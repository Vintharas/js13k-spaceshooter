!function(e){var n={};function t(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,t),i.l=!0,i.exports}t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var i in e)t.d(r,i,function(n){return e[n]}.bind(null,i));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=0)}([function(e,n,t){"use strict";t.r(n);t(1),t(4);document.body.appendChild(function(){var e=document.createElement("div");return e.innerHTML="Hello webpack",e}()),kontra.init();var r=[];function i(e){return e*Math.PI/180}var o=kontra.sprite({type:"ship",x:300,y:300,width:6,rotation:0,dt:0,ttl:1/0,render:function(){this.context.save(),this.context.translate(this.x,this.y),this.context.rotate(i(this.rotation)),this.context.beginPath(),this.context.moveTo(-3,-5),this.context.lineTo(12,0),this.context.lineTo(-3,5),this.context.closePath(),this.context.stroke(),this.context.restore()},update:function(){kontra.keys.pressed("left")?this.rotation+=-4:kontra.keys.pressed("right")&&(this.rotation+=4);var e=Math.cos(i(this.rotation)),n=Math.sin(i(this.rotation));if(kontra.keys.pressed("up")?(this.ddx=.1*e,this.ddy=.1*n):this.ddx=this.ddy=0,this.advance(),Math.sqrt(this.dx*this.dx+this.dy*this.dy)>10&&(this.dx*=.95,this.dy*=.95),this.dt+=1/60,kontra.keys.pressed("space")&&this.dt>.25){this.dt=0;var t=kontra.sprite({type:"bullet",x:this.x+12*e,y:this.y+12*n,dx:this.dx+5*e,dy:this.dy+5*n,ttl:50,width:2,height:2,color:"white"});r.push(t)}}});function a(e,n,t){var i=kontra.sprite({type:"asteroid",x:e,y:n,radius:t,ttl:1/0,dx:4*Math.random()-2,dy:4*Math.random()-2,render:function(){this.context.strokeStyle="white",this.context.beginPath(),this.context.arc(this.x,this.y,this.radius,0,2*Math.PI),this.context.stroke()}});r.push(i)}r.push(o);for(var s=0;s<4;s++)a(100,100,30);kontra.gameLoop({update:function(){r.map(function(e){e.update(),e.x<0?e.x=kontra.canvas.width:e.x>kontra.canvas.width&&(e.x=0),e.y<0?e.y=kontra.canvas.height:e.y>kontra.canvas.height&&(e.y=0)});for(var e=0;e<r.length;e++)if("asteroid"===r[e].type)for(var n=e+1;n<r.length;n++)if("asteroid"!==r[n].type){var t=r[e],i=r[n],o=t.x-i.x,s=t.y-i.y;if(Math.sqrt(o*o+s*s)<t.radius+i.width){if(t.ttl=0,i.ttl=0,t.radius>10)for(var l=0;l<3;l++)a(t.x,t.y,t.radius/2.5);break}}r=r.filter(function(e){return e.isAlive()})},render:function(){r.forEach(function(e){return e.render()})}}).start()},function(e,n,t){t(2)(t(3))},function(e,n){e.exports=function(e){function n(e){"undefined"!=typeof console&&(console.error||console.log)("[Script Loader]",e)}try{"undefined"!=typeof execScript&&"undefined"!=typeof attachEvent&&"undefined"==typeof addEventListener?execScript(e):"undefined"!=typeof eval?eval.call(null,e):n("EvalError: No eval function available")}catch(e){n(e)}}},function(e,n){e.exports="this.kontra = {\n\n  /**\n   * Initialize the canvas.\n   * @memberof kontra\n   *\n   * @param {string|HTMLCanvasElement} canvas - Main canvas ID or Element for the game.\n   */\n  init(canvas) {\n\n    // check if canvas is a string first, an element next, or default to getting\n    // first canvas on page\n    var canvasEl = this.canvas = document.getElementById(canvas) ||\n                                 canvas ||\n                                 document.querySelector('canvas');\n\n    // @if DEBUG\n    if (!canvasEl) {\n      throw Error('You must provide a canvas element for the game');\n    }\n    // @endif\n\n    this.context = canvasEl.getContext('2d');\n  },\n\n  /**\n   * Noop function.\n   * @see https://stackoverflow.com/questions/21634886/what-is-the-javascript-convention-for-no-operation#comment61796464_33458430\n   * @memberof kontra\n   * @private\n   *\n   * The new operator is required when using sinon.stub to replace with the noop.\n   */\n  _noop: new Function,\n\n  /**\n   * Dispatch event to any part of the code that needs to know when\n   * a new frame has started. Will be filled out in pointer events.\n   * @memberOf kontra\n   * @private\n   */\n  _tick: new Function\n};\n(function() {\n  let imageRegex = /(jpeg|jpg|gif|png)$/;\n  let audioRegex = /(wav|mp3|ogg|aac)$/;\n  let noRegex = /^no$/;\n  let leadingSlash = /^\\//;\n  let trailingSlash = /\\/$/;\n  let assets;\n\n  // audio playability\n  // @see https://github.com/Modernizr/Modernizr/blob/master/feature-detects/audio.js\n  let audio = new Audio();\n  let canUse = {\n    wav: '',\n    mp3: audio.canPlayType('audio/mpeg;').replace(noRegex,''),\n    ogg: audio.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(noRegex,''),\n    aac: audio.canPlayType('audio/aac;').replace(noRegex,'')\n  };\n\n  /**\n   * Join a base path and asset path.\n   *\n   * @param {string} base - The asset base path.\n   * @param {string} url - The URL to the asset.\n   *\n   * @returns {string}\n   */\n  function joinPath(base, url) {\n    return [base.replace(trailingSlash, ''), base ? url.replace(leadingSlash, '') : url]\n      .filter(s => s)\n      .join('/')\n  }\n\n  /**\n   * Get the extension of an asset.\n   *\n   * @param {string} url - The URL to the asset.\n   *\n   * @returns {string}\n   */\n  function getExtension(url) {\n    return url.split('.').pop();\n  }\n\n  /**\n   * Get the name of an asset.\n   *\n   * @param {string} url - The URL to the asset.\n   *\n   * @returns {string}\n   */\n  function getName(url) {\n    let name = url.replace('.' + getExtension(url), '');\n\n    // remove leading slash if there is no folder in the path\n    // @see https://stackoverflow.com/a/50592629/2124254\n    return name.split('/').length == 2 ? name.replace(leadingSlash, '') : name;\n  }\n\n  /**\n   * Load an Image file. Uses imagePath to resolve URL.\n   * @memberOf kontra.assets\n   * @private\n   *\n   * @param {string} url - The URL to the Image file.\n   *\n   * @returns {Promise} A deferred promise. Promise resolves with the Image.\n   *\n   * @example\n   * kontra.loadImage('car.png');\n   * kontra.loadImage('autobots/truck.png');\n   */\n  function loadImage(originalUrl, url) {\n    return new Promise(function(resolve, reject) {\n      let image = new Image();\n      url = joinPath(assets.imagePath, originalUrl);\n\n      image.onload = function loadImageOnLoad() {\n        assets.images[ getName(originalUrl) ] = assets.images[url] = this;\n        resolve(this);\n      };\n\n      image.onerror = function loadImageOnError() {\n        reject(/* @if DEBUG */ 'Unable to load image ' + /* @endif */ url);\n      };\n\n      image.src = url;\n    });\n  }\n\n  /**\n   * Load an Audio file. Supports loading multiple audio formats which will be resolved by\n   * the browser in the order listed. Uses audioPath to resolve URL.\n   * @memberOf kontra.assets\n   * @private\n   *\n   * @param {string|string[]} url - The URL to the Audio file.\n   *\n   * @returns {Promise} A deferred promise. Promise resolves with the Audio.\n   *\n   * @example\n   * kontra.loadAudio('sound_effects/laser.mp3');\n   * kontra.loadAudio(['explosion.mp3', 'explosion.m4a', 'explosion.ogg']);\n   */\n  function loadAudio(originalUrl, url, undefined) {\n    return new Promise(function(resolve, reject) {\n\n      // determine which audio format the browser can play\n      originalUrl = [].concat(originalUrl).reduce(function(a, source) {\n        return canUse[ getExtension(source) ] ? source : a\n      }, undefined);\n\n      if (!originalUrl) {\n        reject(/* @if DEBUG */ 'cannot play any of the audio formats provided' + /* @endif */ originalUrl);\n      }\n      else {\n        let audio = new Audio();\n        url = joinPath(assets.audioPath, originalUrl);\n\n        audio.addEventListener('canplay', function loadAudioOnLoad() {\n          assets.audio[ getName(originalUrl) ] = assets.audio[url] = this;\n          resolve(this);\n        });\n\n        audio.onerror = function loadAudioOnError() {\n          reject(/* @if DEBUG */ 'Unable to load audio ' + /* @endif */ url);\n        };\n\n        audio.src = url;\n        audio.load();\n      }\n    });\n  }\n\n  /**\n   * Load a data file (be it text or JSON). Uses dataPath to resolve URL.\n   * @memberOf kontra.assets\n   * @private\n   *\n   * @param {string} url - The URL to the data file.\n   *\n   * @returns {Promise} A deferred promise. Resolves with the data or parsed JSON.\n   *\n   * @example\n   * kontra.loadData('bio.json');\n   * kontra.loadData('dialog.txt');\n   */\n  function loadData(originalUrl, url) {\n    url = joinPath(assets.dataPath, originalUrl);\n\n    return fetch(url).then(function(response) {\n      if (!response.ok) throw response;\n      return response.clone().json().catch(function() { return response.text() })\n    }).then(function(data) {\n      assets.data[ getName(originalUrl) ] = assets.data[url] = data;\n      return data;\n    });\n  }\n\n  /**\n   * Object for loading assets.\n   */\n  assets = kontra.assets = {\n    // all assets are stored by name as well as by URL\n    images: {},\n    audio: {},\n    data: {},\n\n    // base asset path for determining asset URLs\n    imagePath: '',\n    audioPath: '',\n    dataPath: '',\n\n    /**\n     * Load an Image, Audio, or data file.\n     * @memberOf kontra.assets\n     *\n     * @param {string|string[]} - Comma separated list of assets to load.\n     *\n     * @returns {Promise}\n     *\n     * @example\n     * kontra.loadAsset('car.png');\n     * kontra.loadAsset(['explosion.mp3', 'explosion.ogg']);\n     * kontra.loadAsset('bio.json');\n     * kontra.loadAsset('car.png', ['explosion.mp3', 'explosion.ogg'], 'bio.json');\n     */\n    load() {\n      let promises = [];\n      let url, extension, asset, i, promise;\n\n      for (i = 0; (asset = arguments[i]); i++) {\n        url = [].concat(asset)[0];\n\n        extension = getExtension(url);\n        if (extension.match(imageRegex)) {\n          promise = loadImage(asset);\n        }\n        else if (extension.match(audioRegex)) {\n          promise = loadAudio(asset);\n        }\n        else {\n          promise = loadData(asset);\n        }\n\n        promises.push(promise);\n      }\n\n      return Promise.all(promises);\n    },\n\n    // expose properties for testing\n    /* @if DEBUG */\n    _canUse: canUse\n    /* @endif */\n  };\n})();\n(function() {\n\n  /**\n   * Game loop that updates and renders the game every frame.\n   * @memberof kontra\n   *\n   * @param {object}   properties - Properties of the game loop.\n   * @param {number}   [properties.fps=60] - Desired frame rate.\n   * @param {boolean}  [properties.clearCanvas=true] - Clear the canvas every frame.\n   * @param {function} properties.update - Function called to update the game.\n   * @param {function} properties.render - Function called to render the game.\n   */\n  kontra.gameLoop = function(properties) {\n    properties = properties || {};\n\n    // check for required functions\n    // @if DEBUG\n    if ( !(properties.update && properties.render) ) {\n      throw Error('You must provide update() and render() functions');\n    }\n    // @endif\n\n    // animation variables\n    let fps = properties.fps || 60;\n    let accumulator = 0;\n    let delta = 1E3 / fps;  // delta between performance.now timings (in ms)\n    let step = 1 / fps;\n\n    let clear = (properties.clearCanvas === false ?\n                kontra._noop :\n                function clear() {\n                  kontra.context.clearRect(0,0,kontra.canvas.width,kontra.canvas.height);\n                });\n    let last, rAF, now, dt;\n\n    /**\n     * Called every frame of the game loop.\n     */\n    function frame() {\n      rAF = requestAnimationFrame(frame);\n\n      now = performance.now();\n      dt = now - last;\n      last = now;\n\n      // prevent updating the game with a very large dt if the game were to lose focus\n      // and then regain focus later\n      if (dt > 1E3) {\n        return;\n      }\n\n      kontra._tick();\n      accumulator += dt;\n\n      while (accumulator >= delta) {\n        gameLoop.update(step);\n\n        accumulator -= delta;\n      }\n\n      clear();\n      gameLoop.render();\n    }\n\n    // game loop object\n    let gameLoop = {\n      update: properties.update,\n      render: properties.render,\n      isStopped: true,\n\n      /**\n       * Start the game loop.\n       * @memberof kontra.gameLoop\n       */\n      start() {\n        last = performance.now();\n        this.isStopped = false;\n        requestAnimationFrame(frame);\n      },\n\n      /**\n       * Stop the game loop.\n       */\n      stop() {\n        this.isStopped = true;\n        cancelAnimationFrame(rAF);\n      },\n\n      // expose properties for testing\n      // @if DEBUG\n      _frame: frame,\n      set _last(value) {\n        last = value;\n      }\n      // @endif\n    };\n\n    return gameLoop;\n  };\n})();\n(function() {\n  let callbacks = {};\n  let pressedKeys = {};\n\n  let keyMap = {\n    // named keys\n    13: 'enter',\n    27: 'esc',\n    32: 'space',\n    37: 'left',\n    38: 'up',\n    39: 'right',\n    40: 'down'\n  };\n\n  // alpha keys\n  // @see https://stackoverflow.com/a/43095772/2124254\n  for (let i = 0; i < 26; i++) {\n    keyMap[65+i] = (10 + i).toString(36);\n  }\n  // numeric keys\n  for (i = 0; i < 10; i++) {\n    keyMap[48+i] = ''+i;\n  }\n\n  addEventListener('keydown', keydownEventHandler);\n  addEventListener('keyup', keyupEventHandler);\n  addEventListener('blur', blurEventHandler);\n\n  /**\n   * Execute a function that corresponds to a keyboard key.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function keydownEventHandler(e) {\n    let key = keyMap[e.which];\n    pressedKeys[key] = true;\n\n    if (callbacks[key]) {\n      callbacks[key](e);\n    }\n  }\n\n  /**\n   * Set the released key to not being pressed.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function keyupEventHandler(e) {\n    pressedKeys[ keyMap[e.which] ] = false;\n  }\n\n  /**\n   * Reset pressed keys.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function blurEventHandler(e) {\n    pressedKeys = {};\n  }\n\n  /**\n   * Object for using the keyboard.\n   */\n  kontra.keys = {\n    /**\n     * Register a function to be called on a key press.\n     * @memberof kontra.keys\n     *\n     * @param {string|string[]} keys - key or keys to bind.\n     */\n    bind(keys, callback) {\n      // smaller than doing `Array.isArray(keys) ? keys : [keys]`\n      [].concat(keys).map(function(key) {\n        callbacks[key] = callback;\n      })\n    },\n\n    /**\n     * Remove the callback function for a key.\n     * @memberof kontra.keys\n     *\n     * @param {string|string[]} keys - key or keys to unbind.\n     */\n    unbind(keys, undefined) {\n      [].concat(keys).map(function(key) {\n        callbacks[key] = undefined;\n      })\n    },\n\n    /**\n     * Returns whether a key is pressed.\n     * @memberof kontra.keys\n     *\n     * @param {string} key - Key to check for press.\n     *\n     * @returns {boolean}\n     */\n    pressed(key) {\n      return !!pressedKeys[key];\n    }\n  };\n})();\n(function() {\n  let pointer;\n\n  // save each object as they are rendered to determine which object\n  // is on top when multiple objects are the target of an event.\n  // we'll always use the last frame's object order so we know\n  // the finalized order of all objects, otherwise an object could ask\n  // if it's being hovered when it's rendered first even if other objects\n  // would block it later in the render order\n  let thisFrameRenderOrder = [];\n  let lastFrameRenderOrder = [];\n\n  let callbacks = {};\n  let trackedObjects = [];\n  let pressedButtons = {};\n\n  let buttonMap = {\n    0: 'left',\n    1: 'middle',\n    2: 'right'\n  };\n\n  addEventListener('mousedown', pointerDownHandler);\n  addEventListener('touchstart', pointerDownHandler);\n  addEventListener('mouseup', pointerUpHandler);\n  addEventListener('touchend', pointerUpHandler);\n  addEventListener('blur', blurEventHandler);\n  addEventListener('mousemove', mouseMoveHandler);\n\n  /**\n   * Detection collision between a rectangle and a circle.\n   * @see https://yal.cc/rectangle-circle-intersection-test/\n   * @private\n   *\n   * @param {object} object - Object to check collision against.\n   */\n  function circleRectCollision(object) {\n    let dx = pointer.x - Math.max(object.x, Math.min(pointer.x, object.x + object.width));\n    let dy = pointer.y - Math.max(object.y, Math.min(pointer.y, object.y + object.height));\n    return (dx * dx + dy * dy) < (pointer.radius * pointer.radius);\n  }\n\n  /**\n   * Get the first on top object that the pointer collides with.\n   * @private\n   *\n   * @returns {object} First object to collide with the pointer.\n   */\n  function getCurrentObject() {\n\n    // if pointer events are required on the very first frame or without a game loop,\n    // use the current frame order array\n    let frameOrder = (lastFrameRenderOrder.length ? lastFrameRenderOrder : thisFrameRenderOrder);\n    let length = frameOrder.length - 1;\n    let object, collides;\n\n    for (let i = length; i >= 0; i--) {\n      object = frameOrder[i];\n\n      if (object.collidesWithPointer) {\n        collides = object.collidesWithPointer(pointer);\n      }\n      else {\n        collides = circleRectCollision(object);\n      }\n\n      if (collides) {\n        return object;\n      }\n    }\n  }\n\n  /**\n   * Execute the onDown callback for an object.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function pointerDownHandler(e) {\n    pressedButtons[ buttonMap[e.button] ] = true;\n    pointerHandler(e, 'onDown');\n  }\n\n  /**\n   * Execute the onUp callback for an object.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function pointerUpHandler(e) {\n    pressedButtons[ buttonMap[e.button] ] = false;\n    pointerHandler(e, 'onUp');\n  }\n\n  /**\n   * Track the position of the mouse.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function mouseMoveHandler(e) {\n    pointerHandler(e, 'onOver');\n  }\n\n  /**\n   * Reset pressed buttons.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function blurEventHandler(e) {\n    pressedButtons = {};\n  }\n\n  /**\n   * Find the first object for the event and execute it's callback function\n   * @private\n   *\n   * @param {Event} e\n   * @param {string} event - Which event was called.\n   */\n  function pointerHandler(e, event) {\n    if (!kontra.canvas) return;\n\n    let clientX, clientY;\n\n    if (e.type.indexOf('mouse') !== -1) {\n      clientX = e.clientX;\n      clientY = e.clientY;\n    }\n    else {\n      // touchstart uses touches while touchend uses changedTouches\n      // @see https://stackoverflow.com/questions/17957593/how-to-capture-touchend-coordinates\n      clientX = (e.touches[0] || e.changedTouches[0]).clientX;\n      clientY = (e.touches[0] || e.changedTouches[0]).clientY;\n    }\n\n    pointer.x = clientX - kontra.canvas.offsetLeft;\n    pointer.y = clientY - kontra.canvas.offsetTop;\n\n    let object;\n    if (e.target === kontra.canvas) {\n      object = getCurrentObject();\n      if (object && object[event]) {\n        object[event]();\n      }\n    }\n\n    if (callbacks[event]) {\n      callbacks[event](e, object);\n    }\n  }\n\n  /**\n   * Object for using the pointer.\n   */\n  pointer = kontra.pointer = {\n    x: 0,\n    y: 0,\n    radius: 5,  // arbitrary size\n\n    /**\n     * Register object to be tracked by pointer events.\n     * @memberof kontra.pointer\n     *\n     * @param {object|object[]} objects - Object or objects to track.\n     */\n    track(objects) {\n      [].concat(objects).map(function(object) {\n\n        // override the objects render function to keep track of render order\n        if (!object._r) {\n          object._r = object.render;\n\n          object.render = function() {\n            thisFrameRenderOrder.push(this);\n            this._r();\n          };\n\n          trackedObjects.push(object);\n        }\n      });\n    },\n\n    /**\n     * Remove object from being tracked by pointer events.\n     * @memberof kontra.pointer\n     *\n     * @param {object|object[]} objects - Object or objects to stop tracking.\n     */\n    untrack(objects, undefined) {\n      [].concat(objects).map(function(object) {\n\n        // restore original render function to no longer track render order\n        object.render = object._r;\n        object._r = undefined;\n\n        let index = trackedObjects.indexOf(object);\n        if (index !== -1) {\n          trackedObjects.splice(index, 1);\n        }\n      })\n    },\n\n    /**\n     * Returns whether a tracked object is under the pointer.\n     * @memberof kontra.pointer\n     *\n     * @param {object} object - Object to check\n     *\n     * @returns {boolean}\n     */\n    over(object) {\n      if (trackedObjects.indexOf(object) === -1) return false;\n\n      return getCurrentObject() === object;\n    },\n\n    /**\n     * Register a function to be called on pointer down.\n     * @memberof kontra.pointer\n     *\n     * @param {function} callback - Function to execute\n     */\n    onDown(callback) {\n      callbacks.onDown = callback;\n    },\n\n    /**\n     * Register a function to be called on pointer up.\n     * @memberof kontra.pointer\n     *\n     * @param {function} callback - Function to execute\n     */\n    onUp(callback) {\n      callbacks.onUp = callback;\n    },\n\n    /**\n     * Returns whether the button is pressed.\n     * @memberof kontra.pointer\n     *\n     * @param {string} button - Button to check for press.\n     *\n     * @returns {boolean}\n     */\n    pressed(button) {\n      return !!pressedButtons[button]\n    }\n  };\n\n  // reset object render order on every new frame\n  kontra._tick = function() {\n    lastFrameRenderOrder.length = 0;\n\n    thisFrameRenderOrder.map(function(object) {\n      lastFrameRenderOrder.push(object);\n    });\n\n    thisFrameRenderOrder.length = 0;\n  };\n})();\n(function() {\n\n  /**\n   * Object pool. The pool will grow in size to accommodate as many objects as are needed.\n   * Unused items are at the front of the pool and in use items are at the of the pool.\n   * @memberof kontra\n   *\n   * @param {object} properties - Properties of the pool.\n   * @param {function} properties.create - Function that returns the object to use in the pool.\n   * @param {number} properties.maxSize - The maximum size that the pool will grow to.\n   */\n  kontra.pool = function(properties) {\n    properties = properties || {};\n\n    let inUse = 0;\n\n    // check for the correct structure of the objects added to pools so we know that the\n    // rest of the pool code will work without errors\n    // @if DEBUG\n    let obj;\n    if (!properties.create ||\n        ( !( obj = properties.create() ) ||\n          !( obj.update && obj.init &&\n             obj.isAlive )\n       )) {\n      throw Error('Must provide create() function which returns an object with init(), update(), and isAlive() functions');\n    }\n    // @endif\n\n    return {\n      _c: properties.create,\n\n      // start the pool with an object\n      objects: [properties.create()],\n      size: 1,\n      maxSize: properties.maxSize || Infinity,\n\n      /**\n       * Get an object from the pool.\n       * @memberof kontra.pool\n       *\n       * @param {object} properties - Properties to pass to object.init().\n       */\n      get(properties) {\n        properties = properties || {};\n\n        // the pool is out of objects if the first object is in use and it can't grow\n        if (this.objects[0].isAlive()) {\n          if (this.size === this.maxSize) {\n            return;\n          }\n          // double the size of the array by filling it with twice as many objects\n          else {\n            for (let x = 0; x < this.size && this.objects.length < this.maxSize; x++) {\n              this.objects.unshift(this._c());\n            }\n\n            this.size = this.objects.length;\n          }\n        }\n\n        // save off first object in pool to reassign to last object after unshift\n        let obj = this.objects.shift();\n        obj.init(properties);\n        this.objects.push(obj);\n        inUse++;\n      },\n\n      /**\n       * Return all objects that are alive from the pool.\n       * @memberof kontra.pool\n       *\n       * @returns {object[]}\n       */\n      getAliveObjects() {\n        return this.objects.slice(this.objects.length - inUse);\n      },\n\n      /**\n       * Clear the object pool.\n       * @memberof kontra.pool\n       */\n      clear() {\n        inUse = this.objects.length = 0;\n        this.size = 1;\n        this.objects.push(this._c());\n      },\n\n      /**\n       * Update all alive pool objects.\n       * @memberof kontra.pool\n       *\n       * @param {number} dt - Time since last update.\n       */\n      update(dt) {\n        let i = this.size - 1;\n        let obj;\n\n        // If the user kills an object outside of the update cycle, the pool won't know of\n        // the change until the next update and inUse won't be decremented. If the user then\n        // gets an object when inUse is the same size as objects.length, inUse will increment\n        // and this statement will evaluate to -1.\n        //\n        // I don't like having to go through the pool to kill an object as it forces you to\n        // know which object came from which pool. Instead, we'll just prevent the index from\n        // going below 0 and accept the fact that inUse may be out of sync for a frame.\n        let index = Math.max(this.objects.length - inUse, 0);\n\n        // only iterate over the objects that are alive\n        while (i >= index) {\n          obj = this.objects[i];\n\n          obj.update(dt);\n\n          // if the object is dead, move it to the front of the pool\n          if (!obj.isAlive()) {\n            this.objects = this.objects.splice(i, 1).concat(this.objects);\n            inUse--;\n            index++;\n          }\n          else {\n            i--;\n          }\n        }\n      },\n\n      /**\n       * render all alive pool objects.\n       * @memberof kontra.pool\n       */\n      render() {\n        let index = Math.max(this.objects.length - inUse, 0);\n\n        for (let i = this.size - 1; i >= index; i--) {\n          this.objects[i].render();\n        }\n      }\n    };\n  };\n})();\n(function() {\n\n  /**\n   * A quadtree for 2D collision checking. The quadtree acts like an object pool in that it\n   * will create subnodes as objects are needed but it won't clean up the subnodes when it\n   * collapses to avoid garbage collection.\n   * @memberof kontra\n   *\n   * @param {object} properties - Properties of the quadtree.\n   * @param {number} [properties.maxDepth=3] - Maximum node depths the quadtree can have.\n   * @param {number} [properties.maxObjects=25] - Maximum number of objects a node can support before splitting.\n   * @param {object} [properties.bounds] - The 2D space this node occupies.\n   * @param {object} [properties.parent] - Private. The node that contains this node.\n   * @param {number} [properties.depth=0] - Private. Current node depth.\n   *\n   * The quadrant indices are numbered as follows (following a z-order curve):\n   *     |\n   *  0  |  1\n   * ----+----\n   *  2  |  3\n   *     |\n   */\n  kontra.quadtree = function(properties) {\n    properties = properties || {};\n\n    return {\n      maxDepth: properties.maxDepth || 3,\n      maxObjects: properties.maxObjects || 25,\n\n      // since we won't clean up any subnodes, we need to keep track of which nodes are\n      // currently the leaf node so we know which nodes to add objects to\n      // b = branch, d = depth, p = parent\n      _b: false,\n      _d: properties.depth || 0,\n      /* @if VISUAL_DEBUG */\n      _p: properties.parent,\n      /* @endif */\n\n      bounds: properties.bounds || {\n        x: 0,\n        y: 0,\n        width: kontra.canvas.width,\n        height: kontra.canvas.height\n      },\n\n      objects: [],\n      subnodes: [],\n\n      /**\n       * Clear the quadtree\n       * @memberof kontra.quadtree\n       */\n      clear() {\n        this.subnodes.map(function(subnode) {\n          subnode.clear();\n        });\n\n        this._b = false;\n        this.objects.length = 0;\n      },\n\n      /**\n       * Find the leaf node the object belongs to and get all objects that are part of\n       * that node.\n       * @memberof kontra.quadtree\n       *\n       * @param {object} object - Object to use for finding the leaf node.\n       *\n       * @returns {object[]} A list of objects in the same leaf node as the object.\n       */\n      get(object) {\n        let objects = [];\n        let indices, i;\n\n        // traverse the tree until we get to a leaf node\n        while (this.subnodes.length && this._b) {\n          indices = this._g(object);\n\n          for (i = 0; i < indices.length; i++) {\n            objects.push.apply(objects, this.subnodes[ indices[i] ].get(object));\n          }\n\n          return objects;\n        }\n\n        return this.objects;\n      },\n\n      /**\n       * Add an object to the quadtree. Once the number of objects in the node exceeds\n       * the maximum number of objects allowed, it will split and move all objects to their\n       * corresponding subnodes.\n       * @memberof kontra.quadtree\n       *\n       * @param {...object|object[]} Objects to add to the quadtree\n       *\n       * @example\n       * kontra.quadtree().add({id:1}, {id:2}, {id:3});\n       * kontra.quadtree().add([{id:1}, {id:2}], {id:3});\n       */\n      add() {\n        let i, j, object, obj, indices, index;\n\n        for (j = 0; j < arguments.length; j++) {\n          object = arguments[j];\n\n          // add a group of objects separately\n          if (Array.isArray(object)) {\n            this.add.apply(this, object);\n\n            continue;\n          }\n\n          // current node has subnodes, so we need to add this object into a subnode\n          if (this._b) {\n            this._a(object);\n\n            continue;\n          }\n\n          // this node is a leaf node so add the object to it\n          this.objects.push(object);\n\n          // split the node if there are too many objects\n          if (this.objects.length > this.maxObjects && this._d < this.maxDepth) {\n            this._s();\n\n            // move all objects to their corresponding subnodes\n            for (i = 0; (obj = this.objects[i]); i++) {\n              this._a(obj);\n            }\n\n            this.objects.length = 0;\n          }\n        }\n      },\n\n      /**\n       * Add an object to a subnode.\n       * @memberof kontra.quadtree\n       * @private\n       *\n       * @param {object} object - Object to add into a subnode\n       */\n      // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#use-placeholder-arguments-instead-of-var\n      _a(object, indices, i) {\n        indices = this._g(object);\n\n        // add the object to all subnodes it intersects\n        for (i = 0; i < indices.length; i++) {\n          this.subnodes[ indices[i] ].add(object);\n        }\n      },\n\n      /**\n       * Determine which subnodes the object intersects with.\n       * @memberof kontra.quadtree\n       * @private\n       *\n       * @param {object} object - Object to check.\n       *\n       * @returns {number[]} List of all subnodes object intersects.\n       */\n      _g(object) {\n        let indices = [];\n\n        let verticalMidpoint = this.bounds.x + this.bounds.width / 2;\n        let horizontalMidpoint = this.bounds.y + this.bounds.height / 2;\n\n        // save off quadrant checks for reuse\n        let intersectsTopQuadrants = object.y < horizontalMidpoint && object.y + object.height >= this.bounds.y;\n        let intersectsBottomQuadrants = object.y + object.height >= horizontalMidpoint && object.y < this.bounds.y + this.bounds.height;\n\n        // object intersects with the left quadrants\n        if (object.x < verticalMidpoint && object.x + object.width >= this.bounds.x) {\n          if (intersectsTopQuadrants) {  // top left\n            indices.push(0);\n          }\n\n          if (intersectsBottomQuadrants) {  // bottom left\n            indices.push(2);\n          }\n        }\n\n        // object intersects with the right quadrants\n        if (object.x + object.width >= verticalMidpoint && object.x < this.bounds.x + this.bounds.width) {  // top right\n          if (intersectsTopQuadrants) {\n            indices.push(1);\n          }\n\n          if (intersectsBottomQuadrants) {  // bottom right\n            indices.push(3);\n          }\n        }\n\n        return indices;\n      },\n\n      /**\n       * Split the node into four subnodes.\n       * @memberof kontra.quadtree\n       * @private\n       */\n      // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#use-placeholder-arguments-instead-of-var\n      _s(subWidth, subHeight, i) {\n        this._b = true;\n\n        // only split if we haven't split before\n        if (this.subnodes.length) {\n          return;\n        }\n\n        subWidth = this.bounds.width / 2 | 0;\n        subHeight = this.bounds.height / 2 | 0;\n\n        for (i = 0; i < 4; i++) {\n          this.subnodes[i] = kontra.quadtree({\n            bounds: {\n              x: this.bounds.x + (i % 2 === 1 ? subWidth : 0),  // nodes 1 and 3\n              y: this.bounds.y + (i >= 2 ? subHeight : 0),      // nodes 2 and 3\n              width: subWidth,\n              height: subHeight\n            },\n            depth: this._d+1,\n            maxDepth: this.maxDepth,\n            maxObjects: this.maxObjects,\n            /* @if VISUAL_DEBUG */\n            parent: this\n            /* @endif */\n          });\n        }\n      },\n\n      /**\n       * Draw the quadtree. Useful for visual debugging.\n       * @memberof kontra.quadtree\n       */\n       /* @if VISUAL_DEBUG **\n       render() {\n         // don't draw empty leaf nodes, always draw branch nodes and the first node\n         if (this.objects.length || this._d === 0 ||\n             (this._p && this._p._b)) {\n\n           kontra.context.strokeStyle = 'red';\n           kontra.context.strokeRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);\n\n           if (this.subnodes.length) {\n             for (let i = 0; i < 4; i++) {\n               this.subnodes[i].render();\n             }\n           }\n         }\n       }\n       /* @endif */\n    };\n  };\n})();\n(function() {\n\n  class Vector {\n    /**\n     * Initialize the vectors x and y position.\n     * @memberof kontra.vector\n     * @private\n     *\n     * @param {number} [x=0] - X coordinate.\n     * @param {number} [y=0] - Y coordinate.\n     *\n     * @returns {vector}\n     */\n    constructor(x, y) {\n      this._x = x || 0;\n      this._y = y || 0;\n    }\n\n    /**\n     * Add a vector to this vector.\n     * @memberof kontra.vector\n     *\n     * @param {vector} vector - Vector to add.\n     * @param {number} dt=1 - Time since last update.\n     */\n    add(vector, dt) {\n      this.x += (vector.x || 0) * (dt || 1);\n      this.y += (vector.y || 0) * (dt || 1);\n    }\n\n    /**\n     * Clamp the vector between two points that form a rectangle.\n     * @memberof kontra.vector\n     *\n     * @param {number} xMin - Min x value.\n     * @param {number} yMin - Min y value.\n     * @param {number} xMax - Max x value.\n     * @param {number} yMax - Max y value.\n     */\n    clamp(xMin, yMin, xMax, yMax) {\n      this._c = true;\n      this._a = xMin;\n      this._b = yMin;\n      this._d = xMax;\n      this._e = yMax;\n    }\n\n    /**\n     * Vector x\n     * @memberof kontra.vector\n     *\n     * @property {number} x\n     */\n    get x() {\n      return this._x;\n    }\n\n    /**\n     * Vector y\n     * @memberof kontra.vector\n     *\n     * @property {number} y\n     */\n    get y() {\n      return this._y;\n    }\n\n    set x(value) {\n      this._x = (this._c ? Math.min( Math.max(this._a, value), this._d ) : value);\n    }\n\n    set y(value) {\n      this._y = (this._c ? Math.min( Math.max(this._b, value), this._e ) : value);\n    }\n  }\n\n  /**\n   * A vector for 2D space.\n   * @memberof kontra\n   *\n   * @param {number} [x=0] - X coordinate.\n   * @param {number} [y=0] - Y coordinate.\n   */\n  kontra.vector = (x, y) => {\n    return new Vector(x, y);\n  };\n  kontra.vector.prototype = Vector.prototype;\n\n\n\n\n\n  class Sprite {\n    /**\n     * Initialize properties on the sprite.\n     * @memberof kontra.sprite\n     *\n     * @param {object} properties - Properties of the sprite.\n     * @param {number} properties.x - X coordinate of the sprite.\n     * @param {number} properties.y - Y coordinate of the sprite.\n     * @param {number} [properties.dx] - Change in X position.\n     * @param {number} [properties.dy] - Change in Y position.\n     * @param {number} [properties.ddx] - Change in X velocity.\n     * @param {number} [properties.ddy] - Change in Y velocity.\n     *\n     * @param {number} [properties.ttl=0] - How may frames the sprite should be alive.\n     * @param {Context} [properties.context=kontra.context] - Provide a context for the sprite to draw on.\n     *\n     * @param {Image|Canvas} [properties.image] - Image for the sprite.\n     *\n     * @param {object} [properties.animations] - Animations for the sprite instead of an image.\n     *\n     * @param {string} [properties.color] - If no image or animation is provided, use color to draw a rectangle for the sprite.\n     * @param {number} [properties.width] - Width of the sprite for drawing a rectangle.\n     * @param {number} [properties.height] - Height of the sprite for drawing a rectangle.\n     *\n     * @param {function} [properties.update] - Function to use to update the sprite.\n     * @param {function} [properties.render] - Function to use to render the sprite.\n     *\n     * If you need the sprite to live forever, or just need it to stay on screen until you\n     * decide when to kill it, you can set <code>ttl</code> to <code>Infinity</code>.\n     * Just be sure to set <code>ttl</code> to 0 when you want the sprite to die.\n     */\n    // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#use-placeholder-arguments-instead-of-var\n    init(properties, prop, temp, firstAnimation) {\n      properties = properties || {};\n\n      this.position = kontra.vector(properties.x, properties.y);\n      this.velocity = kontra.vector(properties.dx, properties.dy);\n      this.acceleration = kontra.vector(properties.ddx, properties.ddy);\n\n      // defaults\n      this.width = this.height = 0;\n      this.context = kontra.context;\n\n      // loop through properties before overrides\n      for (prop in properties) {\n        this[prop] = properties[prop];\n      }\n\n      // image sprite\n      if (temp = properties.image) {\n        this.image = temp;\n        this.width = temp.width;\n        this.height = temp.height;\n      }\n      // animation sprite\n      else if (temp = properties.animations) {\n\n        // clone each animation so no sprite shares an animation\n        for (prop in temp) {\n          this.animations[prop] = temp[prop].clone();\n\n          // default the current animation to the first one in the list\n          firstAnimation = firstAnimation || temp[prop];\n        }\n\n        this._ca = firstAnimation;\n        this.width = firstAnimation.width;\n        this.height = firstAnimation.height;\n      }\n\n      return this;\n    }\n\n    // define getter and setter shortcut functions to make it easier to work with the\n    // position, velocity, and acceleration vectors.\n\n    /**\n     * Sprite position.x\n     * @memberof kontra.sprite\n     *\n     * @property {number} x\n     */\n    get x() {\n      return this.position.x;\n    }\n\n    /**\n     * Sprite position.y\n     * @memberof kontra.sprite\n     *\n     * @property {number} y\n     */\n    get y() {\n      return this.position.y;\n    }\n\n    /**\n     * Sprite velocity.x\n     * @memberof kontra.sprite\n     *\n     * @property {number} dx\n     */\n    get dx() {\n      return this.velocity.x;\n    }\n\n    /**\n     * Sprite velocity.y\n     * @memberof kontra.sprite\n     *\n     * @property {number} dy\n     */\n    get dy() {\n      return this.velocity.y;\n    }\n\n    /**\n     * Sprite acceleration.x\n     * @memberof kontra.sprite\n     *\n     * @property {number} ddx\n     */\n    get ddx() {\n      return this.acceleration.x;\n    }\n\n    /**\n     * Sprite acceleration.y\n     * @memberof kontra.sprite\n     *\n     * @property {number} ddy\n     */\n    get ddy() {\n      return this.acceleration.y;\n    }\n\n    set x(value) {\n      this.position.x = value;\n    }\n    set y(value) {\n      this.position.y = value;\n    }\n    set dx(value) {\n      this.velocity.x = value;\n    }\n    set dy(value) {\n      this.velocity.y = value;\n    }\n    set ddx(value) {\n      this.acceleration.x = value;\n    }\n    set ddy(value) {\n      this.acceleration.y = value;\n    }\n\n    /**\n     * Determine if the sprite is alive.\n     * @memberof kontra.sprite\n     *\n     * @returns {boolean}\n     */\n    isAlive() {\n      return this.ttl > 0;\n    }\n\n    /**\n     * Simple bounding box collision test.\n     * @memberof kontra.sprite\n     *\n     * @param {object} object - Object to check collision against.\n     *\n     * @returns {boolean} True if the objects collide, false otherwise.\n     */\n    collidesWith(object) {\n      return this.x < object.x + object.width &&\n             this.x + this.width > object.x &&\n             this.y < object.y + object.height &&\n             this.y + this.height > object.y;\n    }\n\n    /**\n     * Update the sprites velocity and position.\n     * @memberof kontra.sprite\n     * @abstract\n     *\n     * @param {number} dt - Time since last update.\n     *\n     * This function can be overridden on a per sprite basis if more functionality\n     * is needed in the update step. Just call <code>this.advance()</code> when you need\n     * the sprite to update its position.\n     *\n     * @example\n     * sprite = kontra.sprite({\n     *   update: function update(dt) {\n     *     // do some logic\n     *\n     *     this.advance(dt);\n     *   }\n     * });\n     */\n    update(dt) {\n      this.advance(dt);\n    }\n\n    /**\n     * Render the sprite.\n     * @memberof kontra.sprite.\n     * @abstract\n     *\n     * This function can be overridden on a per sprite basis if more functionality\n     * is needed in the render step. Just call <code>this.draw()</code> when you need the\n     * sprite to draw its image.\n     *\n     * @example\n     * sprite = kontra.sprite({\n     *   render: function render() {\n     *     // do some logic\n     *\n     *     this.draw();\n     *   }\n     * });\n     */\n    render() {\n      this.draw();\n    }\n\n    /**\n     * Play an animation.\n     * @memberof kontra.sprite\n     *\n     * @param {string} name - Name of the animation to play.\n     */\n    playAnimation(name) {\n      this._ca = this.animations[name];\n\n      if (!this._ca.loop) {\n        this._ca.reset();\n      }\n    }\n\n    /**\n     * Advance the sprites position, velocity, and current animation (if it\n     * has one).\n     * @memberof kontra.sprite\n     *\n     * @param {number} dt - Time since last update.\n     */\n    advance(dt) {\n      this.velocity.add(this.acceleration, dt);\n      this.position.add(this.velocity, dt);\n\n      this.ttl--;\n\n      if (this._ca) {\n        this._ca.update(dt);\n      }\n    }\n\n    /**\n     * Draw the sprite to the canvas.\n     * @memberof kontra.sprite\n     */\n    draw() {\n      if (this.image) {\n        this.context.drawImage(this.image, this.x, this.y);\n      }\n      else if (this._ca) {\n        this._ca.render(this);\n      }\n      else {\n        this.context.fillStyle = this.color;\n        this.context.fillRect(this.x, this.y, this.width, this.height);\n      }\n    }\n  };\n\n  /**\n   * A sprite with a position, velocity, and acceleration.\n   * @memberof kontra\n   * @requires kontra.vector\n   *\n   * @param {object} properties - Properties of the sprite.\n   * @param {number} properties.x - X coordinate of the sprite.\n   * @param {number} properties.y - Y coordinate of the sprite.\n   * @param {number} [properties.dx] - Change in X position.\n   * @param {number} [properties.dy] - Change in Y position.\n   * @param {number} [properties.ddx] - Change in X velocity.\n   * @param {number} [properties.ddy] - Change in Y velocity.\n   *\n   * @param {number} [properties.ttl=0] - How may frames the sprite should be alive.\n   * @param {Context} [properties.context=kontra.context] - Provide a context for the sprite to draw on.\n   *\n   * @param {Image|Canvas} [properties.image] - Image for the sprite.\n   *\n   * @param {object} [properties.animations] - Animations for the sprite instead of an image.\n   *\n   * @param {string} [properties.color] - If no image or animation is provided, use color to draw a rectangle for the sprite.\n   * @param {number} [properties.width] - Width of the sprite for drawing a rectangle.\n   * @param {number} [properties.height] - Height of the sprite for drawing a rectangle.\n   *\n   * @param {function} [properties.update] - Function to use to update the sprite.\n   * @param {function} [properties.render] - Function to use to render the sprite.\n   */\n  kontra.sprite = (properties) => {\n    return (new Sprite()).init(properties);\n  };\n  kontra.sprite.prototype = Sprite.prototype;\n})();\n(function() {\n\n  class Animation {\n    /**\n     * Initialize properties on the animation.\n     * @memberof kontra.animation\n     * @private\n     *\n     * @param {object} properties - Properties of the animation.\n     * @param {object} properties.spriteSheet - Sprite sheet for the animation.\n     * @param {number[]} properties.frames - List of frames of the animation.\n     * @param {number}  properties.frameRate - Number of frames to display in one second.\n     * @param {boolean} [properties.loop=true] - If the animation should loop.\n     */\n    // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#use-placeholder-arguments-instead-of-var\n    constructor(properties, frame) {\n      properties = properties || {};\n\n      this.spriteSheet = properties.spriteSheet;\n      this.frames = properties.frames;\n      this.frameRate = properties.frameRate;\n      this.loop = (properties.loop === undefined ? true : properties.loop);\n\n      frame = properties.spriteSheet.frame;\n      this.width = frame.width;\n      this.height = frame.height;\n      this.margin = frame.margin || 0;\n\n      // f = frame, a = accumulator\n      this._f = 0;\n      this._a = 0;\n    }\n\n    /**\n     * Clone an animation to be used more than once.\n     * @memberof kontra.animation\n     *\n     * @returns {object}\n     */\n    clone() {\n      return kontra.animation(this);\n    }\n\n    /**\n     * Reset an animation to the first frame.\n     * @memberof kontra.animation\n     */\n    reset() {\n      this._f = 0;\n      this._a = 0;\n    }\n\n    /**\n     * Update the animation. Used when the animation is not paused or stopped.\n     * @memberof kontra.animation\n     * @private\n     *\n     * @param {number} [dt=1/60] - Time since last update.\n     */\n    update(dt) {\n\n      // if the animation doesn't loop we stop at the last frame\n      if (!this.loop && this._f == this.frames.length-1) return;\n\n      dt = dt || 1 / 60;\n\n      this._a += dt;\n\n      // update to the next frame if it's time\n      while (this._a * this.frameRate >= 1) {\n        this._f = ++this._f % this.frames.length;\n        this._a -= 1 / this.frameRate;\n      }\n    }\n\n    /**\n     * Draw the current frame. Used when the animation is not stopped.\n     * @memberof kontra.animation\n     * @private\n     *\n     * @param {object} properties - How to draw the animation.\n     * @param {number} properties.x - X position to draw.\n     * @param {number} properties.y - Y position to draw.\n     * @param {Context} [properties.context=kontra.context] - Provide a context for the sprite to draw on.\n     */\n    render(properties) {\n      properties = properties || {};\n\n      // get the row and col of the frame\n      let row = this.frames[this._f] / this.spriteSheet._f | 0;\n      let col = this.frames[this._f] % this.spriteSheet._f | 0;\n\n      (properties.context || kontra.context).drawImage(\n        this.spriteSheet.image,\n        col * this.width + (col * 2 + 1) * this.margin,\n        row * this.height + (row * 2 + 1) * this.margin,\n        this.width, this.height,\n        properties.x, properties.y,\n        this.width, this.height\n      );\n    }\n  }\n\n  /**\n   * Single animation from a sprite sheet.\n   * @memberof kontra\n   *\n   * @param {object} properties - Properties of the animation.\n   * @param {object} properties.spriteSheet - Sprite sheet for the animation.\n   * @param {number[]} properties.frames - List of frames of the animation.\n   * @param {number}  properties.frameRate - Number of frames to display in one second.\n   */\n  kontra.animation = function(properties) {\n    return new Animation(properties);\n  };\n  kontra.animation.prototype = Animation.prototype;\n\n\n\n\n\n  class SpriteSheet {\n    /**\n     * Initialize properties on the spriteSheet.\n     * @memberof kontra\n     * @private\n     *\n     * @param {object} properties - Properties of the sprite sheet.\n     * @param {Image|Canvas} properties.image - Image for the sprite sheet.\n     * @param {number} properties.frameWidth - Width (in px) of each frame.\n     * @param {number} properties.frameHeight - Height (in px) of each frame.\n     * @param {number} properties.frameMargin - Margin (in px) between each frame.\n     * @param {object} properties.animations - Animations to create from the sprite sheet.\n     */\n    constructor(properties) {\n      properties = properties || {};\n\n      // @if DEBUG\n      if (!properties.image) {\n        throw Error('You must provide an Image for the SpriteSheet');\n      }\n      // @endif\n\n      this.animations = {};\n      this.image = properties.image;\n      this.frame = {\n        width: properties.frameWidth,\n        height: properties.frameHeight,\n        margin: properties.frameMargin\n      };\n\n      // f = framesPerRow\n      this._f = properties.image.width / properties.frameWidth | 0;\n\n      this.createAnimations(properties.animations);\n    }\n\n    /**\n     * Create animations from the sprite sheet.\n     * @memberof kontra.spriteSheet\n     *\n     * @param {object} animations - List of named animations to create from the Image.\n     * @param {number|string|number[]|string[]} animations.animationName.frames - A single frame or list of frames for this animation.\n     * @param {number} animations.animationName.frameRate - Number of frames to display in one second.\n     *\n     * @example\n     * let sheet = kontra.spriteSheet({image: img, frameWidth: 16, frameHeight: 16});\n     * sheet.createAnimations({\n     *   idle: {\n     *     frames: 1  // single frame animation\n     *   },\n     *   walk: {\n     *     frames: '2..6',  // ascending consecutive frame animation (frames 2-6, inclusive)\n     *     frameRate: 4\n     *   },\n     *   moonWalk: {\n     *     frames: '6..2',  // descending consecutive frame animation\n     *     frameRate: 4\n     *   },\n     *   jump: {\n     *     frames: [7, 12, 2],  // non-consecutive frame animation\n     *     frameRate: 3,\n     *     loop: false\n     *   },\n     *   attack: {\n     *     frames: ['8..10', 13, '10..8'],  // you can also mix and match, in this case frames [8,9,10,13,10,9,8]\n     *     frameRate: 2,\n     *     loop: false\n     *   }\n     * });\n     */\n    createAnimations(animations) {\n      let animation, frames, frameRate, sequence, name;\n\n      for (name in animations) {\n        animation = animations[name];\n        frames = animation.frames;\n\n        // array that holds the order of the animation\n        sequence = [];\n\n        // @if DEBUG\n        if (frames === undefined) {\n          throw Error('Animation ' + name + ' must provide a frames property');\n        }\n        // @endif\n\n        // add new frames to the end of the array\n        [].concat(frames).map(function(frame) {\n          sequence = sequence.concat(this._p(frame));\n        }, this);\n\n        this.animations[name] = kontra.animation({\n          spriteSheet: this,\n          frames: sequence,\n          frameRate: animation.frameRate,\n          loop: animation.loop\n        });\n      }\n    }\n\n    /**\n     * Parse a string of consecutive frames.\n     * @memberof kontra.spriteSheet\n     * @private\n     *\n     * @param {number|string} frames - Start and end frame.\n     *\n     * @returns {number[]} List of frames.\n     */\n    _p(consecutiveFrames, i) {\n      // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#coercion-to-test-for-types\n      if (+consecutiveFrames === consecutiveFrames) {\n        return consecutiveFrames;\n      }\n\n      let sequence = [];\n      let frames = consecutiveFrames.split('..');\n\n      // coerce string to number\n      // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#coercion-to-test-for-types\n      let start = i = +frames[0];\n      let end = +frames[1];\n\n      // ascending frame order\n      if (start < end) {\n        for (; i <= end; i++) {\n          sequence.push(i);\n        }\n      }\n      // descending order\n      else {\n        for (; i >= end; i--) {\n          sequence.push(i);\n        }\n      }\n\n      return sequence;\n    }\n  }\n\n  /**\n   * Create a sprite sheet from an image.\n   * @memberof kontra\n   *\n   * @param {object} properties - Properties of the sprite sheet.\n   * @param {Image|Canvas} properties.image - Image for the sprite sheet.\n   * @param {number} properties.frameWidth - Width (in px) of each frame.\n   * @param {number} properties.frameHeight - Height (in px) of each frame.\n   * @param {number} properties.frameMargin - Margin (in px) between each frame.\n   * @param {object} properties.animations - Animations to create from the sprite sheet.\n   */\n  kontra.spriteSheet = function(properties) {\n    return new SpriteSheet(properties);\n  };\n  kontra.spriteSheet.prototype = SpriteSheet.prototype;\n})();\n/**\n * Object for using localStorage.\n */\nkontra.store = {\n\n  /**\n   * Save an item to localStorage.\n   * @memberof kontra.store\n   *\n   * @param {string} key - Name to store the item as.\n   * @param {*} value - Item to store.\n   */\n  set(key, value) {\n    if (value === undefined) {\n      localStorage.removeItem(key);\n    }\n    else {\n      localStorage.setItem(key, JSON.stringify(value));\n    }\n  },\n\n  /**\n   * Retrieve an item from localStorage and convert it back to it's original type.\n   * @memberof kontra.store\n   *\n   * @param {string} key - Name of the item.\n   *\n   * @returns {*}\n   */\n  get(key) {\n    let value = localStorage.getItem(key);\n\n    try {\n      value = JSON.parse(value);\n    }\n    catch(e) {}\n\n    return value;\n  }\n};\n(function() {\n  // save Math.min and Math.max to variable and use that instead\n\n  /**\n   * A tile engine for rendering tilesets. Works well with the tile engine program Tiled.\n   * @memberof kontra\n   *\n   * @param {object} properties - Properties of the tile engine.\n   * @param {number} [properties.tileWidth=32] - Width of a tile.\n   * @param {number} [properties.tileHeight=32] - Height of a tile.\n   * @param {number} properties.width - Width of the map (in tiles).\n   * @param {number} properties.height - Height of the map (in tiles).\n   * @param {number} [properties.x=0] - X position to draw.\n   * @param {number} [properties.y=0] - Y position to draw.\n   * @param {number} [properties.sx=0] - X position to clip the tileset.\n   * @param {number} [properties.sy=0] - Y position to clip the tileset.\n   * @param {Context} [properties.context=kontra.context] - Provide a context for the tile engine to draw on.\n   */\n  kontra.tileEngine = function(properties) {\n    properties = properties || {};\n\n    // size of the map (in tiles)\n    // @if DEBUG\n    if (!properties.width || !properties.height) {\n      throw Error('You must provide width and height properties');\n    }\n    // @endif\n\n    /**\n     * Get the index of the x, y or row, col.\n     * @memberof kontra.tileEngine\n     * @private\n     *\n     * @param {number} position.x - X coordinate of the tile.\n     * @param {number} position.y - Y coordinate of the tile.\n     * @param {number} position.row - Row of the tile.\n     * @param {number} position.col - Col of the tile.\n     *\n     * @return {number} Returns the tile index or -1 if the x, y or row, col is outside the dimensions of the tile engine.\n     */\n    function getIndex(position) {\n      let row, col;\n\n      if (typeof position.x !== 'undefined' && typeof position.y !== 'undefined') {\n        row = tileEngine.getRow(position.y);\n        col = tileEngine.getCol(position.x);\n      }\n      else {\n        row = position.row;\n        col = position.col;\n      }\n\n      // don't calculate out of bound numbers\n      if (row < 0 || col < 0 || row >= height || col >= width) {\n        return -1;\n      }\n\n      return col + row * width;\n    }\n\n    /**\n     * Modified binary search that will return the tileset associated with the tile\n     * @memberof kontra.tileEngine\n     * @private\n     *\n     * @param {number} tile - Tile grid.\n     *\n     * @return {object}\n     */\n    function getTileset(tile) {\n      let min = 0;\n      let max = tileEngine.tilesets.length - 1;\n      let index, currTile;\n\n      while (min <= max) {\n        index = (min + max) / 2 | 0;\n        currTile = tileEngine.tilesets[index];\n\n        if (tile >= currTile.firstGrid && tile <= currTile.lastGrid) {\n          return currTile;\n        }\n        else if (currTile.lastGrid < tile) {\n          min = index + 1;\n        }\n        else {\n          max = index - 1;\n        }\n      }\n    }\n\n    /**\n     * Pre-render the tiles to make drawing fast.\n     * @memberof kontra.tileEngine\n     * @private\n     */\n    function preRenderImage() {\n      let tile, tileset, image, x, y, sx, sy, tileOffset, w;\n\n      // draw each layer in order\n      for (let i = 0, layer; layer = tileEngine.layers[layerOrder[i]]; i++) {\n        for (let j = 0, len = layer.data.length; j < len; j++) {\n          tile = layer.data[j];\n\n          // skip empty tiles (0)\n          if (!tile) {\n            continue;\n          }\n\n          tileset = getTileset(tile);\n          image = tileset.image;\n\n          x = (j % width) * tileWidth;\n          y = (j / width | 0) * tileHeight;\n\n          tileOffset = tile - tileset.firstGrid;\n          w = image.width / tileWidth;\n\n          sx = (tileOffset % w) * tileWidth;\n          sy = (tileOffset / w | 0) * tileHeight;\n\n          offscreenContext.drawImage(\n            image,\n            sx, sy, tileWidth, tileHeight,\n            x, y, tileWidth, tileHeight\n          );\n        }\n      }\n    }\n\n    let width = properties.width;\n    let height = properties.height;\n\n    // size of the tiles. Most common tile size on opengameart.org seems to be 32x32,\n    // followed by 16x16\n    // Tiled names the property tilewidth and tileheight\n    let tileWidth = properties.tileWidth || properties.tilewidth || 32;\n    let tileHeight = properties.tileHeight || properties.tileheight || 32;\n\n    let mapWidth = width * tileWidth;\n    let mapHeight = height * tileHeight;\n\n    let context = properties.context || kontra.context;\n    let canvasWidth = context.canvas.width;\n    let canvasHeight = context.canvas.height;\n\n    // create an off-screen canvas for pre-rendering the map\n    // @see http://jsperf.com/render-vs-prerender\n    let offscreenCanvas = document.createElement('canvas');\n    let offscreenContext = offscreenCanvas.getContext('2d');\n\n    // when clipping an image, sx and sy must within the image region, otherwise\n    // Firefox and Safari won't draw it.\n    // @see http://stackoverflow.com/questions/19338032/canvas-indexsizeerror-index-or-size-is-negative-or-greater-than-the-allowed-a\n    let sxMax = Math.max(0, mapWidth - canvasWidth);\n    let syMax = Math.max(0, mapHeight - canvasHeight);\n\n    let _sx, _sy;\n\n    // draw order of layers (by name)\n    let layerOrder = [];\n\n    let tileEngine = {\n      width: width,\n      height: height,\n\n      tileWidth: tileWidth,\n      tileHeight: tileHeight,\n\n      mapWidth: mapWidth,\n      mapHeight: mapHeight,\n\n      context: context,\n\n      x: properties.x || 0,\n      y: properties.y || 0,\n\n      tilesets: [],\n      layers: {},\n\n      /**\n       * Add an tileset for the tile engine to use.\n       * @memberof kontra.tileEngine\n       *\n       * @param {object|object[]} tileset - Properties of the image to add.\n       * @param {Image|Canvas} tileset.image - Path to the image or Image object.\n       * @param {number} tileset.firstGrid - The first tile grid to start the image.\n       */\n      addTilesets: function addTilesets(tilesets) {\n        [].concat(tilesets).map(function(tileset) {\n          let tilesetImage = tileset.image;\n          let image, firstGrid, numTiles, lastTileset, tiles;\n\n          // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#coercion-to-test-for-types\n          if (''+tilesetImage === tilesetImage) {\n            let i = Infinity;\n\n            while (i >= 0) {\n              i = tilesetImage.lastIndexOf('/', i);\n              let path = (i < 0 ? tilesetImage : tilesetImage.substr(i));\n\n              if (kontra.assets.images[path]) {\n                image = kontra.assets.images[path];\n                break;\n              }\n\n              i--;\n            }\n          }\n          else {\n            image = tilesetImage;\n          }\n\n          firstGrid = tileset.firstGrid;\n\n          // if the width or height of the provided image is smaller than the tile size,\n          // default calculation to 1\n          numTiles = ( (image.width / tileWidth | 0) || 1 ) *\n                     ( (image.height / tileHeight | 0) || 1 );\n\n          if (!firstGrid) {\n            // only calculate the first grid if the tile map has a tileset already\n            if (tileEngine.tilesets.length > 0) {\n              lastTileset = tileEngine.tilesets[tileEngine.tilesets.length - 1];\n              tiles = (lastTileset.image.width / tileWidth | 0) *\n                      (lastTileset.image.height / tileHeight | 0);\n\n              firstGrid = lastTileset.firstGrid + tiles;\n            }\n            // otherwise this is the first tile added to the tile map\n            else {\n              firstGrid = 1;\n            }\n          }\n\n          tileEngine.tilesets.push({\n            firstGrid: firstGrid,\n            lastGrid: firstGrid + numTiles - 1,\n            image: image\n          });\n\n          // sort the tile map so we can perform a binary search when drawing\n          tileEngine.tilesets.sort(function(a, b) {\n            return a.firstGrid - b.firstGrid;\n          });\n        });\n      },\n\n      /**\n       * Add a layer to the tile engine.\n       * @memberof kontra.tileEngine\n       *\n       * @param {object} properties - Properties of the layer to add.\n       * @param {string} properties.name - Name of the layer.\n       * @param {number[]} properties.data - Tile layer data.\n       * @param {boolean} [properties.render=true] - If the layer should be drawn.\n       * @param {number} [properties.zIndex] - Draw order for tile layer. Highest number is drawn last (i.e. on top of all other layers).\n       */\n      addLayers: function addLayers(layers) {\n        [].concat(layers).map(function(layer) {\n          layer.render = (layer.render === undefined ? true : layer.render);\n\n          let data, r, row, c, prop, value;\n\n          // flatten a 2D array into a single array\n          if (Array.isArray(layer.data[0])) {\n            data = [];\n\n            for (r = 0; row = layer.data[r]; r++) {\n              for (c = 0; c < width; c++) {\n                data.push(row[c] || 0);\n              }\n            }\n          }\n          else {\n            data = layer.data;\n          }\n\n          tileEngine.layers[layer.name] = {\n            data: data,\n            zIndex: layer.zIndex || 0,\n            render: layer.render\n          };\n\n          // merge properties of layer onto layer object\n          for (prop in layer.properties) {\n            value = layer.properties[prop];\n\n            try {\n              value = JSON.parse(value);\n            }\n            catch(e) {}\n\n            tileEngine.layers[layer.name][prop] = value;\n          }\n\n          // only add the layer to the layer order if it should be drawn\n          if (tileEngine.layers[layer.name].render) {\n            layerOrder.push(layer.name);\n\n            layerOrder.sort(function(a, b) {\n              return tileEngine.layers[a].zIndex - tileEngine.layers[b].zIndex;\n            });\n\n          }\n        });\n\n        preRenderImage();\n      },\n\n      /**\n       * Simple bounding box collision test for layer tiles.\n       * @memberof kontra.tileEngine\n       *\n       * @param {string} name - Name of the layer.\n       * @param {object} object - Object to check collision against.\n       * @param {number} object.x - X coordinate of the object.\n       * @param {number} object.y - Y coordinate of the object.\n       * @param {number} object.width - Width of the object.\n       * @param {number} object.height - Height of the object.\n       *\n       * @returns {boolean} True if the object collides with a tile, false otherwise.\n       */\n      layerCollidesWith: function layerCollidesWith(name, object) {\n        // calculate all tiles that the object can collide with\n        let row = tileEngine.getRow(object.y);\n        let col = tileEngine.getCol(object.x);\n\n        let endRow = tileEngine.getRow(object.y + object.height);\n        let endCol = tileEngine.getCol(object.x + object.width);\n\n        // check all tiles\n        let index;\n        for (let r = row; r <= endRow; r++) {\n          for (let c = col; c <= endCol; c++) {\n            index = getIndex({row: r, col: c});\n\n            if (tileEngine.layers[name].data[index]) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n      },\n\n      /**\n       * Get the tile from the specified layer at x, y or row, col.\n       * @memberof kontra.tileEngine\n       *\n       * @param {string} name - Name of the layer.\n       * @param {object} position - Position of the tile in either x, y or row, col.\n       * @param {number} position.x - X coordinate of the tile.\n       * @param {number} position.y - Y coordinate of the tile.\n       * @param {number} position.row - Row of the tile.\n       * @param {number} position.col - Col of the tile.\n       *\n       * @returns {number}\n       */\n      tileAtLayer: function tileAtLayer(name, position) {\n        let index = getIndex(position);\n\n        if (index >= 0) {\n          return tileEngine.layers[name].data[index];\n        }\n      },\n\n      /**\n       * Render the pre-rendered canvas.\n       * @memberof kontra.tileEngine\n       */\n      render: function render() {\n        /* istanbul ignore next */\n        tileEngine.context.drawImage(\n          offscreenCanvas,\n          tileEngine.sx, tileEngine.sy, canvasWidth, canvasHeight,\n          tileEngine.x, tileEngine.y, canvasWidth, canvasHeight\n        );\n      },\n\n      /**\n       * Render a specific layer.\n       * @memberof kontra.tileEngine\n       *\n       * @param {string} name - Name of the layer to render.\n       */\n      renderLayer: function renderLayer(name) {\n        let layer = tileEngine.layers[name];\n\n        // calculate the starting tile\n        let row = tileEngine.getRow();\n        let col = tileEngine.getCol();\n        let index = getIndex({row: row, col: col});\n\n        // calculate where to start drawing the tile relative to the drawing canvas\n        let startX = col * tileWidth - tileEngine.sx;\n        let startY = row * tileHeight - tileEngine.sy;\n\n        // calculate how many tiles the drawing canvas can hold\n        let viewWidth = Math.min(Math.ceil(canvasWidth / tileWidth) + 1, width);\n        let viewHeight = Math.min(Math.ceil(canvasHeight / tileHeight) + 1, height);\n        let numTiles = viewWidth * viewHeight;\n\n        let count = 0;\n        let x, y, tile, tileset, image, tileOffset, w, sx, sy;\n\n        // draw just enough of the layer to fit inside the drawing canvas\n        while (count < numTiles) {\n          tile = layer.data[index];\n\n          if (tile) {\n            tileset = getTileset(tile);\n            image = tileset.image;\n\n            x = startX + (count % viewWidth) * tileWidth;\n            y = startY + (count / viewWidth | 0) * tileHeight;\n\n            tileOffset = tile - tileset.firstGrid;\n            w = image.width / tileWidth;\n\n            sx = (tileOffset % w) * tileWidth;\n            sy = (tileOffset / w | 0) * tileHeight;\n\n            tileEngine.context.drawImage(\n              image,\n              sx, sy, tileWidth, tileHeight,\n              x, y, tileWidth, tileHeight\n            );\n          }\n\n          if (++count % viewWidth === 0) {\n            index = col + (++row * width);\n          }\n          else {\n            index++;\n          }\n        }\n      },\n\n      /**\n       * Get the row from the y coordinate.\n       * @memberof kontra.tileEngine\n       *\n       * @param {number} y - Y coordinate.\n       *\n       * @return {number}\n       */\n      getRow: function getRow(y) {\n        y = y || 0;\n\n        return (tileEngine.sy + y) / tileHeight | 0;\n      },\n\n      /**\n       * Get the col from the x coordinate.\n       * @memberof kontra.tileEngine\n       *\n       * @param {number} x - X coordinate.\n       *\n       * @return {number}\n       */\n      getCol: function getCol(x) {\n        x = x || 0;\n\n        return (tileEngine.sx + x) / tileWidth | 0;\n      },\n\n      get sx() {\n        return _sx;\n      },\n\n      get sy() {\n        return _sy;\n      },\n\n      // ensure sx and sy are within the image region\n      set sx(value) {\n        _sx = Math.min( Math.max(0, value), sxMax );\n      },\n\n      set sy(value) {\n        _sy = Math.min( Math.max(0, value), syMax );\n      },\n\n      // expose properties for testing\n      // @if DEBUG\n      _layerOrder: layerOrder\n      // @endif\n    };\n\n    // set here so we use setter function\n    tileEngine.sx = properties.sx || 0;\n    tileEngine.sy = properties.sy || 0;\n\n    // make the off-screen canvas the full size of the map\n    offscreenCanvas.width = mapWidth;\n    offscreenCanvas.height = mapHeight;\n\n    // merge properties of the tile engine onto the tile engine itself\n    for (let prop in properties.properties) {\n      let value = properties.properties[prop];\n\n      try {\n        value = JSON.parse(value);\n      }\n      catch(e) {}\n\n      // passed in properties override properties.properties\n      tileEngine[prop] = tileEngine[prop] || value;\n    }\n\n    if (properties.tilesets) {\n      tileEngine.addTilesets(properties.tilesets);\n    }\n\n    if (properties.layers) {\n      tileEngine.addLayers(properties.layers);\n    }\n\n    return tileEngine;\n  };\n})();"},function(e,n,t){var r=t(5);"string"==typeof r&&(r=[[e.i,r,""]]);var i={hmr:!0,transform:void 0,insertInto:void 0};t(7)(r,i);r.locals&&(e.exports=r.locals)},function(e,n,t){(e.exports=t(6)(!1)).push([e.i,"body {\n  background: black;\n}\ncanvas {\n  border: 1px solid white;\n}\n",""])},function(e,n){e.exports=function(e){var n=[];return n.toString=function(){return this.map(function(n){var t=function(e,n){var t=e[1]||"",r=e[3];if(!r)return t;if(n&&"function"==typeof btoa){var i=function(e){return"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(e))))+" */"}(r),o=r.sources.map(function(e){return"/*# sourceURL="+r.sourceRoot+e+" */"});return[t].concat(o).concat([i]).join("\n")}return[t].join("\n")}(n,e);return n[2]?"@media "+n[2]+"{"+t+"}":t}).join("")},n.i=function(e,t){"string"==typeof e&&(e=[[null,e,""]]);for(var r={},i=0;i<this.length;i++){var o=this[i][0];"number"==typeof o&&(r[o]=!0)}for(i=0;i<e.length;i++){var a=e[i];"number"==typeof a[0]&&r[a[0]]||(t&&!a[2]?a[2]=t:t&&(a[2]="("+a[2]+") and ("+t+")"),n.push(a))}},n}},function(e,n,t){var r={},i=function(e){var n;return function(){return void 0===n&&(n=e.apply(this,arguments)),n}}(function(){return window&&document&&document.all&&!window.atob}),o=function(e){var n={};return function(e,t){if("function"==typeof e)return e();if(void 0===n[e]){var r=function(e,n){return n?n.querySelector(e):document.querySelector(e)}.call(this,e,t);if(window.HTMLIFrameElement&&r instanceof window.HTMLIFrameElement)try{r=r.contentDocument.head}catch(e){r=null}n[e]=r}return n[e]}}(),a=null,s=0,l=[],p=t(8);function c(e,n){for(var t=0;t<e.length;t++){var i=e[t],o=r[i.id];if(o){o.refs++;for(var a=0;a<o.parts.length;a++)o.parts[a](i.parts[a]);for(;a<i.parts.length;a++)o.parts.push(b(i.parts[a],n))}else{var s=[];for(a=0;a<i.parts.length;a++)s.push(b(i.parts[a],n));r[i.id]={id:i.id,refs:1,parts:s}}}}function d(e,n){for(var t=[],r={},i=0;i<e.length;i++){var o=e[i],a=n.base?o[0]+n.base:o[0],s={css:o[1],media:o[2],sourceMap:o[3]};r[a]?r[a].parts.push(s):t.push(r[a]={id:a,parts:[s]})}return t}function h(e,n){var t=o(e.insertInto);if(!t)throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");var r=l[l.length-1];if("top"===e.insertAt)r?r.nextSibling?t.insertBefore(n,r.nextSibling):t.appendChild(n):t.insertBefore(n,t.firstChild),l.push(n);else if("bottom"===e.insertAt)t.appendChild(n);else{if("object"!=typeof e.insertAt||!e.insertAt.before)throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");var i=o(e.insertAt.before,t);t.insertBefore(n,i)}}function m(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e);var n=l.indexOf(e);n>=0&&l.splice(n,1)}function u(e){var n=document.createElement("style");if(void 0===e.attrs.type&&(e.attrs.type="text/css"),void 0===e.attrs.nonce){var r=function(){0;return t.nc}();r&&(e.attrs.nonce=r)}return f(n,e.attrs),h(e,n),n}function f(e,n){Object.keys(n).forEach(function(t){e.setAttribute(t,n[t])})}function b(e,n){var t,r,i,o;if(n.transform&&e.css){if(!(o=n.transform(e.css)))return function(){};e.css=o}if(n.singleton){var l=s++;t=a||(a=u(n)),r=y.bind(null,t,l,!1),i=y.bind(null,t,l,!0)}else e.sourceMap&&"function"==typeof URL&&"function"==typeof URL.createObjectURL&&"function"==typeof URL.revokeObjectURL&&"function"==typeof Blob&&"function"==typeof btoa?(t=function(e){var n=document.createElement("link");return void 0===e.attrs.type&&(e.attrs.type="text/css"),e.attrs.rel="stylesheet",f(n,e.attrs),h(e,n),n}(n),r=function(e,n,t){var r=t.css,i=t.sourceMap,o=void 0===n.convertToAbsoluteUrls&&i;(n.convertToAbsoluteUrls||o)&&(r=p(r));i&&(r+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(i))))+" */");var a=new Blob([r],{type:"text/css"}),s=e.href;e.href=URL.createObjectURL(a),s&&URL.revokeObjectURL(s)}.bind(null,t,n),i=function(){m(t),t.href&&URL.revokeObjectURL(t.href)}):(t=u(n),r=function(e,n){var t=n.css,r=n.media;r&&e.setAttribute("media",r);if(e.styleSheet)e.styleSheet.cssText=t;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(t))}}.bind(null,t),i=function(){m(t)});return r(e),function(n){if(n){if(n.css===e.css&&n.media===e.media&&n.sourceMap===e.sourceMap)return;r(e=n)}else i()}}e.exports=function(e,n){if("undefined"!=typeof DEBUG&&DEBUG&&"object"!=typeof document)throw new Error("The style-loader cannot be used in a non-browser environment");(n=n||{}).attrs="object"==typeof n.attrs?n.attrs:{},n.singleton||"boolean"==typeof n.singleton||(n.singleton=i()),n.insertInto||(n.insertInto="head"),n.insertAt||(n.insertAt="bottom");var t=d(e,n);return c(t,n),function(e){for(var i=[],o=0;o<t.length;o++){var a=t[o];(s=r[a.id]).refs--,i.push(s)}e&&c(d(e,n),n);for(o=0;o<i.length;o++){var s;if(0===(s=i[o]).refs){for(var l=0;l<s.parts.length;l++)s.parts[l]();delete r[s.id]}}}};var g=function(){var e=[];return function(n,t){return e[n]=t,e.filter(Boolean).join("\n")}}();function y(e,n,t,r){var i=t?"":r.css;if(e.styleSheet)e.styleSheet.cssText=g(n,i);else{var o=document.createTextNode(i),a=e.childNodes;a[n]&&e.removeChild(a[n]),a.length?e.insertBefore(o,a[n]):e.appendChild(o)}}},function(e,n){e.exports=function(e){var n="undefined"!=typeof window&&window.location;if(!n)throw new Error("fixUrls requires window.location");if(!e||"string"!=typeof e)return e;var t=n.protocol+"//"+n.host,r=t+n.pathname.replace(/\/[^\/]*$/,"/");return e.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi,function(e,n){var i,o=n.trim().replace(/^"(.*)"$/,function(e,n){return n}).replace(/^'(.*)'$/,function(e,n){return n});return/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(o)?e:(i=0===o.indexOf("//")?o:0===o.indexOf("/")?t+o:r+o.replace(/^\.\//,""),"url("+JSON.stringify(i)+")")})}}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9rb250cmEva29udHJhLmpzPzZkN2UiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9rb250cmEva29udHJhLmpzIiwid2VicGFjazovLy8uL3NyYy9zdHlsZXMuY3NzPzAyYWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0eWxlcy5jc3MiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzIl0sIm5hbWVzIjpbImluc3RhbGxlZE1vZHVsZXMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwibW9kdWxlSWQiLCJleHBvcnRzIiwibW9kdWxlIiwiaSIsImwiLCJtb2R1bGVzIiwiY2FsbCIsIm0iLCJjIiwiZCIsIm5hbWUiLCJnZXR0ZXIiLCJvIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiciIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwidmFsdWUiLCJ0IiwibW9kZSIsIl9fZXNNb2R1bGUiLCJucyIsImNyZWF0ZSIsImtleSIsImJpbmQiLCJuIiwib2JqZWN0IiwicHJvcGVydHkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsInAiLCJzIiwiZG9jdW1lbnQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJlbGVtZW50IiwiY3JlYXRlRWxlbWVudCIsImlubmVySFRNTCIsImNvbXBvbmVudCIsImtvbnRyYSIsImluaXQiLCJzcHJpdGVzIiwiZGVncmVlc1RvUmFkaWFucyIsImRlZ3JlZXMiLCJNYXRoIiwiUEkiLCJzaGlwIiwic3ByaXRlIiwidHlwZSIsIngiLCJ5Iiwid2lkdGgiLCJyb3RhdGlvbiIsImR0IiwidHRsIiwiSW5maW5pdHkiLCJyZW5kZXIiLCJ0aGlzIiwiY29udGV4dCIsInNhdmUiLCJ0cmFuc2xhdGUiLCJyb3RhdGUiLCJiZWdpblBhdGgiLCJtb3ZlVG8iLCJsaW5lVG8iLCJjbG9zZVBhdGgiLCJzdHJva2UiLCJyZXN0b3JlIiwidXBkYXRlIiwia2V5cyIsInByZXNzZWQiLCJjb3MiLCJzaW4iLCJkZHgiLCJkZHkiLCJhZHZhbmNlIiwic3FydCIsImR4IiwiZHkiLCJidWxsZXQiLCJoZWlnaHQiLCJjb2xvciIsInB1c2giLCJjcmVhdGVBc3Rlcm9pZCIsInJhZGl1cyIsImFzdGVyb2lkIiwicmFuZG9tIiwic3Ryb2tlU3R5bGUiLCJhcmMiLCJnYW1lTG9vcCIsIm1hcCIsImNhbnZhcyIsImlfMSIsImxlbmd0aCIsImoiLCJmaWx0ZXIiLCJpc0FsaXZlIiwiZm9yRWFjaCIsInN0YXJ0Iiwic3JjIiwibG9nIiwiZXJyb3IiLCJjb25zb2xlIiwiZXhlY1NjcmlwdCIsImF0dGFjaEV2ZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2YWwiLCJjb250ZW50Iiwib3B0aW9ucyIsImhtciIsInRyYW5zZm9ybSIsImluc2VydEludG8iLCJ1bmRlZmluZWQiLCJsb2NhbHMiLCJ1c2VTb3VyY2VNYXAiLCJsaXN0IiwidG9TdHJpbmciLCJpdGVtIiwiY3NzTWFwcGluZyIsImJ0b2EiLCJzb3VyY2VNYXBwaW5nIiwic291cmNlTWFwIiwidW5lc2NhcGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJKU09OIiwic3RyaW5naWZ5IiwidG9Db21tZW50Iiwic291cmNlVVJMcyIsInNvdXJjZXMiLCJzb3VyY2UiLCJzb3VyY2VSb290IiwiY29uY2F0Iiwiam9pbiIsImNzc1dpdGhNYXBwaW5nVG9TdHJpbmciLCJtZWRpYVF1ZXJ5IiwiYWxyZWFkeUltcG9ydGVkTW9kdWxlcyIsImlkIiwic3R5bGVzSW5Eb20iLCJpc09sZElFIiwiZm4iLCJtZW1vIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJtZW1vaXplIiwid2luZG93IiwiYWxsIiwiYXRvYiIsImdldEVsZW1lbnQiLCJ0YXJnZXQiLCJwYXJlbnQiLCJzdHlsZVRhcmdldCIsInF1ZXJ5U2VsZWN0b3IiLCJIVE1MSUZyYW1lRWxlbWVudCIsImNvbnRlbnREb2N1bWVudCIsImhlYWQiLCJlIiwic2luZ2xldG9uIiwic2luZ2xldG9uQ291bnRlciIsInN0eWxlc0luc2VydGVkQXRUb3AiLCJmaXhVcmxzIiwiYWRkU3R5bGVzVG9Eb20iLCJzdHlsZXMiLCJkb21TdHlsZSIsInJlZnMiLCJwYXJ0cyIsImFkZFN0eWxlIiwibGlzdFRvU3R5bGVzIiwibmV3U3R5bGVzIiwiYmFzZSIsInBhcnQiLCJjc3MiLCJtZWRpYSIsImluc2VydFN0eWxlRWxlbWVudCIsInN0eWxlIiwiRXJyb3IiLCJsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCIsImluc2VydEF0IiwibmV4dFNpYmxpbmciLCJpbnNlcnRCZWZvcmUiLCJmaXJzdENoaWxkIiwiYmVmb3JlIiwicmVtb3ZlU3R5bGVFbGVtZW50IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiaWR4IiwiaW5kZXhPZiIsInNwbGljZSIsImNyZWF0ZVN0eWxlRWxlbWVudCIsImF0dHJzIiwibm9uY2UiLCJuYyIsImdldE5vbmNlIiwiYWRkQXR0cnMiLCJlbCIsInNldEF0dHJpYnV0ZSIsIm9iaiIsInJlbW92ZSIsInJlc3VsdCIsInN0eWxlSW5kZXgiLCJhcHBseVRvU2luZ2xldG9uVGFnIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwicmV2b2tlT2JqZWN0VVJMIiwiQmxvYiIsImxpbmsiLCJyZWwiLCJjcmVhdGVMaW5rRWxlbWVudCIsImF1dG9GaXhVcmxzIiwiY29udmVydFRvQWJzb2x1dGVVcmxzIiwiYmxvYiIsIm9sZFNyYyIsImhyZWYiLCJzdHlsZVNoZWV0IiwiY3NzVGV4dCIsImNyZWF0ZVRleHROb2RlIiwibmV3T2JqIiwiREVCVUciLCJuZXdMaXN0IiwibWF5UmVtb3ZlIiwicmVwbGFjZVRleHQiLCJ0ZXh0U3RvcmUiLCJpbmRleCIsInJlcGxhY2VtZW50IiwiQm9vbGVhbiIsImNzc05vZGUiLCJjaGlsZE5vZGVzIiwibG9jYXRpb24iLCJiYXNlVXJsIiwicHJvdG9jb2wiLCJob3N0IiwiY3VycmVudERpciIsInBhdGhuYW1lIiwicmVwbGFjZSIsImZ1bGxNYXRjaCIsIm9yaWdVcmwiLCJuZXdVcmwiLCJ1bnF1b3RlZE9yaWdVcmwiLCJ0cmltIiwiJDEiLCJ0ZXN0Il0sIm1hcHBpbmdzIjoiYUFDQSxJQUFBQSxLQUdBLFNBQUFDLEVBQUFDLEdBR0EsR0FBQUYsRUFBQUUsR0FDQSxPQUFBRixFQUFBRSxHQUFBQyxRQUdBLElBQUFDLEVBQUFKLEVBQUFFLElBQ0FHLEVBQUFILEVBQ0FJLEdBQUEsRUFDQUgsWUFVQSxPQU5BSSxFQUFBTCxHQUFBTSxLQUFBSixFQUFBRCxRQUFBQyxJQUFBRCxRQUFBRixHQUdBRyxFQUFBRSxHQUFBLEVBR0FGLEVBQUFELFFBS0FGLEVBQUFRLEVBQUFGLEVBR0FOLEVBQUFTLEVBQUFWLEVBR0FDLEVBQUFVLEVBQUEsU0FBQVIsRUFBQVMsRUFBQUMsR0FDQVosRUFBQWEsRUFBQVgsRUFBQVMsSUFDQUcsT0FBQUMsZUFBQWIsRUFBQVMsR0FBMENLLFlBQUEsRUFBQUMsSUFBQUwsS0FLMUNaLEVBQUFrQixFQUFBLFNBQUFoQixHQUNBLG9CQUFBaUIsZUFBQUMsYUFDQU4sT0FBQUMsZUFBQWIsRUFBQWlCLE9BQUFDLGFBQXdEQyxNQUFBLFdBRXhEUCxPQUFBQyxlQUFBYixFQUFBLGNBQWlEbUIsT0FBQSxLQVFqRHJCLEVBQUFzQixFQUFBLFNBQUFELEVBQUFFLEdBRUEsR0FEQSxFQUFBQSxJQUFBRixFQUFBckIsRUFBQXFCLElBQ0EsRUFBQUUsRUFBQSxPQUFBRixFQUNBLEtBQUFFLEdBQUEsaUJBQUFGLFFBQUFHLFdBQUEs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QUlBLE9BQUE1RyxLQUFBQyxVQUFBOEcsR0FBQSIsImZpbGUiOiJtYWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDApO1xuIiwiaW1wb3J0IFwia29udHJhXCI7XG5pbXBvcnQgXCIuL3N0eWxlcy5jc3NcIjtcblxuZnVuY3Rpb24gY29tcG9uZW50KCkge1xuICBsZXQgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cbiAgLy8gTG9kYXNoLCBjdXJyZW50bHkgaW5jbHVkZWQgdmlhIGEgc2NyaXB0LCBpcyByZXF1aXJlZCBmb3IgdGhpcyBsaW5lIHRvIHdvcmtcbiAgZWxlbWVudC5pbm5lckhUTUwgPSBcIkhlbGxvIHdlYnBhY2tcIjtcblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb21wb25lbnQoKSk7XG5cbmtvbnRyYS5pbml0KCk7XG5sZXQgc3ByaXRlczogYW55W10gPSBbXTtcblxuLy8gaGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgZGVncmVlcyB0byByYWRpYW5zXG5mdW5jdGlvbiBkZWdyZWVzVG9SYWRpYW5zKGRlZ3JlZXM6IG51bWJlcikge1xuICByZXR1cm4gKGRlZ3JlZXMgKiBNYXRoLlBJKSAvIDE4MDtcbn1cblxubGV0IHNoaXAgPSBrb250cmEuc3ByaXRlKHtcbiAgLy8gbWFrZSBzdXJlIHRvIGdpdmUgdGhlIGFzdGVyb2lkcyBhIHR5cGU6ICdhc3Rlcm9pZHMnIVxuICB0eXBlOiBcInNoaXBcIixcblxuICB4OiAzMDAsXG4gIHk6IDMwMCxcbiAgd2lkdGg6IDYsIC8vIHdlJ2xsIHVzZSB0aGlzIGxhdGVyIGZvciBjb2xsaXNpb24gZGV0ZWN0aW9uXG4gIHJvdGF0aW9uOiAwLCAvLyAwIGRlZ3JlZXMgaXMgdG8gdGhlIHJpZ2h0XG4gIGR0OiAwLCAvLyB0cmFjayBob3cgbXVjaCB0aW1lIGhhcyBwYXNzZWRcbiAgLy8gbWFrZSBzdXJlIHRvIGdpdmUgdGhlIGFzdGVyb2lkcyB0aGlzIGFzIHdlbGwhXG4gIHR0bDogSW5maW5pdHksXG5cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGV4dC5zYXZlKCk7XG4gICAgLy8gdHJhbnNmb3JtIHRoZSBvcmlnaW4sIGFuZCByb3RhdGUgYXJvdW5kIHRoZSBvcmlnaW5cbiAgICAvLyB1c2luZyB0aGUgc2hpcHMgcm90YXRpb25cbiAgICB0aGlzLmNvbnRleHQudHJhbnNsYXRlKHRoaXMueCwgdGhpcy55KTtcbiAgICB0aGlzLmNvbnRleHQucm90YXRlKGRlZ3JlZXNUb1JhZGlhbnModGhpcy5yb3RhdGlvbikpO1xuICAgIC8vIGRyYXcgYSByaWdodCBmYWNpbmcgdHJpYW5nbGVcbiAgICB0aGlzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgdGhpcy5jb250ZXh0Lm1vdmVUbygtMywgLTUpO1xuICAgIHRoaXMuY29udGV4dC5saW5lVG8oMTIsIDApO1xuICAgIHRoaXMuY29udGV4dC5saW5lVG8oLTMsIDUpO1xuICAgIHRoaXMuY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLmNvbnRleHQuc3Ryb2tlKCk7XG4gICAgdGhpcy5jb250ZXh0LnJlc3RvcmUoKTtcbiAgfSxcbiAgdXBkYXRlKCkge1xuICAgIC8vIHJvdGF0ZSB0aGUgc2hpcCBsZWZ0IG9yIHJpZ2h0XG4gICAgaWYgKGtvbnRyYS5rZXlzLnByZXNzZWQoXCJsZWZ0XCIpKSB7XG4gICAgICB0aGlzLnJvdGF0aW9uICs9IC00O1xuICAgIH0gZWxzZSBpZiAoa29udHJhLmtleXMucHJlc3NlZChcInJpZ2h0XCIpKSB7XG4gICAgICB0aGlzLnJvdGF0aW9uICs9IDQ7XG4gICAgfVxuICAgIC8vIG1vdmUgdGhlIHNoaXAgZm9yd2FyZCBpbiB0aGUgZGlyZWN0aW9uIGl0J3MgZmFjaW5nXG4gICAgY29uc3QgY29zID0gTWF0aC5jb3MoZGVncmVlc1RvUmFkaWFucyh0aGlzLnJvdGF0aW9uKSk7XG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4oZGVncmVlc1RvUmFkaWFucyh0aGlzLnJvdGF0aW9uKSk7XG5cbiAgICBpZiAoa29udHJhLmtleXMucHJlc3NlZChcInVwXCIpKSB7XG4gICAgICB0aGlzLmRkeCA9IGNvcyAqIDAuMTtcbiAgICAgIHRoaXMuZGR5ID0gc2luICogMC4xO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRkeCA9IHRoaXMuZGR5ID0gMDtcbiAgICB9XG4gICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgLy8gc2V0IGEgbWF4IHNwZWVkXG4gICAgY29uc3QgbWFnbml0dWRlID0gTWF0aC5zcXJ0KHRoaXMuZHggKiB0aGlzLmR4ICsgdGhpcy5keSAqIHRoaXMuZHkpO1xuICAgIGlmIChtYWduaXR1ZGUgPiAxMCkge1xuICAgICAgdGhpcy5keCAqPSAwLjk1O1xuICAgICAgdGhpcy5keSAqPSAwLjk1O1xuICAgIH1cbiAgICAvLyBhbGxvdyB0aGUgcGxheWVyIHRvIGZpcmUgbm8gbW9yZSB0aGFuIDEgYnVsbGV0IGV2ZXJ5IDEvNCBzZWNvbmRcbiAgICB0aGlzLmR0ICs9IDEgLyA2MDtcbiAgICBpZiAoa29udHJhLmtleXMucHJlc3NlZChcInNwYWNlXCIpICYmIHRoaXMuZHQgPiAwLjI1KSB7XG4gICAgICB0aGlzLmR0ID0gMDtcbiAgICAgIGxldCBidWxsZXQgPSBrb250cmEuc3ByaXRlKHtcbiAgICAgICAgdHlwZTogXCJidWxsZXRcIixcbiAgICAgICAgLy8gc3RhcnQgdGhlIGJ1bGxldCBvbiB0aGUgc2hpcCBhdCB0aGUgZW5kIG9mIHRoZSB0cmlhbmdsZVxuICAgICAgICB4OiB0aGlzLnggKyBjb3MgKiAxMixcbiAgICAgICAgeTogdGhpcy55ICsgc2luICogMTIsXG4gICAgICAgIC8vIG1vdmUgdGhlIGJ1bGxldCBzbGlnaHRseSBmYXN0ZXIgdGhhbiB0aGUgc2hpcFxuICAgICAgICBkeDogdGhpcy5keCArIGNvcyAqIDUsXG4gICAgICAgIGR5OiB0aGlzLmR5ICsgc2luICogNSxcbiAgICAgICAgLy8gbGl2ZSBvbmx5IDUwIGZyYW1lc1xuICAgICAgICB0dGw6IDUwLFxuICAgICAgICAvLyBidWxsZXRzIGFyZSBzbWFsbFxuICAgICAgICB3aWR0aDogMixcbiAgICAgICAgaGVpZ2h0OiAyLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiXG4gICAgICB9KTtcbiAgICAgIHNwcml0ZXMucHVzaChidWxsZXQpO1xuICAgIH1cbiAgfVxufSk7XG5cbnNwcml0ZXMucHVzaChzaGlwKTtcblxuZnVuY3Rpb24gY3JlYXRlQXN0ZXJvaWQoeDogbnVtYmVyLCB5OiBudW1iZXIsIHJhZGl1czogbnVtYmVyKSB7XG4gIGxldCBhc3Rlcm9pZCA9IGtvbnRyYS5zcHJpdGUoe1xuICAgIHR5cGU6IFwiYXN0ZXJvaWRcIixcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgcmFkaXVzOiByYWRpdXMsXG4gICAgdHRsOiBJbmZpbml0eSxcbiAgICBkeDogTWF0aC5yYW5kb20oKSAqIDQgLSAyLFxuICAgIGR5OiBNYXRoLnJhbmRvbSgpICogNCAtIDIsXG4gICAgcmVuZGVyKCkge1xuICAgICAgdGhpcy5jb250ZXh0LnN0cm9rZVN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgICAgdGhpcy5jb250ZXh0LmJlZ2luUGF0aCgpOyAvLyBzdGFydCBkcmF3aW5nIGEgc2hhcGVcbiAgICAgIHRoaXMuY29udGV4dC5hcmModGhpcy54LCB0aGlzLnksIHRoaXMucmFkaXVzLCAwLCBNYXRoLlBJICogMik7XG4gICAgICB0aGlzLmNvbnRleHQuc3Ryb2tlKCk7IC8vIG91dGxpbmUgdGhlIGNpcmNsZVxuICAgIH1cbiAgfSk7XG5cbiAgc3ByaXRlcy5wdXNoKGFzdGVyb2lkKTtcbn1cbmZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gIGNyZWF0ZUFzdGVyb2lkKDEwMCwgMTAwLCAzMCk7XG59XG5cbmxldCBsb29wID0ga29udHJhLmdhbWVMb29wKHtcbiAgdXBkYXRlLFxuICByZW5kZXJcbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGUoKSB7XG4gIHNwcml0ZXMubWFwKHNwcml0ZSA9PiB7XG4gICAgc3ByaXRlLnVwZGF0ZSgpO1xuICAgIC8vIHNwcml0ZSBpcyBiZXlvbmQgdGhlIGxlZnQgZWRnZVxuICAgIGlmIChzcHJpdGUueCA8IDApIHtcbiAgICAgIHNwcml0ZS54ID0ga29udHJhLmNhbnZhcy53aWR0aDtcbiAgICB9XG4gICAgLy8gc3ByaXRlIGlzIGJleW9uZCB0aGUgcmlnaHQgZWRnZVxuICAgIGVsc2UgaWYgKHNwcml0ZS54ID4ga29udHJhLmNhbnZhcy53aWR0aCkge1xuICAgICAgc3ByaXRlLnggPSAwO1xuICAgIH1cbiAgICAvLyBzcHJpdGUgaXMgYmV5b25kIHRoZSB0b3AgZWRnZVxuICAgIGlmIChzcHJpdGUueSA8IDApIHtcbiAgICAgIHNwcml0ZS55ID0ga29udHJhLmNhbnZhcy5oZWlnaHQ7XG4gICAgfVxuICAgIC8vIHNwcml0ZSBpcyBiZXlvbmQgdGhlIGJvdHRvbSBlZGdlXG4gICAgZWxzZSBpZiAoc3ByaXRlLnkgPiBrb250cmEuY2FudmFzLmhlaWdodCkge1xuICAgICAgc3ByaXRlLnkgPSAwO1xuICAgIH1cbiAgfSk7XG4gIC8vIGNvbGxpc2lvbiBkZXRlY3Rpb25cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcHJpdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gb25seSBjaGVjayBmb3IgY29sbGlzaW9uIGFnYWluc3QgYXN0ZXJvaWRzXG4gICAgaWYgKHNwcml0ZXNbaV0udHlwZSA9PT0gXCJhc3Rlcm9pZFwiKSB7XG4gICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBzcHJpdGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIC8vIGRvbid0IGNoZWNrIGFzdGVyb2lkIHZzLiBhc3Rlcm9pZCBjb2xsaXNpb25zXG4gICAgICAgIGlmIChzcHJpdGVzW2pdLnR5cGUgIT09IFwiYXN0ZXJvaWRcIikge1xuICAgICAgICAgIGxldCBhc3Rlcm9pZCA9IHNwcml0ZXNbaV07XG4gICAgICAgICAgbGV0IHNwcml0ZSA9IHNwcml0ZXNbal07XG4gICAgICAgICAgLy8gY2lyY2xlIHZzLiBjaXJjbGUgY29sbGlzaW9uIGRldGVjdGlvblxuICAgICAgICAgIGxldCBkeCA9IGFzdGVyb2lkLnggLSBzcHJpdGUueDtcbiAgICAgICAgICBsZXQgZHkgPSBhc3Rlcm9pZC55IC0gc3ByaXRlLnk7XG4gICAgICAgICAgaWYgKE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSkgPCBhc3Rlcm9pZC5yYWRpdXMgKyBzcHJpdGUud2lkdGgpIHtcbiAgICAgICAgICAgIGFzdGVyb2lkLnR0bCA9IDA7XG4gICAgICAgICAgICBzcHJpdGUudHRsID0gMDtcblxuICAgICAgICAgICAgLy8gc3BsaXQgdGhlIGFzdGVyb2lkIG9ubHkgaWYgaXQncyBsYXJnZSBlbm91Z2hcbiAgICAgICAgICAgIGlmIChhc3Rlcm9pZC5yYWRpdXMgPiAxMCkge1xuICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IDM7IHgrKykge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUFzdGVyb2lkKGFzdGVyb2lkLngsIGFzdGVyb2lkLnksIGFzdGVyb2lkLnJhZGl1cyAvIDIuNSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNwcml0ZXMgPSBzcHJpdGVzLmZpbHRlcihzcHJpdGUgPT4gc3ByaXRlLmlzQWxpdmUoKSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgc3ByaXRlcy5mb3JFYWNoKHMgPT4gcy5yZW5kZXIoKSk7XG59XG5cbmxvb3Auc3RhcnQoKTtcbiIsInJlcXVpcmUoXCIhIS9Vc2Vycy9qYWltZWdvbnphbGV6Z2FyY2lhL0dpdEh1Yi9qczEzay1zcGFjZXNob290ZXIvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9Vc2Vycy9qYWltZWdvbnphbGV6Z2FyY2lhL0dpdEh1Yi9qczEzay1zcGFjZXNob290ZXIvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL1VzZXJzL2phaW1lZ29uemFsZXpnYXJjaWEvR2l0SHViL2pzMTNrLXNwYWNlc2hvb3Rlci9ub2RlX21vZHVsZXMva29udHJhL2tvbnRyYS5qc1wiKSkiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzcmMpIHtcblx0ZnVuY3Rpb24gbG9nKGVycm9yKSB7XG5cdFx0KHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKVxuXHRcdCYmIChjb25zb2xlLmVycm9yIHx8IGNvbnNvbGUubG9nKShcIltTY3JpcHQgTG9hZGVyXVwiLCBlcnJvcik7XG5cdH1cblxuXHQvLyBDaGVjayBmb3IgSUUgPTwgOFxuXHRmdW5jdGlvbiBpc0lFKCkge1xuXHRcdHJldHVybiB0eXBlb2YgYXR0YWNoRXZlbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgPT09IFwidW5kZWZpbmVkXCI7XG5cdH1cblxuXHR0cnkge1xuXHRcdGlmICh0eXBlb2YgZXhlY1NjcmlwdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpc0lFKCkpIHtcblx0XHRcdGV4ZWNTY3JpcHQoc3JjKTtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBldmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRldmFsLmNhbGwobnVsbCwgc3JjKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bG9nKFwiRXZhbEVycm9yOiBObyBldmFsIGZ1bmN0aW9uIGF2YWlsYWJsZVwiKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0bG9nKGVycm9yKTtcblx0fVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBcInRoaXMua29udHJhID0ge1xcblxcbiAgLyoqXFxuICAgKiBJbml0aWFsaXplIHRoZSBjYW52YXMuXFxuICAgKiBAbWVtYmVyb2Yga29udHJhXFxuICAgKlxcbiAgICogQHBhcmFtIHtzdHJpbmd8SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIE1haW4gY2FudmFzIElEIG9yIEVsZW1lbnQgZm9yIHRoZSBnYW1lLlxcbiAgICovXFxuICBpbml0KGNhbnZhcykge1xcblxcbiAgICAvLyBjaGVjayBpZiBjYW52YXMgaXMgYSBzdHJpbmcgZmlyc3QsIGFuIGVsZW1lbnQgbmV4dCwgb3IgZGVmYXVsdCB0byBnZXR0aW5nXFxuICAgIC8vIGZpcnN0IGNhbnZhcyBvbiBwYWdlXFxuICAgIHZhciBjYW52YXNFbCA9IHRoaXMuY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2FudmFzKSB8fFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcyB8fFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcycpO1xcblxcbiAgICAvLyBAaWYgREVCVUdcXG4gICAgaWYgKCFjYW52YXNFbCkge1xcbiAgICAgIHRocm93IEVycm9yKCdZb3UgbXVzdCBwcm92aWRlIGEgY2FudmFzIGVsZW1lbnQgZm9yIHRoZSBnYW1lJyk7XFxuICAgIH1cXG4gICAgLy8gQGVuZGlmXFxuXFxuICAgIHRoaXMuY29udGV4dCA9IGNhbnZhc0VsLmdldENvbnRleHQoJzJkJyk7XFxuICB9LFxcblxcbiAgLyoqXFxuICAgKiBOb29wIGZ1bmN0aW9uLlxcbiAgICogQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMTYzNDg4Ni93aGF0LWlzLXRoZS1qYXZhc2NyaXB0LWNvbnZlbnRpb24tZm9yLW5vLW9wZXJhdGlvbiNjb21tZW50NjE3OTY0NjRfMzM0NTg0MzBcXG4gICAqIEBtZW1iZXJvZiBrb250cmFcXG4gICAqIEBwcml2YXRlXFxuICAgKlxcbiAgICogVGhlIG5ldyBvcGVyYXRvciBpcyByZXF1aXJlZCB3aGVuIHVzaW5nIHNpbm9uLnN0dWIgdG8gcmVwbGFjZSB3aXRoIHRoZSBub29wLlxcbiAgICovXFxuICBfbm9vcDogbmV3IEZ1bmN0aW9uLFxcblxcbiAgLyoqXFxuICAgKiBEaXNwYXRjaCBldmVudCB0byBhbnkgcGFydCBvZiB0aGUgY29kZSB0aGF0IG5lZWRzIHRvIGtub3cgd2hlblxcbiAgICogYSBuZXcgZnJhbWUgaGFzIHN0YXJ0ZWQuIFdpbGwgYmUgZmlsbGVkIG91dCBpbiBwb2ludGVyIGV2ZW50cy5cXG4gICAqIEBtZW1iZXJPZiBrb250cmFcXG4gICAqIEBwcml2YXRlXFxuICAgKi9cXG4gIF90aWNrOiBuZXcgRnVuY3Rpb25cXG59O1xcbihmdW5jdGlvbigpIHtcXG4gIGxldCBpbWFnZVJlZ2V4ID0gLyhqcGVnfGpwZ3xnaWZ8cG5nKSQvO1xcbiAgbGV0IGF1ZGlvUmVnZXggPSAvKHdhdnxtcDN8b2dnfGFhYykkLztcXG4gIGxldCBub1JlZ2V4ID0gL15ubyQvO1xcbiAgbGV0IGxlYWRpbmdTbGFzaCA9IC9eXFxcXC8vO1xcbiAgbGV0IHRyYWlsaW5nU2xhc2ggPSAvXFxcXC8kLztcXG4gIGxldCBhc3NldHM7XFxuXFxuICAvLyBhdWRpbyBwbGF5YWJpbGl0eVxcbiAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvYXVkaW8uanNcXG4gIGxldCBhdWRpbyA9IG5ldyBBdWRpbygpO1xcbiAgbGV0IGNhblVzZSA9IHtcXG4gICAgd2F2OiAnJyxcXG4gICAgbXAzOiBhdWRpby5jYW5QbGF5VHlwZSgnYXVkaW8vbXBlZzsnKS5yZXBsYWNlKG5vUmVnZXgsJycpLFxcbiAgICBvZ2c6IGF1ZGlvLmNhblBsYXlUeXBlKCdhdWRpby9vZ2c7IGNvZGVjcz1cXFwidm9yYmlzXFxcIicpLnJlcGxhY2Uobm9SZWdleCwnJyksXFxuICAgIGFhYzogYXVkaW8uY2FuUGxheVR5cGUoJ2F1ZGlvL2FhYzsnKS5yZXBsYWNlKG5vUmVnZXgsJycpXFxuICB9O1xcblxcbiAgLyoqXFxuICAgKiBKb2luIGEgYmFzZSBwYXRoIGFuZCBhc3NldCBwYXRoLlxcbiAgICpcXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlIC0gVGhlIGFzc2V0IGJhc2UgcGF0aC5cXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgVVJMIHRvIHRoZSBhc3NldC5cXG4gICAqXFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxcbiAgICovXFxuICBmdW5jdGlvbiBqb2luUGF0aChiYXNlLCB1cmwpIHtcXG4gICAgcmV0dXJuIFtiYXNlLnJlcGxhY2UodHJhaWxpbmdTbGFzaCwgJycpLCBiYXNlID8gdXJsLnJlcGxhY2UobGVhZGluZ1NsYXNoLCAnJykgOiB1cmxdXFxuICAgICAgLmZpbHRlcihzID0+IHMpXFxuICAgICAgLmpvaW4oJy8nKVxcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBHZXQgdGhlIGV4dGVuc2lvbiBvZiBhbiBhc3NldC5cXG4gICAqXFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIFVSTCB0byB0aGUgYXNzZXQuXFxuICAgKlxcbiAgICogQHJldHVybnMge3N0cmluZ31cXG4gICAqL1xcbiAgZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uKHVybCkge1xcbiAgICByZXR1cm4gdXJsLnNwbGl0KCcuJykucG9wKCk7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIEdldCB0aGUgbmFtZSBvZiBhbiBhc3NldC5cXG4gICAqXFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIFVSTCB0byB0aGUgYXNzZXQuXFxuICAgKlxcbiAgICogQHJldHVybnMge3N0cmluZ31cXG4gICAqL1xcbiAgZnVuY3Rpb24gZ2V0TmFtZSh1cmwpIHtcXG4gICAgbGV0IG5hbWUgPSB1cmwucmVwbGFjZSgnLicgKyBnZXRFeHRlbnNpb24odXJsKSwgJycpO1xcblxcbiAgICAvLyByZW1vdmUgbGVhZGluZyBzbGFzaCBpZiB0aGVyZSBpcyBubyBmb2xkZXIgaW4gdGhlIHBhdGhcXG4gICAgLy8gQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTA1OTI2MjkvMjEyNDI1NFxcbiAgICByZXR1cm4gbmFtZS5zcGxpdCgnLycpLmxlbmd0aCA9PSAyID8gbmFtZS5yZXBsYWNlKGxlYWRpbmdTbGFzaCwgJycpIDogbmFtZTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogTG9hZCBhbiBJbWFnZSBmaWxlLiBVc2VzIGltYWdlUGF0aCB0byByZXNvbHZlIFVSTC5cXG4gICAqIEBtZW1iZXJPZiBrb250cmEuYXNzZXRzXFxuICAgKiBAcHJpdmF0ZVxcbiAgICpcXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgVVJMIHRvIHRoZSBJbWFnZSBmaWxlLlxcbiAgICpcXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIGRlZmVycmVkIHByb21pc2UuIFByb21pc2UgcmVzb2x2ZXMgd2l0aCB0aGUgSW1hZ2UuXFxuICAgKlxcbiAgICogQGV4YW1wbGVcXG4gICAqIGtvbnRyYS5sb2FkSW1hZ2UoJ2Nhci5wbmcnKTtcXG4gICAqIGtvbnRyYS5sb2FkSW1hZ2UoJ2F1dG9ib3RzL3RydWNrLnBuZycpO1xcbiAgICovXFxuICBmdW5jdGlvbiBsb2FkSW1hZ2Uob3JpZ2luYWxVcmwsIHVybCkge1xcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XFxuICAgICAgbGV0IGltYWdlID0gbmV3IEltYWdlKCk7XFxuICAgICAgdXJsID0gam9pblBhdGgoYXNzZXRzLmltYWdlUGF0aCwgb3JpZ2luYWxVcmwpO1xcblxcbiAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uIGxvYWRJbWFnZU9uTG9hZCgpIHtcXG4gICAgICAgIGFzc2V0cy5pbWFnZXNbIGdldE5hbWUob3JpZ2luYWxVcmwpIF0gPSBhc3NldHMuaW1hZ2VzW3VybF0gPSB0aGlzO1xcbiAgICAgICAgcmVzb2x2ZSh0aGlzKTtcXG4gICAgICB9O1xcblxcbiAgICAgIGltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbiBsb2FkSW1hZ2VPbkVycm9yKCkge1xcbiAgICAgICAgcmVqZWN0KC8qIEBpZiBERUJVRyAqLyAnVW5hYmxlIHRvIGxvYWQgaW1hZ2UgJyArIC8qIEBlbmRpZiAqLyB1cmwpO1xcbiAgICAgIH07XFxuXFxuICAgICAgaW1hZ2Uuc3JjID0gdXJsO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogTG9hZCBhbiBBdWRpbyBmaWxlLiBTdXBwb3J0cyBsb2FkaW5nIG11bHRpcGxlIGF1ZGlvIGZvcm1hdHMgd2hpY2ggd2lsbCBiZSByZXNvbHZlZCBieVxcbiAgICogdGhlIGJyb3dzZXIgaW4gdGhlIG9yZGVyIGxpc3RlZC4gVXNlcyBhdWRpb1BhdGggdG8gcmVzb2x2ZSBVUkwuXFxuICAgKiBAbWVtYmVyT2Yga29udHJhLmFzc2V0c1xcbiAgICogQHByaXZhdGVcXG4gICAqXFxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gdXJsIC0gVGhlIFVSTCB0byB0aGUgQXVkaW8gZmlsZS5cXG4gICAqXFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBkZWZlcnJlZCBwcm9taXNlLiBQcm9taXNlIHJlc29sdmVzIHdpdGggdGhlIEF1ZGlvLlxcbiAgICpcXG4gICAqIEBleGFtcGxlXFxuICAgKiBrb250cmEubG9hZEF1ZGlvKCdzb3VuZF9lZmZlY3RzL2xhc2VyLm1wMycpO1xcbiAgICoga29udHJhLmxvYWRBdWRpbyhbJ2V4cGxvc2lvbi5tcDMnLCAnZXhwbG9zaW9uLm00YScsICdleHBsb3Npb24ub2dnJ10pO1xcbiAgICovXFxuICBmdW5jdGlvbiBsb2FkQXVkaW8ob3JpZ2luYWxVcmwsIHVybCwgdW5kZWZpbmVkKSB7XFxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcXG5cXG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggYXVkaW8gZm9ybWF0IHRoZSBicm93c2VyIGNhbiBwbGF5XFxuICAgICAgb3JpZ2luYWxVcmwgPSBbXS5jb25jYXQob3JpZ2luYWxVcmwpLnJlZHVjZShmdW5jdGlvbihhLCBzb3VyY2UpIHtcXG4gICAgICAgIHJldHVybiBjYW5Vc2VbIGdldEV4dGVuc2lvbihzb3VyY2UpIF0gPyBzb3VyY2UgOiBhXFxuICAgICAgfSwgdW5kZWZpbmVkKTtcXG5cXG4gICAgICBpZiAoIW9yaWdpbmFsVXJsKSB7XFxuICAgICAgICByZWplY3QoLyogQGlmIERFQlVHICovICdjYW5ub3QgcGxheSBhbnkgb2YgdGhlIGF1ZGlvIGZvcm1hdHMgcHJvdmlkZWQnICsgLyogQGVuZGlmICovIG9yaWdpbmFsVXJsKTtcXG4gICAgICB9XFxuICAgICAgZWxzZSB7XFxuICAgICAgICBsZXQgYXVkaW8gPSBuZXcgQXVkaW8oKTtcXG4gICAgICAgIHVybCA9IGpvaW5QYXRoKGFzc2V0cy5hdWRpb1BhdGgsIG9yaWdpbmFsVXJsKTtcXG5cXG4gICAgICAgIGF1ZGlvLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXknLCBmdW5jdGlvbiBsb2FkQXVkaW9PbkxvYWQoKSB7XFxuICAgICAgICAgIGFzc2V0cy5hdWRpb1sgZ2V0TmFtZShvcmlnaW5hbFVybCkgXSA9IGFzc2V0cy5hdWRpb1t1cmxdID0gdGhpcztcXG4gICAgICAgICAgcmVzb2x2ZSh0aGlzKTtcXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgYXVkaW8ub25lcnJvciA9IGZ1bmN0aW9uIGxvYWRBdWRpb09uRXJyb3IoKSB7XFxuICAgICAgICAgIHJlamVjdCgvKiBAaWYgREVCVUcgKi8gJ1VuYWJsZSB0byBsb2FkIGF1ZGlvICcgKyAvKiBAZW5kaWYgKi8gdXJsKTtcXG4gICAgICAgIH07XFxuXFxuICAgICAgICBhdWRpby5zcmMgPSB1cmw7XFxuICAgICAgICBhdWRpby5sb2FkKCk7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogTG9hZCBhIGRhdGEgZmlsZSAoYmUgaXQgdGV4dCBvciBKU09OKS4gVXNlcyBkYXRhUGF0aCB0byByZXNvbHZlIFVSTC5cXG4gICAqIEBtZW1iZXJPZiBrb250cmEuYXNzZXRzXFxuICAgKiBAcHJpdmF0ZVxcbiAgICpcXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgVVJMIHRvIHRoZSBkYXRhIGZpbGUuXFxuICAgKlxcbiAgICogQHJldHVybnMge1Byb21pc2V9IEEgZGVmZXJyZWQgcHJvbWlzZS4gUmVzb2x2ZXMgd2l0aCB0aGUgZGF0YSBvciBwYXJzZWQgSlNPTi5cXG4gICAqXFxuICAgKiBAZXhhbXBsZVxcbiAgICoga29udHJhLmxvYWREYXRhKCdiaW8uanNvbicpO1xcbiAgICoga29udHJhLmxvYWREYXRhKCdkaWFsb2cudHh0Jyk7XFxuICAgKi9cXG4gIGZ1bmN0aW9uIGxvYWREYXRhKG9yaWdpbmFsVXJsLCB1cmwpIHtcXG4gICAgdXJsID0gam9pblBhdGgoYXNzZXRzLmRhdGFQYXRoLCBvcmlnaW5hbFVybCk7XFxuXFxuICAgIHJldHVybiBmZXRjaCh1cmwpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyByZXNwb25zZTtcXG4gICAgICByZXR1cm4gcmVzcG9uc2UuY2xvbmUoKS5qc29uKCkuY2F0Y2goZnVuY3Rpb24oKSB7IHJldHVybiByZXNwb25zZS50ZXh0KCkgfSlcXG4gICAgfSkudGhlbihmdW5jdGlvbihkYXRhKSB7XFxuICAgICAgYXNzZXRzLmRhdGFbIGdldE5hbWUob3JpZ2luYWxVcmwpIF0gPSBhc3NldHMuZGF0YVt1cmxdID0gZGF0YTtcXG4gICAgICByZXR1cm4gZGF0YTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIE9iamVjdCBmb3IgbG9hZGluZyBhc3NldHMuXFxuICAgKi9cXG4gIGFzc2V0cyA9IGtvbnRyYS5hc3NldHMgPSB7XFxuICAgIC8vIGFsbCBhc3NldHMgYXJlIHN0b3JlZCBieSBuYW1lIGFzIHdlbGwgYXMgYnkgVVJMXFxuICAgIGltYWdlczoge30sXFxuICAgIGF1ZGlvOiB7fSxcXG4gICAgZGF0YToge30sXFxuXFxuICAgIC8vIGJhc2UgYXNzZXQgcGF0aCBmb3IgZGV0ZXJtaW5pbmcgYXNzZXQgVVJMc1xcbiAgICBpbWFnZVBhdGg6ICcnLFxcbiAgICBhdWRpb1BhdGg6ICcnLFxcbiAgICBkYXRhUGF0aDogJycsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBMb2FkIGFuIEltYWdlLCBBdWRpbywgb3IgZGF0YSBmaWxlLlxcbiAgICAgKiBAbWVtYmVyT2Yga29udHJhLmFzc2V0c1xcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gLSBDb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBhc3NldHMgdG8gbG9hZC5cXG4gICAgICpcXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XFxuICAgICAqXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqIGtvbnRyYS5sb2FkQXNzZXQoJ2Nhci5wbmcnKTtcXG4gICAgICoga29udHJhLmxvYWRBc3NldChbJ2V4cGxvc2lvbi5tcDMnLCAnZXhwbG9zaW9uLm9nZyddKTtcXG4gICAgICoga29udHJhLmxvYWRBc3NldCgnYmlvLmpzb24nKTtcXG4gICAgICoga29udHJhLmxvYWRBc3NldCgnY2FyLnBuZycsIFsnZXhwbG9zaW9uLm1wMycsICdleHBsb3Npb24ub2dnJ10sICdiaW8uanNvbicpO1xcbiAgICAgKi9cXG4gICAgbG9hZCgpIHtcXG4gICAgICBsZXQgcHJvbWlzZXMgPSBbXTtcXG4gICAgICBsZXQgdXJsLCBleHRlbnNpb24sIGFzc2V0LCBpLCBwcm9taXNlO1xcblxcbiAgICAgIGZvciAoaSA9IDA7IChhc3NldCA9IGFyZ3VtZW50c1tpXSk7IGkrKykge1xcbiAgICAgICAgdXJsID0gW10uY29uY2F0KGFzc2V0KVswXTtcXG5cXG4gICAgICAgIGV4dGVuc2lvbiA9IGdldEV4dGVuc2lvbih1cmwpO1xcbiAgICAgICAgaWYgKGV4dGVuc2lvbi5tYXRjaChpbWFnZVJlZ2V4KSkge1xcbiAgICAgICAgICBwcm9taXNlID0gbG9hZEltYWdlKGFzc2V0KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKGV4dGVuc2lvbi5tYXRjaChhdWRpb1JlZ2V4KSkge1xcbiAgICAgICAgICBwcm9taXNlID0gbG9hZEF1ZGlvKGFzc2V0KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICBwcm9taXNlID0gbG9hZERhdGEoYXNzZXQpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcXG4gICAgfSxcXG5cXG4gICAgLy8gZXhwb3NlIHByb3BlcnRpZXMgZm9yIHRlc3RpbmdcXG4gICAgLyogQGlmIERFQlVHICovXFxuICAgIF9jYW5Vc2U6IGNhblVzZVxcbiAgICAvKiBAZW5kaWYgKi9cXG4gIH07XFxufSkoKTtcXG4oZnVuY3Rpb24oKSB7XFxuXFxuICAvKipcXG4gICAqIEdhbWUgbG9vcCB0aGF0IHVwZGF0ZXMgYW5kIHJlbmRlcnMgdGhlIGdhbWUgZXZlcnkgZnJhbWUuXFxuICAgKiBAbWVtYmVyb2Yga29udHJhXFxuICAgKlxcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgcHJvcGVydGllcyAtIFByb3BlcnRpZXMgb2YgdGhlIGdhbWUgbG9vcC5cXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgIFtwcm9wZXJ0aWVzLmZwcz02MF0gLSBEZXNpcmVkIGZyYW1lIHJhdGUuXFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICBbcHJvcGVydGllcy5jbGVhckNhbnZhcz10cnVlXSAtIENsZWFyIHRoZSBjYW52YXMgZXZlcnkgZnJhbWUuXFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBwcm9wZXJ0aWVzLnVwZGF0ZSAtIEZ1bmN0aW9uIGNhbGxlZCB0byB1cGRhdGUgdGhlIGdhbWUuXFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBwcm9wZXJ0aWVzLnJlbmRlciAtIEZ1bmN0aW9uIGNhbGxlZCB0byByZW5kZXIgdGhlIGdhbWUuXFxuICAgKi9cXG4gIGtvbnRyYS5nYW1lTG9vcCA9IGZ1bmN0aW9uKHByb3BlcnRpZXMpIHtcXG4gICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwge307XFxuXFxuICAgIC8vIGNoZWNrIGZvciByZXF1aXJlZCBmdW5jdGlvbnNcXG4gICAgLy8gQGlmIERFQlVHXFxuICAgIGlmICggIShwcm9wZXJ0aWVzLnVwZGF0ZSAmJiBwcm9wZXJ0aWVzLnJlbmRlcikgKSB7XFxuICAgICAgdGhyb3cgRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgdXBkYXRlKCkgYW5kIHJlbmRlcigpIGZ1bmN0aW9ucycpO1xcbiAgICB9XFxuICAgIC8vIEBlbmRpZlxcblxcbiAgICAvLyBhbmltYXRpb24gdmFyaWFibGVzXFxuICAgIGxldCBmcHMgPSBwcm9wZXJ0aWVzLmZwcyB8fCA2MDtcXG4gICAgbGV0IGFjY3VtdWxhdG9yID0gMDtcXG4gICAgbGV0IGRlbHRhID0gMUUzIC8gZnBzOyAgLy8gZGVsdGEgYmV0d2VlbiBwZXJmb3JtYW5jZS5ub3cgdGltaW5ncyAoaW4gbXMpXFxuICAgIGxldCBzdGVwID0gMSAvIGZwcztcXG5cXG4gICAgbGV0IGNsZWFyID0gKHByb3BlcnRpZXMuY2xlYXJDYW52YXMgPT09IGZhbHNlID9cXG4gICAgICAgICAgICAgICAga29udHJhLl9ub29wIDpcXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY2xlYXIoKSB7XFxuICAgICAgICAgICAgICAgICAga29udHJhLmNvbnRleHQuY2xlYXJSZWN0KDAsMCxrb250cmEuY2FudmFzLndpZHRoLGtvbnRyYS5jYW52YXMuaGVpZ2h0KTtcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgIGxldCBsYXN0LCByQUYsIG5vdywgZHQ7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDYWxsZWQgZXZlcnkgZnJhbWUgb2YgdGhlIGdhbWUgbG9vcC5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGZyYW1lKCkge1xcbiAgICAgIHJBRiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmcmFtZSk7XFxuXFxuICAgICAgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XFxuICAgICAgZHQgPSBub3cgLSBsYXN0O1xcbiAgICAgIGxhc3QgPSBub3c7XFxuXFxuICAgICAgLy8gcHJldmVudCB1cGRhdGluZyB0aGUgZ2FtZSB3aXRoIGEgdmVyeSBsYXJnZSBkdCBpZiB0aGUgZ2FtZSB3ZXJlIHRvIGxvc2UgZm9jdXNcXG4gICAgICAvLyBhbmQgdGhlbiByZWdhaW4gZm9jdXMgbGF0ZXJcXG4gICAgICBpZiAoZHQgPiAxRTMpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAga29udHJhLl90aWNrKCk7XFxuICAgICAgYWNjdW11bGF0b3IgKz0gZHQ7XFxuXFxuICAgICAgd2hpbGUgKGFjY3VtdWxhdG9yID49IGRlbHRhKSB7XFxuICAgICAgICBnYW1lTG9vcC51cGRhdGUoc3RlcCk7XFxuXFxuICAgICAgICBhY2N1bXVsYXRvciAtPSBkZWx0YTtcXG4gICAgICB9XFxuXFxuICAgICAgY2xlYXIoKTtcXG4gICAgICBnYW1lTG9vcC5yZW5kZXIoKTtcXG4gICAgfVxcblxcbiAgICAvLyBnYW1lIGxvb3Agb2JqZWN0XFxuICAgIGxldCBnYW1lTG9vcCA9IHtcXG4gICAgICB1cGRhdGU6IHByb3BlcnRpZXMudXBkYXRlLFxcbiAgICAgIHJlbmRlcjogcHJvcGVydGllcy5yZW5kZXIsXFxuICAgICAgaXNTdG9wcGVkOiB0cnVlLFxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIFN0YXJ0IHRoZSBnYW1lIGxvb3AuXFxuICAgICAgICogQG1lbWJlcm9mIGtvbnRyYS5nYW1lTG9vcFxcbiAgICAgICAqL1xcbiAgICAgIHN0YXJ0KCkge1xcbiAgICAgICAgbGFzdCA9IHBlcmZvcm1hbmNlLm5vdygpO1xcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmcmFtZSk7XFxuICAgICAgfSxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBTdG9wIHRoZSBnYW1lIGxvb3AuXFxuICAgICAgICovXFxuICAgICAgc3RvcCgpIHtcXG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJBRik7XFxuICAgICAgfSxcXG5cXG4gICAgICAvLyBleHBvc2UgcHJvcGVydGllcyBmb3IgdGVzdGluZ1xcbiAgICAgIC8vIEBpZiBERUJVR1xcbiAgICAgIF9mcmFtZTogZnJhbWUsXFxuICAgICAgc2V0IF9sYXN0KHZhbHVlKSB7XFxuICAgICAgICBsYXN0ID0gdmFsdWU7XFxuICAgICAgfVxcbiAgICAgIC8vIEBlbmRpZlxcbiAgICB9O1xcblxcbiAgICByZXR1cm4gZ2FtZUxvb3A7XFxuICB9O1xcbn0pKCk7XFxuKGZ1bmN0aW9uKCkge1xcbiAgbGV0IGNhbGxiYWNrcyA9IHt9O1xcbiAgbGV0IHByZXNzZWRLZXlzID0ge307XFxuXFxuICBsZXQga2V5TWFwID0ge1xcbiAgICAvLyBuYW1lZCBrZXlzXFxuICAgIDEzOiAnZW50ZXInLFxcbiAgICAyNzogJ2VzYycsXFxuICAgIDMyOiAnc3BhY2UnLFxcbiAgICAzNzogJ2xlZnQnLFxcbiAgICAzODogJ3VwJyxcXG4gICAgMzk6ICdyaWdodCcsXFxuICAgIDQwOiAnZG93bidcXG4gIH07XFxuXFxuICAvLyBhbHBoYSBrZXlzXFxuICAvLyBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80MzA5NTc3Mi8yMTI0MjU0XFxuICBmb3IgKGxldCBpID0gMDsgaSA8IDI2OyBpKyspIHtcXG4gICAga2V5TWFwWzY1K2ldID0gKDEwICsgaSkudG9TdHJpbmcoMzYpO1xcbiAgfVxcbiAgLy8gbnVtZXJpYyBrZXlzXFxuICBmb3IgKGkgPSAwOyBpIDwgMTA7IGkrKykge1xcbiAgICBrZXlNYXBbNDgraV0gPSAnJytpO1xcbiAgfVxcblxcbiAgYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGtleWRvd25FdmVudEhhbmRsZXIpO1xcbiAgYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBrZXl1cEV2ZW50SGFuZGxlcik7XFxuICBhZGRFdmVudExpc3RlbmVyKCdibHVyJywgYmx1ckV2ZW50SGFuZGxlcik7XFxuXFxuICAvKipcXG4gICAqIEV4ZWN1dGUgYSBmdW5jdGlvbiB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga2V5Ym9hcmQga2V5LlxcbiAgICogQHByaXZhdGVcXG4gICAqXFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXFxuICAgKi9cXG4gIGZ1bmN0aW9uIGtleWRvd25FdmVudEhhbmRsZXIoZSkge1xcbiAgICBsZXQga2V5ID0ga2V5TWFwW2Uud2hpY2hdO1xcbiAgICBwcmVzc2VkS2V5c1trZXldID0gdHJ1ZTtcXG5cXG4gICAgaWYgKGNhbGxiYWNrc1trZXldKSB7XFxuICAgICAgY2FsbGJhY2tzW2tleV0oZSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogU2V0IHRoZSByZWxlYXNlZCBrZXkgdG8gbm90IGJlaW5nIHByZXNzZWQuXFxuICAgKiBAcHJpdmF0ZVxcbiAgICpcXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcXG4gICAqL1xcbiAgZnVuY3Rpb24ga2V5dXBFdmVudEhhbmRsZXIoZSkge1xcbiAgICBwcmVzc2VkS2V5c1sga2V5TWFwW2Uud2hpY2hdIF0gPSBmYWxzZTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogUmVzZXQgcHJlc3NlZCBrZXlzLlxcbiAgICogQHByaXZhdGVcXG4gICAqXFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXFxuICAgKi9cXG4gIGZ1bmN0aW9uIGJsdXJFdmVudEhhbmRsZXIoZSkge1xcbiAgICBwcmVzc2VkS2V5cyA9IHt9O1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBPYmplY3QgZm9yIHVzaW5nIHRoZSBrZXlib2FyZC5cXG4gICAqL1xcbiAga29udHJhLmtleXMgPSB7XFxuICAgIC8qKlxcbiAgICAgKiBSZWdpc3RlciBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBhIGtleSBwcmVzcy5cXG4gICAgICogQG1lbWJlcm9mIGtvbnRyYS5rZXlzXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBrZXlzIC0ga2V5IG9yIGtleXMgdG8gYmluZC5cXG4gICAgICovXFxuICAgIGJpbmQoa2V5cywgY2FsbGJhY2spIHtcXG4gICAgICAvLyBzbWFsbGVyIHRoYW4gZG9pbmcgYEFycmF5LmlzQXJyYXkoa2V5cykgPyBrZXlzIDogW2tleXNdYFxcbiAgICAgIFtdLmNvbmNhdChrZXlzKS5tYXAoZnVuY3Rpb24oa2V5KSB7XFxuICAgICAgICBjYWxsYmFja3Nba2V5XSA9IGNhbGxiYWNrO1xcbiAgICAgIH0pXFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBSZW1vdmUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBhIGtleS5cXG4gICAgICogQG1lbWJlcm9mIGtvbnRyYS5rZXlzXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBrZXlzIC0ga2V5IG9yIGtleXMgdG8gdW5iaW5kLlxcbiAgICAgKi9cXG4gICAgdW5iaW5kKGtleXMsIHVuZGVmaW5lZCkge1xcbiAgICAgIFtdLmNvbmNhdChrZXlzKS5tYXAoZnVuY3Rpb24oa2V5KSB7XFxuICAgICAgICBjYWxsYmFja3Nba2V5XSA9IHVuZGVmaW5lZDtcXG4gICAgICB9KVxcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogUmV0dXJucyB3aGV0aGVyIGEga2V5IGlzIHByZXNzZWQuXFxuICAgICAqIEBtZW1iZXJvZiBrb250cmEua2V5c1xcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gS2V5IHRvIGNoZWNrIGZvciBwcmVzcy5cXG4gICAgICpcXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XFxuICAgICAqL1xcbiAgICBwcmVzc2VkKGtleSkge1xcbiAgICAgIHJldHVybiAhIXByZXNzZWRLZXlzW2tleV07XFxuICAgIH1cXG4gIH07XFxufSkoKTtcXG4oZnVuY3Rpb24oKSB7XFxuICBsZXQgcG9pbnRlcjtcXG5cXG4gIC8vIHNhdmUgZWFjaCBvYmplY3QgYXMgdGhleSBhcmUgcmVuZGVyZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIG9iamVjdFxcbiAgLy8gaXMgb24gdG9wIHdoZW4gbXVsdGlwbGUgb2JqZWN0cyBhcmUgdGhlIHRhcmdldCBvZiBhbiBldmVudC5cXG4gIC8vIHdlJ2xsIGFsd2F5cyB1c2UgdGhlIGxhc3QgZnJhbWUncyBvYmplY3Qgb3JkZXIgc28gd2Uga25vd1xcbiAgLy8gdGhlIGZpbmFsaXplZCBvcmRlciBvZiBhbGwgb2JqZWN0cywgb3RoZXJ3aXNlIGFuIG9iamVjdCBjb3VsZCBhc2tcXG4gIC8vIGlmIGl0J3MgYmVpbmcgaG92ZXJlZCB3aGVuIGl0J3MgcmVuZGVyZWQgZmlyc3QgZXZlbiBpZiBvdGhlciBvYmplY3RzXFxuICAvLyB3b3VsZCBibG9jayBpdCBsYXRlciBpbiB0aGUgcmVuZGVyIG9yZGVyXFxuICBsZXQgdGhpc0ZyYW1lUmVuZGVyT3JkZXIgPSBbXTtcXG4gIGxldCBsYXN0RnJhbWVSZW5kZXJPcmRlciA9IFtdO1xcblxcbiAgbGV0IGNhbGxiYWNrcyA9IHt9O1xcbiAgbGV0IHRyYWNrZWRPYmplY3RzID0gW107XFxuICBsZXQgcHJlc3NlZEJ1dHRvbnMgPSB7fTtcXG5cXG4gIGxldCBidXR0b25NYXAgPSB7XFxuICAgIDA6ICdsZWZ0JyxcXG4gICAgMTogJ21pZGRsZScsXFxuICAgIDI6ICdyaWdodCdcXG4gIH07XFxuXFxuICBhZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBwb2ludGVyRG93bkhhbmRsZXIpO1xcbiAgYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHBvaW50ZXJEb3duSGFuZGxlcik7XFxuICBhZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgcG9pbnRlclVwSGFuZGxlcik7XFxuICBhZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHBvaW50ZXJVcEhhbmRsZXIpO1xcbiAgYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGJsdXJFdmVudEhhbmRsZXIpO1xcbiAgYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2VNb3ZlSGFuZGxlcik7XFxuXFxuICAvKipcXG4gICAqIERldGVjdGlvbiBjb2xsaXNpb24gYmV0d2VlbiBhIHJlY3RhbmdsZSBhbmQgYSBjaXJjbGUuXFxuICAgKiBAc2VlIGh0dHBzOi8veWFsLmNjL3JlY3RhbmdsZS1jaXJjbGUtaW50ZXJzZWN0aW9uLXRlc3QvXFxuICAgKiBAcHJpdmF0ZVxcbiAgICpcXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgLSBPYmplY3QgdG8gY2hlY2sgY29sbGlzaW9uIGFnYWluc3QuXFxuICAgKi9cXG4gIGZ1bmN0aW9uIGNpcmNsZVJlY3RDb2xsaXNpb24ob2JqZWN0KSB7XFxuICAgIGxldCBkeCA9IHBvaW50ZXIueCAtIE1hdGgubWF4KG9iamVjdC54LCBNYXRoLm1pbihwb2ludGVyLngsIG9iamVjdC54ICsgb2JqZWN0LndpZHRoKSk7XFxuICAgIGxldCBkeSA9IHBvaW50ZXIueSAtIE1hdGgubWF4KG9iamVjdC55LCBNYXRoLm1pbihwb2ludGVyLnksIG9iamVjdC55ICsgb2JqZWN0LmhlaWdodCkpO1xcbiAgICByZXR1cm4gKGR4ICogZHggKyBkeSAqIGR5KSA8IChwb2ludGVyLnJhZGl1cyAqIHBvaW50ZXIucmFkaXVzKTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogR2V0IHRoZSBmaXJzdCBvbiB0b3Agb2JqZWN0IHRoYXQgdGhlIHBvaW50ZXIgY29sbGlkZXMgd2l0aC5cXG4gICAqIEBwcml2YXRlXFxuICAgKlxcbiAgICogQHJldHVybnMge29iamVjdH0gRmlyc3Qgb2JqZWN0IHRvIGNvbGxpZGUgd2l0aCB0aGUgcG9pbnRlci5cXG4gICAqL1xcbiAgZnVuY3Rpb24gZ2V0Q3VycmVudE9iamVjdCgpIHtcXG5cXG4gICAgLy8gaWYgcG9pbnRlciBldmVudHMgYXJlIHJlcXVpcmVkIG9uIHRoZSB2ZXJ5IGZpcnN0IGZyYW1lIG9yIHdpdGhvdXQgYSBnYW1lIGxvb3AsXFxuICAgIC8vIHVzZSB0aGUgY3VycmVudCBmcmFtZSBvcmRlciBhcnJheVxcbiAgICBsZXQgZnJhbWVPcmRlciA9IChsYXN0RnJhbWVSZW5kZXJPcmRlci5sZW5ndGggPyBsYXN0RnJhbWVSZW5kZXJPcmRlciA6IHRoaXNGcmFtZVJlbmRlck9yZGVyKTtcXG4gICAgbGV0IGxlbmd0aCA9IGZyYW1lT3JkZXIubGVuZ3RoIC0gMTtcXG4gICAgbGV0IG9iamVjdCwgY29sbGlkZXM7XFxuXFxuICAgIGZvciAobGV0IGkgPSBsZW5ndGg7IGkgPj0gMDsgaS0tKSB7XFxuICAgICAgb2JqZWN0ID0gZnJhbWVPcmRlcltpXTtcXG5cXG4gICAgICBpZiAob2JqZWN0LmNvbGxpZGVzV2l0aFBvaW50ZXIpIHtcXG4gICAgICAgIGNvbGxpZGVzID0gb2JqZWN0LmNvbGxpZGVzV2l0aFBvaW50ZXIocG9pbnRlcik7XFxuICAgICAgfVxcbiAgICAgIGVsc2Uge1xcbiAgICAgICAgY29sbGlkZXMgPSBjaXJjbGVSZWN0Q29sbGlzaW9uKG9iamVjdCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChjb2xsaWRlcykge1xcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogRXhlY3V0ZSB0aGUgb25Eb3duIGNhbGxiYWNrIGZvciBhbiBvYmplY3QuXFxuICAgKiBAcHJpdmF0ZVxcbiAgICpcXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcXG4gICAqL1xcbiAgZnVuY3Rpb24gcG9pbnRlckRvd25IYW5kbGVyKGUpIHtcXG4gICAgcHJlc3NlZEJ1dHRvbnNbIGJ1dHRvbk1hcFtlLmJ1dHRvbl0gXSA9IHRydWU7XFxuICAgIHBvaW50ZXJIYW5kbGVyKGUsICdvbkRvd24nKTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogRXhlY3V0ZSB0aGUgb25VcCBjYWxsYmFjayBmb3IgYW4gb2JqZWN0LlxcbiAgICogQHByaXZhdGVcXG4gICAqXFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXFxuICAgKi9cXG4gIGZ1bmN0aW9uIHBvaW50ZXJVcEhhbmRsZXIoZSkge1xcbiAgICBwcmVzc2VkQnV0dG9uc1sgYnV0dG9uTWFwW2UuYnV0dG9uXSBdID0gZmFsc2U7XFxuICAgIHBvaW50ZXJIYW5kbGVyKGUsICdvblVwJyk7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIFRyYWNrIHRoZSBwb3NpdGlvbiBvZiB0aGUgbW91c2UuXFxuICAgKiBAcHJpdmF0ZVxcbiAgICpcXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcXG4gICAqL1xcbiAgZnVuY3Rpb24gbW91c2VNb3ZlSGFuZGxlcihlKSB7XFxuICAgIHBvaW50ZXJIYW5kbGVyKGUsICdvbk92ZXInKTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogUmVzZXQgcHJlc3NlZCBidXR0b25zLlxcbiAgICogQHByaXZhdGVcXG4gICAqXFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXFxuICAgKi9cXG4gIGZ1bmN0aW9uIGJsdXJFdmVudEhhbmRsZXIoZSkge1xcbiAgICBwcmVzc2VkQnV0dG9ucyA9IHt9O1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBGaW5kIHRoZSBmaXJzdCBvYmplY3QgZm9yIHRoZSBldmVudCBhbmQgZXhlY3V0ZSBpdCdzIGNhbGxiYWNrIGZ1bmN0aW9uXFxuICAgKiBAcHJpdmF0ZVxcbiAgICpcXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCAtIFdoaWNoIGV2ZW50IHdhcyBjYWxsZWQuXFxuICAgKi9cXG4gIGZ1bmN0aW9uIHBvaW50ZXJIYW5kbGVyKGUsIGV2ZW50KSB7XFxuICAgIGlmICgha29udHJhLmNhbnZhcykgcmV0dXJuO1xcblxcbiAgICBsZXQgY2xpZW50WCwgY2xpZW50WTtcXG5cXG4gICAgaWYgKGUudHlwZS5pbmRleE9mKCdtb3VzZScpICE9PSAtMSkge1xcbiAgICAgIGNsaWVudFggPSBlLmNsaWVudFg7XFxuICAgICAgY2xpZW50WSA9IGUuY2xpZW50WTtcXG4gICAgfVxcbiAgICBlbHNlIHtcXG4gICAgICAvLyB0b3VjaHN0YXJ0IHVzZXMgdG91Y2hlcyB3aGlsZSB0b3VjaGVuZCB1c2VzIGNoYW5nZWRUb3VjaGVzXFxuICAgICAgLy8gQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNzk1NzU5My9ob3ctdG8tY2FwdHVyZS10b3VjaGVuZC1jb29yZGluYXRlc1xcbiAgICAgIGNsaWVudFggPSAoZS50b3VjaGVzWzBdIHx8IGUuY2hhbmdlZFRvdWNoZXNbMF0pLmNsaWVudFg7XFxuICAgICAgY2xpZW50WSA9IChlLnRvdWNoZXNbMF0gfHwgZS5jaGFuZ2VkVG91Y2hlc1swXSkuY2xpZW50WTtcXG4gICAgfVxcblxcbiAgICBwb2ludGVyLnggPSBjbGllbnRYIC0ga29udHJhLmNhbnZhcy5vZmZzZXRMZWZ0O1xcbiAgICBwb2ludGVyLnkgPSBjbGllbnRZIC0ga29udHJhLmNhbnZhcy5vZmZzZXRUb3A7XFxuXFxuICAgIGxldCBvYmplY3Q7XFxuICAgIGlmIChlLnRhcmdldCA9PT0ga29udHJhLmNhbnZhcykge1xcbiAgICAgIG9iamVjdCA9IGdldEN1cnJlbnRPYmplY3QoKTtcXG4gICAgICBpZiAob2JqZWN0ICYmIG9iamVjdFtldmVudF0pIHtcXG4gICAgICAgIG9iamVjdFtldmVudF0oKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKGNhbGxiYWNrc1tldmVudF0pIHtcXG4gICAgICBjYWxsYmFja3NbZXZlbnRdKGUsIG9iamVjdCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogT2JqZWN0IGZvciB1c2luZyB0aGUgcG9pbnRlci5cXG4gICAqL1xcbiAgcG9pbnRlciA9IGtvbnRyYS5wb2ludGVyID0ge1xcbiAgICB4OiAwLFxcbiAgICB5OiAwLFxcbiAgICByYWRpdXM6IDUsICAvLyBhcmJpdHJhcnkgc2l6ZVxcblxcbiAgICAvKipcXG4gICAgICogUmVnaXN0ZXIgb2JqZWN0IHRvIGJlIHRyYWNrZWQgYnkgcG9pbnRlciBldmVudHMuXFxuICAgICAqIEBtZW1iZXJvZiBrb250cmEucG9pbnRlclxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0ge29iamVjdHxvYmplY3RbXX0gb2JqZWN0cyAtIE9iamVjdCBvciBvYmplY3RzIHRvIHRyYWNrLlxcbiAgICAgKi9cXG4gICAgdHJhY2sob2JqZWN0cykge1xcbiAgICAgIFtdLmNvbmNhdChvYmplY3RzKS5tYXAoZnVuY3Rpb24ob2JqZWN0KSB7XFxuXFxuICAgICAgICAvLyBvdmVycmlkZSB0aGUgb2JqZWN0cyByZW5kZXIgZnVuY3Rpb24gdG8ga2VlcCB0cmFjayBvZiByZW5kZXIgb3JkZXJcXG4gICAgICAgIGlmICghb2JqZWN0Ll9yKSB7XFxuICAgICAgICAgIG9iamVjdC5fciA9IG9iamVjdC5yZW5kZXI7XFxuXFxuICAgICAgICAgIG9iamVjdC5yZW5kZXIgPSBmdW5jdGlvbigpIHtcXG4gICAgICAgICAgICB0aGlzRnJhbWVSZW5kZXJPcmRlci5wdXNoKHRoaXMpO1xcbiAgICAgICAgICAgIHRoaXMuX3IoKTtcXG4gICAgICAgICAgfTtcXG5cXG4gICAgICAgICAgdHJhY2tlZE9iamVjdHMucHVzaChvYmplY3QpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogUmVtb3ZlIG9iamVjdCBmcm9tIGJlaW5nIHRyYWNrZWQgYnkgcG9pbnRlciBldmVudHMuXFxuICAgICAqIEBtZW1iZXJvZiBrb250cmEucG9pbnRlclxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0ge29iamVjdHxvYmplY3RbXX0gb2JqZWN0cyAtIE9iamVjdCBvciBvYmplY3RzIHRvIHN0b3AgdHJhY2tpbmcuXFxuICAgICAqL1xcbiAgICB1bnRyYWNrKG9iamVjdHMsIHVuZGVmaW5lZCkge1xcbiAgICAgIFtdLmNvbmNhdChvYmplY3RzKS5tYXAoZnVuY3Rpb24ob2JqZWN0KSB7XFxuXFxuICAgICAgICAvLyByZXN0b3JlIG9yaWdpbmFsIHJlbmRlciBmdW5jdGlvbiB0byBubyBsb25nZXIgdHJhY2sgcmVuZGVyIG9yZGVyXFxuICAgICAgICBvYmplY3QucmVuZGVyID0gb2JqZWN0Ll9yO1xcbiAgICAgICAgb2JqZWN0Ll9yID0gdW5kZWZpbmVkO1xcblxcbiAgICAgICAgbGV0IGluZGV4ID0gdHJhY2tlZE9iamVjdHMuaW5kZXhPZihvYmplY3QpO1xcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xcbiAgICAgICAgICB0cmFja2VkT2JqZWN0cy5zcGxpY2UoaW5kZXgsIDEpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pXFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgYSB0cmFja2VkIG9iamVjdCBpcyB1bmRlciB0aGUgcG9pbnRlci5cXG4gICAgICogQG1lbWJlcm9mIGtvbnRyYS5wb2ludGVyXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgLSBPYmplY3QgdG8gY2hlY2tcXG4gICAgICpcXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XFxuICAgICAqL1xcbiAgICBvdmVyKG9iamVjdCkge1xcbiAgICAgIGlmICh0cmFja2VkT2JqZWN0cy5pbmRleE9mKG9iamVjdCkgPT09IC0xKSByZXR1cm4gZmFsc2U7XFxuXFxuICAgICAgcmV0dXJuIGdldEN1cnJlbnRPYmplY3QoKSA9PT0gb2JqZWN0O1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogUmVnaXN0ZXIgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gcG9pbnRlciBkb3duLlxcbiAgICAgKiBAbWVtYmVyb2Yga29udHJhLnBvaW50ZXJcXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBleGVjdXRlXFxuICAgICAqL1xcbiAgICBvbkRvd24oY2FsbGJhY2spIHtcXG4gICAgICBjYWxsYmFja3Mub25Eb3duID0gY2FsbGJhY2s7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBSZWdpc3RlciBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBwb2ludGVyIHVwLlxcbiAgICAgKiBAbWVtYmVyb2Yga29udHJhLnBvaW50ZXJcXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBleGVjdXRlXFxuICAgICAqL1xcbiAgICBvblVwKGNhbGxiYWNrKSB7XFxuICAgICAgY2FsbGJhY2tzLm9uVXAgPSBjYWxsYmFjaztcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgYnV0dG9uIGlzIHByZXNzZWQuXFxuICAgICAqIEBtZW1iZXJvZiBrb250cmEucG9pbnRlclxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYnV0dG9uIC0gQnV0dG9uIHRvIGNoZWNrIGZvciBwcmVzcy5cXG4gICAgICpcXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XFxuICAgICAqL1xcbiAgICBwcmVzc2VkKGJ1dHRvbikge1xcbiAgICAgIHJldHVybiAhIXByZXNzZWRCdXR0b25zW2J1dHRvbl1cXG4gICAgfVxcbiAgfTtcXG5cXG4gIC8vIHJlc2V0IG9iamVjdCByZW5kZXIgb3JkZXIgb24gZXZlcnkgbmV3IGZyYW1lXFxuICBrb250cmEuX3RpY2sgPSBmdW5jdGlvbigpIHtcXG4gICAgbGFzdEZyYW1lUmVuZGVyT3JkZXIubGVuZ3RoID0gMDtcXG5cXG4gICAgdGhpc0ZyYW1lUmVuZGVyT3JkZXIubWFwKGZ1bmN0aW9uKG9iamVjdCkge1xcbiAgICAgIGxhc3RGcmFtZVJlbmRlck9yZGVyLnB1c2gob2JqZWN0KTtcXG4gICAgfSk7XFxuXFxuICAgIHRoaXNGcmFtZVJlbmRlck9yZGVyLmxlbmd0aCA9IDA7XFxuICB9O1xcbn0pKCk7XFxuKGZ1bmN0aW9uKCkge1xcblxcbiAgLyoqXFxuICAgKiBPYmplY3QgcG9vbC4gVGhlIHBvb2wgd2lsbCBncm93IGluIHNpemUgdG8gYWNjb21tb2RhdGUgYXMgbWFueSBvYmplY3RzIGFzIGFyZSBuZWVkZWQuXFxuICAgKiBVbnVzZWQgaXRlbXMgYXJlIGF0IHRoZSBmcm9udCBvZiB0aGUgcG9vbCBhbmQgaW4gdXNlIGl0ZW1zIGFyZSBhdCB0aGUgb2YgdGhlIHBvb2wuXFxuICAgKiBAbWVtYmVyb2Yga29udHJhXFxuICAgKlxcbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXMgLSBQcm9wZXJ0aWVzIG9mIHRoZSBwb29sLlxcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gcHJvcGVydGllcy5jcmVhdGUgLSBGdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG9iamVjdCB0byB1c2UgaW4gdGhlIHBvb2wuXFxuICAgKiBAcGFyYW0ge251bWJlcn0gcHJvcGVydGllcy5tYXhTaXplIC0gVGhlIG1heGltdW0gc2l6ZSB0aGF0IHRoZSBwb29sIHdpbGwgZ3JvdyB0by5cXG4gICAqL1xcbiAga29udHJhLnBvb2wgPSBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XFxuICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IHt9O1xcblxcbiAgICBsZXQgaW5Vc2UgPSAwO1xcblxcbiAgICAvLyBjaGVjayBmb3IgdGhlIGNvcnJlY3Qgc3RydWN0dXJlIG9mIHRoZSBvYmplY3RzIGFkZGVkIHRvIHBvb2xzIHNvIHdlIGtub3cgdGhhdCB0aGVcXG4gICAgLy8gcmVzdCBvZiB0aGUgcG9vbCBjb2RlIHdpbGwgd29yayB3aXRob3V0IGVycm9yc1xcbiAgICAvLyBAaWYgREVCVUdcXG4gICAgbGV0IG9iajtcXG4gICAgaWYgKCFwcm9wZXJ0aWVzLmNyZWF0ZSB8fFxcbiAgICAgICAgKCAhKCBvYmogPSBwcm9wZXJ0aWVzLmNyZWF0ZSgpICkgfHxcXG4gICAgICAgICAgISggb2JqLnVwZGF0ZSAmJiBvYmouaW5pdCAmJlxcbiAgICAgICAgICAgICBvYmouaXNBbGl2ZSApXFxuICAgICAgICkpIHtcXG4gICAgICB0aHJvdyBFcnJvcignTXVzdCBwcm92aWRlIGNyZWF0ZSgpIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IHdpdGggaW5pdCgpLCB1cGRhdGUoKSwgYW5kIGlzQWxpdmUoKSBmdW5jdGlvbnMnKTtcXG4gICAgfVxcbiAgICAvLyBAZW5kaWZcXG5cXG4gICAgcmV0dXJuIHtcXG4gICAgICBfYzogcHJvcGVydGllcy5jcmVhdGUsXFxuXFxuICAgICAgLy8gc3RhcnQgdGhlIHBvb2wgd2l0aCBhbiBvYmplY3RcXG4gICAgICBvYmplY3RzOiBbcHJvcGVydGllcy5jcmVhdGUoKV0sXFxuICAgICAgc2l6ZTogMSxcXG4gICAgICBtYXhTaXplOiBwcm9wZXJ0aWVzLm1heFNpemUgfHwgSW5maW5pdHksXFxuXFxuICAgICAgLyoqXFxuICAgICAgICogR2V0IGFuIG9iamVjdCBmcm9tIHRoZSBwb29sLlxcbiAgICAgICAqIEBtZW1iZXJvZiBrb250cmEucG9vbFxcbiAgICAgICAqXFxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXMgLSBQcm9wZXJ0aWVzIHRvIHBhc3MgdG8gb2JqZWN0LmluaXQoKS5cXG4gICAgICAgKi9cXG4gICAgICBnZXQocHJvcGVydGllcykge1xcbiAgICAgICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwge307XFxuXFxuICAgICAgICAvLyB0aGUgcG9vbCBpcyBvdXQgb2Ygb2JqZWN0cyBpZiB0aGUgZmlyc3Qgb2JqZWN0IGlzIGluIHVzZSBhbmQgaXQgY2FuJ3QgZ3Jvd1xcbiAgICAgICAgaWYgKHRoaXMub2JqZWN0c1swXS5pc0FsaXZlKCkpIHtcXG4gICAgICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gdGhpcy5tYXhTaXplKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIC8vIGRvdWJsZSB0aGUgc2l6ZSBvZiB0aGUgYXJyYXkgYnkgZmlsbGluZyBpdCB3aXRoIHR3aWNlIGFzIG1hbnkgb2JqZWN0c1xcbiAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuc2l6ZSAmJiB0aGlzLm9iamVjdHMubGVuZ3RoIDwgdGhpcy5tYXhTaXplOyB4KyspIHtcXG4gICAgICAgICAgICAgIHRoaXMub2JqZWN0cy51bnNoaWZ0KHRoaXMuX2MoKSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHRoaXMuc2l6ZSA9IHRoaXMub2JqZWN0cy5sZW5ndGg7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIHNhdmUgb2ZmIGZpcnN0IG9iamVjdCBpbiBwb29sIHRvIHJlYXNzaWduIHRvIGxhc3Qgb2JqZWN0IGFmdGVyIHVuc2hpZnRcXG4gICAgICAgIGxldCBvYmogPSB0aGlzLm9iamVjdHMuc2hpZnQoKTtcXG4gICAgICAgIG9iai5pbml0KHByb3BlcnRpZXMpO1xcbiAgICAgICAgdGhpcy5vYmplY3RzLnB1c2gob2JqKTtcXG4gICAgICAgIGluVXNlKys7XFxuICAgICAgfSxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBSZXR1cm4gYWxsIG9iamVjdHMgdGhhdCBhcmUgYWxpdmUgZnJvbSB0aGUgcG9vbC5cXG4gICAgICAgKiBAbWVtYmVyb2Yga29udHJhLnBvb2xcXG4gICAgICAgKlxcbiAgICAgICAqIEByZXR1cm5zIHtvYmplY3RbXX1cXG4gICAgICAgKi9cXG4gICAgICBnZXRBbGl2ZU9iamVjdHMoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5vYmplY3RzLnNsaWNlKHRoaXMub2JqZWN0cy5sZW5ndGggLSBpblVzZSk7XFxuICAgICAgfSxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBDbGVhciB0aGUgb2JqZWN0IHBvb2wuXFxuICAgICAgICogQG1lbWJlcm9mIGtvbnRyYS5wb29sXFxuICAgICAgICovXFxuICAgICAgY2xlYXIoKSB7XFxuICAgICAgICBpblVzZSA9IHRoaXMub2JqZWN0cy5sZW5ndGggPSAwO1xcbiAgICAgICAgdGhpcy5zaXplID0gMTtcXG4gICAgICAgIHRoaXMub2JqZWN0cy5wdXNoKHRoaXMuX2MoKSk7XFxuICAgICAgfSxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBVcGRhdGUgYWxsIGFsaXZlIHBvb2wgb2JqZWN0cy5cXG4gICAgICAgKiBAbWVtYmVyb2Yga29udHJhLnBvb2xcXG4gICAgICAgKlxcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkdCAtIFRpbWUgc2luY2UgbGFzdCB1cGRhdGUuXFxuICAgICAgICovXFxuICAgICAgdXBkYXRlKGR0KSB7XFxuICAgICAgICBsZXQgaSA9IHRoaXMuc2l6ZSAtIDE7XFxuICAgICAgICBsZXQgb2JqO1xcblxcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIga2lsbHMgYW4gb2JqZWN0IG91dHNpZGUgb2YgdGhlIHVwZGF0ZSBjeWNsZSwgdGhlIHBvb2wgd29uJ3Qga25vdyBvZlxcbiAgICAgICAgLy8gdGhlIGNoYW5nZSB1bnRpbCB0aGUgbmV4dCB1cGRhdGUgYW5kIGluVXNlIHdvbid0IGJlIGRlY3JlbWVudGVkLiBJZiB0aGUgdXNlciB0aGVuXFxuICAgICAgICAvLyBnZXRzIGFuIG9iamVjdCB3aGVuIGluVXNlIGlzIHRoZSBzYW1lIHNpemUgYXMgb2JqZWN0cy5sZW5ndGgsIGluVXNlIHdpbGwgaW5jcmVtZW50XFxuICAgICAgICAvLyBhbmQgdGhpcyBzdGF0ZW1lbnQgd2lsbCBldmFsdWF0ZSB0byAtMS5cXG4gICAgICAgIC8vXFxuICAgICAgICAvLyBJIGRvbid0IGxpa2UgaGF2aW5nIHRvIGdvIHRocm91Z2ggdGhlIHBvb2wgdG8ga2lsbCBhbiBvYmplY3QgYXMgaXQgZm9yY2VzIHlvdSB0b1xcbiAgICAgICAgLy8ga25vdyB3aGljaCBvYmplY3QgY2FtZSBmcm9tIHdoaWNoIHBvb2wuIEluc3RlYWQsIHdlJ2xsIGp1c3QgcHJldmVudCB0aGUgaW5kZXggZnJvbVxcbiAgICAgICAgLy8gZ29pbmcgYmVsb3cgMCBhbmQgYWNjZXB0IHRoZSBmYWN0IHRoYXQgaW5Vc2UgbWF5IGJlIG91dCBvZiBzeW5jIGZvciBhIGZyYW1lLlxcbiAgICAgICAgbGV0IGluZGV4ID0gTWF0aC5tYXgodGhpcy5vYmplY3RzLmxlbmd0aCAtIGluVXNlLCAwKTtcXG5cXG4gICAgICAgIC8vIG9ubHkgaXRlcmF0ZSBvdmVyIHRoZSBvYmplY3RzIHRoYXQgYXJlIGFsaXZlXFxuICAgICAgICB3aGlsZSAoaSA+PSBpbmRleCkge1xcbiAgICAgICAgICBvYmogPSB0aGlzLm9iamVjdHNbaV07XFxuXFxuICAgICAgICAgIG9iai51cGRhdGUoZHQpO1xcblxcbiAgICAgICAgICAvLyBpZiB0aGUgb2JqZWN0IGlzIGRlYWQsIG1vdmUgaXQgdG8gdGhlIGZyb250IG9mIHRoZSBwb29sXFxuICAgICAgICAgIGlmICghb2JqLmlzQWxpdmUoKSkge1xcbiAgICAgICAgICAgIHRoaXMub2JqZWN0cyA9IHRoaXMub2JqZWN0cy5zcGxpY2UoaSwgMSkuY29uY2F0KHRoaXMub2JqZWN0cyk7XFxuICAgICAgICAgICAgaW5Vc2UtLTtcXG4gICAgICAgICAgICBpbmRleCsrO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIGktLTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuXFxuICAgICAgLyoqXFxuICAgICAgICogcmVuZGVyIGFsbCBhbGl2ZSBwb29sIG9iamVjdHMuXFxuICAgICAgICogQG1lbWJlcm9mIGtvbnRyYS5wb29sXFxuICAgICAgICovXFxuICAgICAgcmVuZGVyKCkge1xcbiAgICAgICAgbGV0IGluZGV4ID0gTWF0aC5tYXgodGhpcy5vYmplY3RzLmxlbmd0aCAtIGluVXNlLCAwKTtcXG5cXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnNpemUgLSAxOyBpID49IGluZGV4OyBpLS0pIHtcXG4gICAgICAgICAgdGhpcy5vYmplY3RzW2ldLnJlbmRlcigpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfTtcXG4gIH07XFxufSkoKTtcXG4oZnVuY3Rpb24oKSB7XFxuXFxuICAvKipcXG4gICAqIEEgcXVhZHRyZWUgZm9yIDJEIGNvbGxpc2lvbiBjaGVja2luZy4gVGhlIHF1YWR0cmVlIGFjdHMgbGlrZSBhbiBvYmplY3QgcG9vbCBpbiB0aGF0IGl0XFxuICAgKiB3aWxsIGNyZWF0ZSBzdWJub2RlcyBhcyBvYmplY3RzIGFyZSBuZWVkZWQgYnV0IGl0IHdvbid0IGNsZWFuIHVwIHRoZSBzdWJub2RlcyB3aGVuIGl0XFxuICAgKiBjb2xsYXBzZXMgdG8gYXZvaWQgZ2FyYmFnZSBjb2xsZWN0aW9uLlxcbiAgICogQG1lbWJlcm9mIGtvbnRyYVxcbiAgICpcXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wZXJ0aWVzIC0gUHJvcGVydGllcyBvZiB0aGUgcXVhZHRyZWUuXFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3Byb3BlcnRpZXMubWF4RGVwdGg9M10gLSBNYXhpbXVtIG5vZGUgZGVwdGhzIHRoZSBxdWFkdHJlZSBjYW4gaGF2ZS5cXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJvcGVydGllcy5tYXhPYmplY3RzPTI1XSAtIE1heGltdW0gbnVtYmVyIG9mIG9iamVjdHMgYSBub2RlIGNhbiBzdXBwb3J0IGJlZm9yZSBzcGxpdHRpbmcuXFxuICAgKiBAcGFyYW0ge29iamVjdH0gW3Byb3BlcnRpZXMuYm91bmRzXSAtIFRoZSAyRCBzcGFjZSB0aGlzIG5vZGUgb2NjdXBpZXMuXFxuICAgKiBAcGFyYW0ge29iamVjdH0gW3Byb3BlcnRpZXMucGFyZW50XSAtIFByaXZhdGUuIFRoZSBub2RlIHRoYXQgY29udGFpbnMgdGhpcyBub2RlLlxcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwcm9wZXJ0aWVzLmRlcHRoPTBdIC0gUHJpdmF0ZS4gQ3VycmVudCBub2RlIGRlcHRoLlxcbiAgICpcXG4gICAqIFRoZSBxdWFkcmFudCBpbmRpY2VzIGFyZSBudW1iZXJlZCBhcyBmb2xsb3dzIChmb2xsb3dpbmcgYSB6LW9yZGVyIGN1cnZlKTpcXG4gICAqICAgICB8XFxuICAgKiAgMCAgfCAgMVxcbiAgICogLS0tLSstLS0tXFxuICAgKiAgMiAgfCAgM1xcbiAgICogICAgIHxcXG4gICAqL1xcbiAga29udHJhLnF1YWR0cmVlID0gZnVuY3Rpb24ocHJvcGVydGllcykge1xcbiAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcyB8fCB7fTtcXG5cXG4gICAgcmV0dXJuIHtcXG4gICAgICBtYXhEZXB0aDogcHJvcGVydGllcy5tYXhEZXB0aCB8fCAzLFxcbiAgICAgIG1heE9iamVjdHM6IHByb3BlcnRpZXMubWF4T2JqZWN0cyB8fCAyNSxcXG5cXG4gICAgICAvLyBzaW5jZSB3ZSB3b24ndCBjbGVhbiB1cCBhbnkgc3Vibm9kZXMsIHdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiB3aGljaCBub2RlcyBhcmVcXG4gICAgICAvLyBjdXJyZW50bHkgdGhlIGxlYWYgbm9kZSBzbyB3ZSBrbm93IHdoaWNoIG5vZGVzIHRvIGFkZCBvYmplY3RzIHRvXFxuICAgICAgLy8gYiA9IGJyYW5jaCwgZCA9IGRlcHRoLCBwID0gcGFyZW50XFxuICAgICAgX2I6IGZhbHNlLFxcbiAgICAgIF9kOiBwcm9wZXJ0aWVzLmRlcHRoIHx8IDAsXFxuICAgICAgLyogQGlmIFZJU1VBTF9ERUJVRyAqL1xcbiAgICAgIF9wOiBwcm9wZXJ0aWVzLnBhcmVudCxcXG4gICAgICAvKiBAZW5kaWYgKi9cXG5cXG4gICAgICBib3VuZHM6IHByb3BlcnRpZXMuYm91bmRzIHx8IHtcXG4gICAgICAgIHg6IDAsXFxuICAgICAgICB5OiAwLFxcbiAgICAgICAgd2lkdGg6IGtvbnRyYS5jYW52YXMud2lkdGgsXFxuICAgICAgICBoZWlnaHQ6IGtvbnRyYS5jYW52YXMuaGVpZ2h0XFxuICAgICAgfSxcXG5cXG4gICAgICBvYmplY3RzOiBbXSxcXG4gICAgICBzdWJub2RlczogW10sXFxuXFxuICAgICAgLyoqXFxuICAgICAgICogQ2xlYXIgdGhlIHF1YWR0cmVlXFxuICAgICAgICogQG1lbWJlcm9mIGtvbnRyYS5xdWFkdHJlZVxcbiAgICAgICAqL1xcbiAgICAgIGNsZWFyKCkge1xcbiAgICAgICAgdGhpcy5zdWJub2Rlcy5tYXAoZnVuY3Rpb24oc3Vibm9kZSkge1xcbiAgICAgICAgICBzdWJub2RlLmNsZWFyKCk7XFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIHRoaXMuX2IgPSBmYWxzZTtcXG4gICAgICAgIHRoaXMub2JqZWN0cy5sZW5ndGggPSAwO1xcbiAgICAgIH0sXFxuXFxuICAgICAgLyoqXFxuICAgICAgICogRmluZCB0aGUgbGVhZiBub2RlIHRoZSBvYmplY3QgYmVsb25ncyB0byBhbmQgZ2V0IGFsbCBvYmplY3RzIHRoYXQgYXJlIHBhcnQgb2ZcXG4gICAgICAgKiB0aGF0IG5vZGUuXFxuICAgICAgICogQG1lbWJlcm9mIGtvbnRyYS5xdWFkdHJlZVxcbiAgICAgICAqXFxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCAtIE9iamVjdCB0byB1c2UgZm9yIGZpbmRpbmcgdGhlIGxlYWYgbm9kZS5cXG4gICAgICAgKlxcbiAgICAgICAqIEByZXR1cm5zIHtvYmplY3RbXX0gQSBsaXN0IG9mIG9iamVjdHMgaW4gdGhlIHNhbWUgbGVhZiBub2RlIGFzIHRoZSBvYmplY3QuXFxuICAgICAgICovXFxuICAgICAgZ2V0KG9iamVjdCkge1xcbiAgICAgICAgbGV0IG9iamVjdHMgPSBbXTtcXG4gICAgICAgIGxldCBpbmRpY2VzLCBpO1xcblxcbiAgICAgICAgLy8gdHJhdmVyc2UgdGhlIHRyZWUgdW50aWwgd2UgZ2V0IHRvIGEgbGVhZiBub2RlXFxuICAgICAgICB3aGlsZSAodGhpcy5zdWJub2Rlcy5sZW5ndGggJiYgdGhpcy5fYikge1xcbiAgICAgICAgICBpbmRpY2VzID0gdGhpcy5fZyhvYmplY3QpO1xcblxcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgIG9iamVjdHMucHVzaC5hcHBseShvYmplY3RzLCB0aGlzLnN1Ym5vZGVzWyBpbmRpY2VzW2ldIF0uZ2V0KG9iamVjdCkpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiBvYmplY3RzO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0cztcXG4gICAgICB9LFxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIEFkZCBhbiBvYmplY3QgdG8gdGhlIHF1YWR0cmVlLiBPbmNlIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyBpbiB0aGUgbm9kZSBleGNlZWRzXFxuICAgICAgICogdGhlIG1heGltdW0gbnVtYmVyIG9mIG9iamVjdHMgYWxsb3dlZCwgaXQgd2lsbCBzcGxpdCBhbmQgbW92ZSBhbGwgb2JqZWN0cyB0byB0aGVpclxcbiAgICAgICAqIGNvcnJlc3BvbmRpbmcgc3Vibm9kZXMuXFxuICAgICAgICogQG1lbWJlcm9mIGtvbnRyYS5xdWFkdHJlZVxcbiAgICAgICAqXFxuICAgICAgICogQHBhcmFtIHsuLi5vYmplY3R8b2JqZWN0W119IE9iamVjdHMgdG8gYWRkIHRvIHRoZSBxdWFkdHJlZVxcbiAgICAgICAqXFxuICAgICAgICogQGV4YW1wbGVcXG4gICAgICAgKiBrb250cmEucXVhZHRyZWUoKS5hZGQoe2lkOjF9LCB7aWQ6Mn0sIHtpZDozfSk7XFxuICAgICAgICoga29udHJhLnF1YWR0cmVlKCkuYWRkKFt7aWQ6MX0sIHtpZDoyfV0sIHtpZDozfSk7XFxuICAgICAgICovXFxuICAgICAgYWRkKCkge1xcbiAgICAgICAgbGV0IGksIGosIG9iamVjdCwgb2JqLCBpbmRpY2VzLCBpbmRleDtcXG5cXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBhcmd1bWVudHMubGVuZ3RoOyBqKyspIHtcXG4gICAgICAgICAgb2JqZWN0ID0gYXJndW1lbnRzW2pdO1xcblxcbiAgICAgICAgICAvLyBhZGQgYSBncm91cCBvZiBvYmplY3RzIHNlcGFyYXRlbHlcXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xcbiAgICAgICAgICAgIHRoaXMuYWRkLmFwcGx5KHRoaXMsIG9iamVjdCk7XFxuXFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgLy8gY3VycmVudCBub2RlIGhhcyBzdWJub2Rlcywgc28gd2UgbmVlZCB0byBhZGQgdGhpcyBvYmplY3QgaW50byBhIHN1Ym5vZGVcXG4gICAgICAgICAgaWYgKHRoaXMuX2IpIHtcXG4gICAgICAgICAgICB0aGlzLl9hKG9iamVjdCk7XFxuXFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgLy8gdGhpcyBub2RlIGlzIGEgbGVhZiBub2RlIHNvIGFkZCB0aGUgb2JqZWN0IHRvIGl0XFxuICAgICAgICAgIHRoaXMub2JqZWN0cy5wdXNoKG9iamVjdCk7XFxuXFxuICAgICAgICAgIC8vIHNwbGl0IHRoZSBub2RlIGlmIHRoZXJlIGFyZSB0b28gbWFueSBvYmplY3RzXFxuICAgICAgICAgIGlmICh0aGlzLm9iamVjdHMubGVuZ3RoID4gdGhpcy5tYXhPYmplY3RzICYmIHRoaXMuX2QgPCB0aGlzLm1heERlcHRoKSB7XFxuICAgICAgICAgICAgdGhpcy5fcygpO1xcblxcbiAgICAgICAgICAgIC8vIG1vdmUgYWxsIG9iamVjdHMgdG8gdGhlaXIgY29ycmVzcG9uZGluZyBzdWJub2Rlc1xcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IChvYmogPSB0aGlzLm9iamVjdHNbaV0pOyBpKyspIHtcXG4gICAgICAgICAgICAgIHRoaXMuX2Eob2JqKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgdGhpcy5vYmplY3RzLmxlbmd0aCA9IDA7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9LFxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIEFkZCBhbiBvYmplY3QgdG8gYSBzdWJub2RlLlxcbiAgICAgICAqIEBtZW1iZXJvZiBrb250cmEucXVhZHRyZWVcXG4gICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAqXFxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCAtIE9iamVjdCB0byBhZGQgaW50byBhIHN1Ym5vZGVcXG4gICAgICAgKi9cXG4gICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qZWQvMTQwYnl0ZXMvd2lraS9CeXRlLXNhdmluZy10ZWNobmlxdWVzI3VzZS1wbGFjZWhvbGRlci1hcmd1bWVudHMtaW5zdGVhZC1vZi12YXJcXG4gICAgICBfYShvYmplY3QsIGluZGljZXMsIGkpIHtcXG4gICAgICAgIGluZGljZXMgPSB0aGlzLl9nKG9iamVjdCk7XFxuXFxuICAgICAgICAvLyBhZGQgdGhlIG9iamVjdCB0byBhbGwgc3Vibm9kZXMgaXQgaW50ZXJzZWN0c1xcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgdGhpcy5zdWJub2Rlc1sgaW5kaWNlc1tpXSBdLmFkZChvYmplY3QpO1xcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuXFxuICAgICAgLyoqXFxuICAgICAgICogRGV0ZXJtaW5lIHdoaWNoIHN1Ym5vZGVzIHRoZSBvYmplY3QgaW50ZXJzZWN0cyB3aXRoLlxcbiAgICAgICAqIEBtZW1iZXJvZiBrb250cmEucXVhZHRyZWVcXG4gICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAqXFxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCAtIE9iamVjdCB0byBjaGVjay5cXG4gICAgICAgKlxcbiAgICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX0gTGlzdCBvZiBhbGwgc3Vibm9kZXMgb2JqZWN0IGludGVyc2VjdHMuXFxuICAgICAgICovXFxuICAgICAgX2cob2JqZWN0KSB7XFxuICAgICAgICBsZXQgaW5kaWNlcyA9IFtdO1xcblxcbiAgICAgICAgbGV0IHZlcnRpY2FsTWlkcG9pbnQgPSB0aGlzLmJvdW5kcy54ICsgdGhpcy5ib3VuZHMud2lkdGggLyAyO1xcbiAgICAgICAgbGV0IGhvcml6b250YWxNaWRwb2ludCA9IHRoaXMuYm91bmRzLnkgKyB0aGlzLmJvdW5kcy5oZWlnaHQgLyAyO1xcblxcbiAgICAgICAgLy8gc2F2ZSBvZmYgcXVhZHJhbnQgY2hlY2tzIGZvciByZXVzZVxcbiAgICAgICAgbGV0IGludGVyc2VjdHNUb3BRdWFkcmFudHMgPSBvYmplY3QueSA8IGhvcml6b250YWxNaWRwb2ludCAmJiBvYmplY3QueSArIG9iamVjdC5oZWlnaHQgPj0gdGhpcy5ib3VuZHMueTtcXG4gICAgICAgIGxldCBpbnRlcnNlY3RzQm90dG9tUXVhZHJhbnRzID0gb2JqZWN0LnkgKyBvYmplY3QuaGVpZ2h0ID49IGhvcml6b250YWxNaWRwb2ludCAmJiBvYmplY3QueSA8IHRoaXMuYm91bmRzLnkgKyB0aGlzLmJvdW5kcy5oZWlnaHQ7XFxuXFxuICAgICAgICAvLyBvYmplY3QgaW50ZXJzZWN0cyB3aXRoIHRoZSBsZWZ0IHF1YWRyYW50c1xcbiAgICAgICAgaWYgKG9iamVjdC54IDwgdmVydGljYWxNaWRwb2ludCAmJiBvYmplY3QueCArIG9iamVjdC53aWR0aCA+PSB0aGlzLmJvdW5kcy54KSB7XFxuICAgICAgICAgIGlmIChpbnRlcnNlY3RzVG9wUXVhZHJhbnRzKSB7ICAvLyB0b3AgbGVmdFxcbiAgICAgICAgICAgIGluZGljZXMucHVzaCgwKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoaW50ZXJzZWN0c0JvdHRvbVF1YWRyYW50cykgeyAgLy8gYm90dG9tIGxlZnRcXG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goMik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIG9iamVjdCBpbnRlcnNlY3RzIHdpdGggdGhlIHJpZ2h0IHF1YWRyYW50c1xcbiAgICAgICAgaWYgKG9iamVjdC54ICsgb2JqZWN0LndpZHRoID49IHZlcnRpY2FsTWlkcG9pbnQgJiYgb2JqZWN0LnggPCB0aGlzLmJvdW5kcy54ICsgdGhpcy5ib3VuZHMud2lkdGgpIHsgIC8vIHRvcCByaWdodFxcbiAgICAgICAgICBpZiAoaW50ZXJzZWN0c1RvcFF1YWRyYW50cykge1xcbiAgICAgICAgICAgIGluZGljZXMucHVzaCgxKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoaW50ZXJzZWN0c0JvdHRvbVF1YWRyYW50cykgeyAgLy8gYm90dG9tIHJpZ2h0XFxuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKDMpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gaW5kaWNlcztcXG4gICAgICB9LFxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIFNwbGl0IHRoZSBub2RlIGludG8gZm91ciBzdWJub2Rlcy5cXG4gICAgICAgKiBAbWVtYmVyb2Yga29udHJhLnF1YWR0cmVlXFxuICAgICAgICogQHByaXZhdGVcXG4gICAgICAgKi9cXG4gICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qZWQvMTQwYnl0ZXMvd2lraS9CeXRlLXNhdmluZy10ZWNobmlxdWVzI3VzZS1wbGFjZWhvbGRlci1hcmd1bWVudHMtaW5zdGVhZC1vZi12YXJcXG4gICAgICBfcyhzdWJXaWR0aCwgc3ViSGVpZ2h0LCBpKSB7XFxuICAgICAgICB0aGlzLl9iID0gdHJ1ZTtcXG5cXG4gICAgICAgIC8vIG9ubHkgc3BsaXQgaWYgd2UgaGF2ZW4ndCBzcGxpdCBiZWZvcmVcXG4gICAgICAgIGlmICh0aGlzLnN1Ym5vZGVzLmxlbmd0aCkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzdWJXaWR0aCA9IHRoaXMuYm91bmRzLndpZHRoIC8gMiB8IDA7XFxuICAgICAgICBzdWJIZWlnaHQgPSB0aGlzLmJvdW5kcy5oZWlnaHQgLyAyIHwgMDtcXG5cXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcXG4gICAgICAgICAgdGhpcy5zdWJub2Rlc1tpXSA9IGtvbnRyYS5xdWFkdHJlZSh7XFxuICAgICAgICAgICAgYm91bmRzOiB7XFxuICAgICAgICAgICAgICB4OiB0aGlzLmJvdW5kcy54ICsgKGkgJSAyID09PSAxID8gc3ViV2lkdGggOiAwKSwgIC8vIG5vZGVzIDEgYW5kIDNcXG4gICAgICAgICAgICAgIHk6IHRoaXMuYm91bmRzLnkgKyAoaSA+PSAyID8gc3ViSGVpZ2h0IDogMCksICAgICAgLy8gbm9kZXMgMiBhbmQgM1xcbiAgICAgICAgICAgICAgd2lkdGg6IHN1YldpZHRoLFxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBzdWJIZWlnaHRcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGRlcHRoOiB0aGlzLl9kKzEsXFxuICAgICAgICAgICAgbWF4RGVwdGg6IHRoaXMubWF4RGVwdGgsXFxuICAgICAgICAgICAgbWF4T2JqZWN0czogdGhpcy5tYXhPYmplY3RzLFxcbiAgICAgICAgICAgIC8qIEBpZiBWSVNVQUxfREVCVUcgKi9cXG4gICAgICAgICAgICBwYXJlbnQ6IHRoaXNcXG4gICAgICAgICAgICAvKiBAZW5kaWYgKi9cXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfSxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBEcmF3IHRoZSBxdWFkdHJlZS4gVXNlZnVsIGZvciB2aXN1YWwgZGVidWdnaW5nLlxcbiAgICAgICAqIEBtZW1iZXJvZiBrb250cmEucXVhZHRyZWVcXG4gICAgICAgKi9cXG4gICAgICAgLyogQGlmIFZJU1VBTF9ERUJVRyAqKlxcbiAgICAgICByZW5kZXIoKSB7XFxuICAgICAgICAgLy8gZG9uJ3QgZHJhdyBlbXB0eSBsZWFmIG5vZGVzLCBhbHdheXMgZHJhdyBicmFuY2ggbm9kZXMgYW5kIHRoZSBmaXJzdCBub2RlXFxuICAgICAgICAgaWYgKHRoaXMub2JqZWN0cy5sZW5ndGggfHwgdGhpcy5fZCA9PT0gMCB8fFxcbiAgICAgICAgICAgICAodGhpcy5fcCAmJiB0aGlzLl9wLl9iKSkge1xcblxcbiAgICAgICAgICAga29udHJhLmNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmVkJztcXG4gICAgICAgICAgIGtvbnRyYS5jb250ZXh0LnN0cm9rZVJlY3QodGhpcy5ib3VuZHMueCwgdGhpcy5ib3VuZHMueSwgdGhpcy5ib3VuZHMud2lkdGgsIHRoaXMuYm91bmRzLmhlaWdodCk7XFxuXFxuICAgICAgICAgICBpZiAodGhpcy5zdWJub2Rlcy5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcXG4gICAgICAgICAgICAgICB0aGlzLnN1Ym5vZGVzW2ldLnJlbmRlcigpO1xcbiAgICAgICAgICAgICB9XFxuICAgICAgICAgICB9XFxuICAgICAgICAgfVxcbiAgICAgICB9XFxuICAgICAgIC8qIEBlbmRpZiAqL1xcbiAgICB9O1xcbiAgfTtcXG59KSgpO1xcbihmdW5jdGlvbigpIHtcXG5cXG4gIGNsYXNzIFZlY3RvciB7XFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXplIHRoZSB2ZWN0b3JzIHggYW5kIHkgcG9zaXRpb24uXFxuICAgICAqIEBtZW1iZXJvZiBrb250cmEudmVjdG9yXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIFggY29vcmRpbmF0ZS5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gWSBjb29yZGluYXRlLlxcbiAgICAgKlxcbiAgICAgKiBAcmV0dXJucyB7dmVjdG9yfVxcbiAgICAgKi9cXG4gICAgY29uc3RydWN0b3IoeCwgeSkge1xcbiAgICAgIHRoaXMuX3ggPSB4IHx8IDA7XFxuICAgICAgdGhpcy5feSA9IHkgfHwgMDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQWRkIGEgdmVjdG9yIHRvIHRoaXMgdmVjdG9yLlxcbiAgICAgKiBAbWVtYmVyb2Yga29udHJhLnZlY3RvclxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yIC0gVmVjdG9yIHRvIGFkZC5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR0PTEgLSBUaW1lIHNpbmNlIGxhc3QgdXBkYXRlLlxcbiAgICAgKi9cXG4gICAgYWRkKHZlY3RvciwgZHQpIHtcXG4gICAgICB0aGlzLnggKz0gKHZlY3Rvci54IHx8IDApICogKGR0IHx8IDEpO1xcbiAgICAgIHRoaXMueSArPSAodmVjdG9yLnkgfHwgMCkgKiAoZHQgfHwgMSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENsYW1wIHRoZSB2ZWN0b3IgYmV0d2VlbiB0d28gcG9pbnRzIHRoYXQgZm9ybSBhIHJlY3RhbmdsZS5cXG4gICAgICogQG1lbWJlcm9mIGtvbnRyYS52ZWN0b3JcXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhNaW4gLSBNaW4geCB2YWx1ZS5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlNaW4gLSBNaW4geSB2YWx1ZS5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhNYXggLSBNYXggeCB2YWx1ZS5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlNYXggLSBNYXggeSB2YWx1ZS5cXG4gICAgICovXFxuICAgIGNsYW1wKHhNaW4sIHlNaW4sIHhNYXgsIHlNYXgpIHtcXG4gICAgICB0aGlzLl9jID0gdHJ1ZTtcXG4gICAgICB0aGlzLl9hID0geE1pbjtcXG4gICAgICB0aGlzLl9iID0geU1pbjtcXG4gICAgICB0aGlzLl9kID0geE1heDtcXG4gICAgICB0aGlzLl9lID0geU1heDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVmVjdG9yIHhcXG4gICAgICogQG1lbWJlcm9mIGtvbnRyYS52ZWN0b3JcXG4gICAgICpcXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHhcXG4gICAgICovXFxuICAgIGdldCB4KCkge1xcbiAgICAgIHJldHVybiB0aGlzLl94O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBWZWN0b3IgeVxcbiAgICAgKiBAbWVtYmVyb2Yga29udHJhLnZlY3RvclxcbiAgICAgKlxcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0geVxcbiAgICAgKi9cXG4gICAgZ2V0IHkoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX3k7XFxuICAgIH1cXG5cXG4gICAgc2V0IHgodmFsdWUpIHtcXG4gICAgICB0aGlzLl94ID0gKHRoaXMuX2MgPyBNYXRoLm1pbiggTWF0aC5tYXgodGhpcy5fYSwgdmFsdWUpLCB0aGlzLl9kICkgOiB2YWx1ZSk7XFxuICAgIH1cXG5cXG4gICAgc2V0IHkodmFsdWUpIHtcXG4gICAgICB0aGlzLl95ID0gKHRoaXMuX2MgPyBNYXRoLm1pbiggTWF0aC5tYXgodGhpcy5fYiwgdmFsdWUpLCB0aGlzLl9lICkgOiB2YWx1ZSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogQSB2ZWN0b3IgZm9yIDJEIHNwYWNlLlxcbiAgICogQG1lbWJlcm9mIGtvbnRyYVxcbiAgICpcXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIFggY29vcmRpbmF0ZS5cXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIFkgY29vcmRpbmF0ZS5cXG4gICAqL1xcbiAga29udHJhLnZlY3RvciA9ICh4LCB5KSA9PiB7XFxuICAgIHJldHVybiBuZXcgVmVjdG9yKHgsIHkpO1xcbiAgfTtcXG4gIGtvbnRyYS52ZWN0b3IucHJvdG90eXBlID0gVmVjdG9yLnByb3RvdHlwZTtcXG5cXG5cXG5cXG5cXG5cXG4gIGNsYXNzIFNwcml0ZSB7XFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXplIHByb3BlcnRpZXMgb24gdGhlIHNwcml0ZS5cXG4gICAgICogQG1lbWJlcm9mIGtvbnRyYS5zcHJpdGVcXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXMgLSBQcm9wZXJ0aWVzIG9mIHRoZSBzcHJpdGUuXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwcm9wZXJ0aWVzLnggLSBYIGNvb3JkaW5hdGUgb2YgdGhlIHNwcml0ZS5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHByb3BlcnRpZXMueSAtIFkgY29vcmRpbmF0ZSBvZiB0aGUgc3ByaXRlLlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Byb3BlcnRpZXMuZHhdIC0gQ2hhbmdlIGluIFggcG9zaXRpb24uXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJvcGVydGllcy5keV0gLSBDaGFuZ2UgaW4gWSBwb3NpdGlvbi5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcm9wZXJ0aWVzLmRkeF0gLSBDaGFuZ2UgaW4gWCB2ZWxvY2l0eS5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcm9wZXJ0aWVzLmRkeV0gLSBDaGFuZ2UgaW4gWSB2ZWxvY2l0eS5cXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcm9wZXJ0aWVzLnR0bD0wXSAtIEhvdyBtYXkgZnJhbWVzIHRoZSBzcHJpdGUgc2hvdWxkIGJlIGFsaXZlLlxcbiAgICAgKiBAcGFyYW0ge0NvbnRleHR9IFtwcm9wZXJ0aWVzLmNvbnRleHQ9a29udHJhLmNvbnRleHRdIC0gUHJvdmlkZSBhIGNvbnRleHQgZm9yIHRoZSBzcHJpdGUgdG8gZHJhdyBvbi5cXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtJbWFnZXxDYW52YXN9IFtwcm9wZXJ0aWVzLmltYWdlXSAtIEltYWdlIGZvciB0aGUgc3ByaXRlLlxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3Byb3BlcnRpZXMuYW5pbWF0aW9uc10gLSBBbmltYXRpb25zIGZvciB0aGUgc3ByaXRlIGluc3RlYWQgb2YgYW4gaW1hZ2UuXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydGllcy5jb2xvcl0gLSBJZiBubyBpbWFnZSBvciBhbmltYXRpb24gaXMgcHJvdmlkZWQsIHVzZSBjb2xvciB0byBkcmF3IGEgcmVjdGFuZ2xlIGZvciB0aGUgc3ByaXRlLlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Byb3BlcnRpZXMud2lkdGhdIC0gV2lkdGggb2YgdGhlIHNwcml0ZSBmb3IgZHJhd2luZyBhIHJlY3RhbmdsZS5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcm9wZXJ0aWVzLmhlaWdodF0gLSBIZWlnaHQgb2YgdGhlIHNwcml0ZSBmb3IgZHJhd2luZyBhIHJlY3RhbmdsZS5cXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW3Byb3BlcnRpZXMudXBkYXRlXSAtIEZ1bmN0aW9uIHRvIHVzZSB0byB1cGRhdGUgdGhlIHNwcml0ZS5cXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW3Byb3BlcnRpZXMucmVuZGVyXSAtIEZ1bmN0aW9uIHRvIHVzZSB0byByZW5kZXIgdGhlIHNwcml0ZS5cXG4gICAgICpcXG4gICAgICogSWYgeW91IG5lZWQgdGhlIHNwcml0ZSB0byBsaXZlIGZvcmV2ZXIsIG9yIGp1c3QgbmVlZCBpdCB0byBzdGF5IG9uIHNjcmVlbiB1bnRpbCB5b3VcXG4gICAgICogZGVjaWRlIHdoZW4gdG8ga2lsbCBpdCwgeW91IGNhbiBzZXQgPGNvZGU+dHRsPC9jb2RlPiB0byA8Y29kZT5JbmZpbml0eTwvY29kZT4uXFxuICAgICAqIEp1c3QgYmUgc3VyZSB0byBzZXQgPGNvZGU+dHRsPC9jb2RlPiB0byAwIHdoZW4geW91IHdhbnQgdGhlIHNwcml0ZSB0byBkaWUuXFxuICAgICAqL1xcbiAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qZWQvMTQwYnl0ZXMvd2lraS9CeXRlLXNhdmluZy10ZWNobmlxdWVzI3VzZS1wbGFjZWhvbGRlci1hcmd1bWVudHMtaW5zdGVhZC1vZi12YXJcXG4gICAgaW5pdChwcm9wZXJ0aWVzLCBwcm9wLCB0ZW1wLCBmaXJzdEFuaW1hdGlvbikge1xcbiAgICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IHt9O1xcblxcbiAgICAgIHRoaXMucG9zaXRpb24gPSBrb250cmEudmVjdG9yKHByb3BlcnRpZXMueCwgcHJvcGVydGllcy55KTtcXG4gICAgICB0aGlzLnZlbG9jaXR5ID0ga29udHJhLnZlY3Rvcihwcm9wZXJ0aWVzLmR4LCBwcm9wZXJ0aWVzLmR5KTtcXG4gICAgICB0aGlzLmFjY2VsZXJhdGlvbiA9IGtvbnRyYS52ZWN0b3IocHJvcGVydGllcy5kZHgsIHByb3BlcnRpZXMuZGR5KTtcXG5cXG4gICAgICAvLyBkZWZhdWx0c1xcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XFxuICAgICAgdGhpcy5jb250ZXh0ID0ga29udHJhLmNvbnRleHQ7XFxuXFxuICAgICAgLy8gbG9vcCB0aHJvdWdoIHByb3BlcnRpZXMgYmVmb3JlIG92ZXJyaWRlc1xcbiAgICAgIGZvciAocHJvcCBpbiBwcm9wZXJ0aWVzKSB7XFxuICAgICAgICB0aGlzW3Byb3BdID0gcHJvcGVydGllc1twcm9wXTtcXG4gICAgICB9XFxuXFxuICAgICAgLy8gaW1hZ2Ugc3ByaXRlXFxuICAgICAgaWYgKHRlbXAgPSBwcm9wZXJ0aWVzLmltYWdlKSB7XFxuICAgICAgICB0aGlzLmltYWdlID0gdGVtcDtcXG4gICAgICAgIHRoaXMud2lkdGggPSB0ZW1wLndpZHRoO1xcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0ZW1wLmhlaWdodDtcXG4gICAgICB9XFxuICAgICAgLy8gYW5pbWF0aW9uIHNwcml0ZVxcbiAgICAgIGVsc2UgaWYgKHRlbXAgPSBwcm9wZXJ0aWVzLmFuaW1hdGlvbnMpIHtcXG5cXG4gICAgICAgIC8vIGNsb25lIGVhY2ggYW5pbWF0aW9uIHNvIG5vIHNwcml0ZSBzaGFyZXMgYW4gYW5pbWF0aW9uXFxuICAgICAgICBmb3IgKHByb3AgaW4gdGVtcCkge1xcbiAgICAgICAgICB0aGlzLmFuaW1hdGlvbnNbcHJvcF0gPSB0ZW1wW3Byb3BdLmNsb25lKCk7XFxuXFxuICAgICAgICAgIC8vIGRlZmF1bHQgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIHRvIHRoZSBmaXJzdCBvbmUgaW4gdGhlIGxpc3RcXG4gICAgICAgICAgZmlyc3RBbmltYXRpb24gPSBmaXJzdEFuaW1hdGlvbiB8fCB0ZW1wW3Byb3BdO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5fY2EgPSBmaXJzdEFuaW1hdGlvbjtcXG4gICAgICAgIHRoaXMud2lkdGggPSBmaXJzdEFuaW1hdGlvbi53aWR0aDtcXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZmlyc3RBbmltYXRpb24uaGVpZ2h0O1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfVxcblxcbiAgICAvLyBkZWZpbmUgZ2V0dGVyIGFuZCBzZXR0ZXIgc2hvcnRjdXQgZnVuY3Rpb25zIHRvIG1ha2UgaXQgZWFzaWVyIHRvIHdvcmsgd2l0aCB0aGVcXG4gICAgLy8gcG9zaXRpb24sIHZlbG9jaXR5LCBhbmQgYWNjZWxlcmF0aW9uIHZlY3RvcnMuXFxuXFxuICAgIC8qKlxcbiAgICAgKiBTcHJpdGUgcG9zaXRpb24ueFxcbiAgICAgKiBAbWVtYmVyb2Yga29udHJhLnNwcml0ZVxcbiAgICAgKlxcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0geFxcbiAgICAgKi9cXG4gICAgZ2V0IHgoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24ueDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogU3ByaXRlIHBvc2l0aW9uLnlcXG4gICAgICogQG1lbWJlcm9mIGtvbnRyYS5zcHJpdGVcXG4gICAgICpcXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHlcXG4gICAgICovXFxuICAgIGdldCB5KCkge1xcbiAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLnk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFNwcml0ZSB2ZWxvY2l0eS54XFxuICAgICAqIEBtZW1iZXJvZiBrb250cmEuc3ByaXRlXFxuICAgICAqXFxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkeFxcbiAgICAgKi9cXG4gICAgZ2V0IGR4KCkge1xcbiAgICAgIHJldHVybiB0aGlzLnZlbG9jaXR5Lng7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFNwcml0ZSB2ZWxvY2l0eS55XFxuICAgICAqIEBtZW1iZXJvZiBrb250cmEuc3ByaXRlXFxuICAgICAqXFxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkeVxcbiAgICAgKi9cXG4gICAgZ2V0IGR5KCkge1xcbiAgICAgIHJldHVybiB0aGlzLnZlbG9jaXR5Lnk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFNwcml0ZSBhY2NlbGVyYXRpb24ueFxcbiAgICAgKiBAbWVtYmVyb2Yga29udHJhLnNwcml0ZVxcbiAgICAgKlxcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGR4XFxuICAgICAqL1xcbiAgICBnZXQgZGR4KCkge1xcbiAgICAgIHJldHVybiB0aGlzLmFjY2VsZXJhdGlvbi54O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBTcHJpdGUgYWNjZWxlcmF0aW9uLnlcXG4gICAgICogQG1lbWJlcm9mIGtvbnRyYS5zcHJpdGVcXG4gICAgICpcXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRkeVxcbiAgICAgKi9cXG4gICAgZ2V0IGRkeSgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5hY2NlbGVyYXRpb24ueTtcXG4gICAgfVxcblxcbiAgICBzZXQgeCh2YWx1ZSkge1xcbiAgICAgIHRoaXMucG9zaXRpb24ueCA9IHZhbHVlO1xcbiAgICB9XFxuICAgIHNldCB5KHZhbHVlKSB7XFxuICAgICAgdGhpcy5wb3NpdGlvbi55ID0gdmFsdWU7XFxuICAgIH1cXG4gICAgc2V0IGR4KHZhbHVlKSB7XFxuICAgICAgdGhpcy52ZWxvY2l0eS54ID0gdmFsdWU7XFxuICAgIH1cXG4gICAgc2V0IGR5KHZhbHVlKSB7XFxuICAgICAgdGhpcy52ZWxvY2l0eS55ID0gdmFsdWU7XFxuICAgIH1cXG4gICAgc2V0IGRkeCh2YWx1ZSkge1xcbiAgICAgIHRoaXMuYWNjZWxlcmF0aW9uLnggPSB2YWx1ZTtcXG4gICAgfVxcbiAgICBzZXQgZGR5KHZhbHVlKSB7XFxuICAgICAgdGhpcy5hY2NlbGVyYXRpb24ueSA9IHZhbHVlO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBEZXRlcm1pbmUgaWYgdGhlIHNwcml0ZSBpcyBhbGl2ZS5cXG4gICAgICogQG1lbWJlcm9mIGtvbnRyYS5zcHJpdGVcXG4gICAgICpcXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XFxuICAgICAqL1xcbiAgICBpc0FsaXZlKCkge1xcbiAgICAgIHJldHVybiB0aGlzLnR0bCA+IDA7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFNpbXBsZSBib3VuZGluZyBib3ggY29sbGlzaW9uIHRlc3QuXFxuICAgICAqIEBtZW1iZXJvZiBrb250cmEuc3ByaXRlXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgLSBPYmplY3QgdG8gY2hlY2sgY29sbGlzaW9uIGFnYWluc3QuXFxuICAgICAqXFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBvYmplY3RzIGNvbGxpZGUsIGZhbHNlIG90aGVyd2lzZS5cXG4gICAgICovXFxuICAgIGNvbGxpZGVzV2l0aChvYmplY3QpIHtcXG4gICAgICByZXR1cm4gdGhpcy54IDwgb2JqZWN0LnggKyBvYmplY3Qud2lkdGggJiZcXG4gICAgICAgICAgICAgdGhpcy54ICsgdGhpcy53aWR0aCA+IG9iamVjdC54ICYmXFxuICAgICAgICAgICAgIHRoaXMueSA8IG9iamVjdC55ICsgb2JqZWN0LmhlaWdodCAmJlxcbiAgICAgICAgICAgICB0aGlzLnkgKyB0aGlzLmhlaWdodCA+IG9iamVjdC55O1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBVcGRhdGUgdGhlIHNwcml0ZXMgdmVsb2NpdHkgYW5kIHBvc2l0aW9uLlxcbiAgICAgKiBAbWVtYmVyb2Yga29udHJhLnNwcml0ZVxcbiAgICAgKiBAYWJzdHJhY3RcXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR0IC0gVGltZSBzaW5jZSBsYXN0IHVwZGF0ZS5cXG4gICAgICpcXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgb3ZlcnJpZGRlbiBvbiBhIHBlciBzcHJpdGUgYmFzaXMgaWYgbW9yZSBmdW5jdGlvbmFsaXR5XFxuICAgICAqIGlzIG5lZWRlZCBpbiB0aGUgdXBkYXRlIHN0ZXAuIEp1c3QgY2FsbCA8Y29kZT50aGlzLmFkdmFuY2UoKTwvY29kZT4gd2hlbiB5b3UgbmVlZFxcbiAgICAgKiB0aGUgc3ByaXRlIHRvIHVwZGF0ZSBpdHMgcG9zaXRpb24uXFxuICAgICAqXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqIHNwcml0ZSA9IGtvbnRyYS5zcHJpdGUoe1xcbiAgICAgKiAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGR0KSB7XFxuICAgICAqICAgICAvLyBkbyBzb21lIGxvZ2ljXFxuICAgICAqXFxuICAgICAqICAgICB0aGlzLmFkdmFuY2UoZHQpO1xcbiAgICAgKiAgIH1cXG4gICAgICogfSk7XFxuICAgICAqL1xcbiAgICB1cGRhdGUoZHQpIHtcXG4gICAgICB0aGlzLmFkdmFuY2UoZHQpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBSZW5kZXIgdGhlIHNwcml0ZS5cXG4gICAgICogQG1lbWJlcm9mIGtvbnRyYS5zcHJpdGUuXFxuICAgICAqIEBhYnN0cmFjdFxcbiAgICAgKlxcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBvdmVycmlkZGVuIG9uIGEgcGVyIHNwcml0ZSBiYXNpcyBpZiBtb3JlIGZ1bmN0aW9uYWxpdHlcXG4gICAgICogaXMgbmVlZGVkIGluIHRoZSByZW5kZXIgc3RlcC4gSnVzdCBjYWxsIDxjb2RlPnRoaXMuZHJhdygpPC9jb2RlPiB3aGVuIHlvdSBuZWVkIHRoZVxcbiAgICAgKiBzcHJpdGUgdG8gZHJhdyBpdHMgaW1hZ2UuXFxuICAgICAqXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqIHNwcml0ZSA9IGtvbnRyYS5zcHJpdGUoe1xcbiAgICAgKiAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xcbiAgICAgKiAgICAgLy8gZG8gc29tZSBsb2dpY1xcbiAgICAgKlxcbiAgICAgKiAgICAgdGhpcy5kcmF3KCk7XFxuICAgICAqICAgfVxcbiAgICAgKiB9KTtcXG4gICAgICovXFxuICAgIHJlbmRlcigpIHtcXG4gICAgICB0aGlzLmRyYXcoKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogUGxheSBhbiBhbmltYXRpb24uXFxuICAgICAqIEBtZW1iZXJvZiBrb250cmEuc3ByaXRlXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRvIHBsYXkuXFxuICAgICAqL1xcbiAgICBwbGF5QW5pbWF0aW9uKG5hbWUpIHtcXG4gICAgICB0aGlzLl9jYSA9IHRoaXMuYW5pbWF0aW9uc1tuYW1lXTtcXG5cXG4gICAgICBpZiAoIXRoaXMuX2NhLmxvb3ApIHtcXG4gICAgICAgIHRoaXMuX2NhLnJlc2V0KCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBBZHZhbmNlIHRoZSBzcHJpdGVzIHBvc2l0aW9uLCB2ZWxvY2l0eSwgYW5kIGN1cnJlbnQgYW5pbWF0aW9uIChpZiBpdFxcbiAgICAgKiBoYXMgb25lKS5cXG4gICAgICogQG1lbWJlcm9mIGtvbnRyYS5zcHJpdGVcXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR0IC0gVGltZSBzaW5jZSBsYXN0IHVwZGF0ZS5cXG4gICAgICovXFxuICAgIGFkdmFuY2UoZHQpIHtcXG4gICAgICB0aGlzLnZlbG9jaXR5LmFkZCh0aGlzLmFjY2VsZXJhdGlvbiwgZHQpO1xcbiAgICAgIHRoaXMucG9zaXRpb24uYWRkKHRoaXMudmVsb2NpdHksIGR0KTtcXG5cXG4gICAgICB0aGlzLnR0bC0tO1xcblxcbiAgICAgIGlmICh0aGlzLl9jYSkge1xcbiAgICAgICAgdGhpcy5fY2EudXBkYXRlKGR0KTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIERyYXcgdGhlIHNwcml0ZSB0byB0aGUgY2FudmFzLlxcbiAgICAgKiBAbWVtYmVyb2Yga29udHJhLnNwcml0ZVxcbiAgICAgKi9cXG4gICAgZHJhdygpIHtcXG4gICAgICBpZiAodGhpcy5pbWFnZSkge1xcbiAgICAgICAgdGhpcy5jb250ZXh0LmRyYXdJbWFnZSh0aGlzLmltYWdlLCB0aGlzLngsIHRoaXMueSk7XFxuICAgICAgfVxcbiAgICAgIGVsc2UgaWYgKHRoaXMuX2NhKSB7XFxuICAgICAgICB0aGlzLl9jYS5yZW5kZXIodGhpcyk7XFxuICAgICAgfVxcbiAgICAgIGVsc2Uge1xcbiAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuY29sb3I7XFxuICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFJlY3QodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH07XFxuXFxuICAvKipcXG4gICAqIEEgc3ByaXRlIHdpdGggYSBwb3NpdGlvbiwgdmVsb2NpdHksIGFuZCBhY2NlbGVyYXRpb24uXFxuICAgKiBAbWVtYmVyb2Yga29udHJhXFxuICAgKiBAcmVxdWlyZXMga29udHJhLnZlY3RvclxcbiAgICpcXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wZXJ0aWVzIC0gUHJvcGVydGllcyBvZiB0aGUgc3ByaXRlLlxcbiAgICogQHBhcmFtIHtudW1iZXJ9IHByb3BlcnRpZXMueCAtIFggY29vcmRpbmF0ZSBvZiB0aGUgc3ByaXRlLlxcbiAgICogQHBhcmFtIHtudW1iZXJ9IHByb3BlcnRpZXMueSAtIFkgY29vcmRpbmF0ZSBvZiB0aGUgc3ByaXRlLlxcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwcm9wZXJ0aWVzLmR4XSAtIENoYW5nZSBpbiBYIHBvc2l0aW9uLlxcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwcm9wZXJ0aWVzLmR5XSAtIENoYW5nZSBpbiBZIHBvc2l0aW9uLlxcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwcm9wZXJ0aWVzLmRkeF0gLSBDaGFuZ2UgaW4gWCB2ZWxvY2l0eS5cXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJvcGVydGllcy5kZHldIC0gQ2hhbmdlIGluIFkgdmVsb2NpdHkuXFxuICAgKlxcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwcm9wZXJ0aWVzLnR0bD0wXSAtIEhvdyBtYXkgZnJhbWVzIHRoZSBzcHJpdGUgc2hvdWxkIGJlIGFsaXZlLlxcbiAgICogQHBhcmFtIHtDb250ZXh0fSBbcHJvcGVydGllcy5jb250ZXh0PWtvbnRyYS5jb250ZXh0XSAtIFByb3ZpZGUgYSBjb250ZXh0IGZvciB0aGUgc3ByaXRlIHRvIGRyYXcgb24uXFxuICAgKlxcbiAgICogQHBhcmFtIHtJbWFnZXxDYW52YXN9IFtwcm9wZXJ0aWVzLmltYWdlXSAtIEltYWdlIGZvciB0aGUgc3ByaXRlLlxcbiAgICpcXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbcHJvcGVydGllcy5hbmltYXRpb25zXSAtIEFuaW1hdGlvbnMgZm9yIHRoZSBzcHJpdGUgaW5zdGVhZCBvZiBhbiBpbWFnZS5cXG4gICAqXFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnRpZXMuY29sb3JdIC0gSWYgbm8gaW1hZ2Ugb3IgYW5pbWF0aW9uIGlzIHByb3ZpZGVkLCB1c2UgY29sb3IgdG8gZHJhdyBhIHJlY3RhbmdsZSBmb3IgdGhlIHNwcml0ZS5cXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJvcGVydGllcy53aWR0aF0gLSBXaWR0aCBvZiB0aGUgc3ByaXRlIGZvciBkcmF3aW5nIGEgcmVjdGFuZ2xlLlxcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwcm9wZXJ0aWVzLmhlaWdodF0gLSBIZWlnaHQgb2YgdGhlIHNwcml0ZSBmb3IgZHJhd2luZyBhIHJlY3RhbmdsZS5cXG4gICAqXFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcHJvcGVydGllcy51cGRhdGVdIC0gRnVuY3Rpb24gdG8gdXNlIHRvIHVwZGF0ZSB0aGUgc3ByaXRlLlxcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW3Byb3BlcnRpZXMucmVuZGVyXSAtIEZ1bmN0aW9uIHRvIHVzZSB0byByZW5kZXIgdGhlIHNwcml0ZS5cXG4gICAqL1xcbiAga29udHJhLnNwcml0ZSA9IChwcm9wZXJ0aWVzKSA9PiB7XFxuICAgIHJldHVybiAobmV3IFNwcml0ZSgpKS5pbml0KHByb3BlcnRpZXMpO1xcbiAgfTtcXG4gIGtvbnRyYS5zcHJpdGUucHJvdG90eXBlID0gU3ByaXRlLnByb3RvdHlwZTtcXG59KSgpO1xcbihmdW5jdGlvbigpIHtcXG5cXG4gIGNsYXNzIEFuaW1hdGlvbiB7XFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXplIHByb3BlcnRpZXMgb24gdGhlIGFuaW1hdGlvbi5cXG4gICAgICogQG1lbWJlcm9mIGtvbnRyYS5hbmltYXRpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXMgLSBQcm9wZXJ0aWVzIG9mIHRoZSBhbmltYXRpb24uXFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wZXJ0aWVzLnNwcml0ZVNoZWV0IC0gU3ByaXRlIHNoZWV0IGZvciB0aGUgYW5pbWF0aW9uLlxcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBwcm9wZXJ0aWVzLmZyYW1lcyAtIExpc3Qgb2YgZnJhbWVzIG9mIHRoZSBhbmltYXRpb24uXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSAgcHJvcGVydGllcy5mcmFtZVJhdGUgLSBOdW1iZXIgb2YgZnJhbWVzIHRvIGRpc3BsYXkgaW4gb25lIHNlY29uZC5cXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcHJvcGVydGllcy5sb29wPXRydWVdIC0gSWYgdGhlIGFuaW1hdGlvbiBzaG91bGQgbG9vcC5cXG4gICAgICovXFxuICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2plZC8xNDBieXRlcy93aWtpL0J5dGUtc2F2aW5nLXRlY2huaXF1ZXMjdXNlLXBsYWNlaG9sZGVyLWFyZ3VtZW50cy1pbnN0ZWFkLW9mLXZhclxcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0aWVzLCBmcmFtZSkge1xcbiAgICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IHt9O1xcblxcbiAgICAgIHRoaXMuc3ByaXRlU2hlZXQgPSBwcm9wZXJ0aWVzLnNwcml0ZVNoZWV0O1xcbiAgICAgIHRoaXMuZnJhbWVzID0gcHJvcGVydGllcy5mcmFtZXM7XFxuICAgICAgdGhpcy5mcmFtZVJhdGUgPSBwcm9wZXJ0aWVzLmZyYW1lUmF0ZTtcXG4gICAgICB0aGlzLmxvb3AgPSAocHJvcGVydGllcy5sb29wID09PSB1bmRlZmluZWQgPyB0cnVlIDogcHJvcGVydGllcy5sb29wKTtcXG5cXG4gICAgICBmcmFtZSA9IHByb3BlcnRpZXMuc3ByaXRlU2hlZXQuZnJhbWU7XFxuICAgICAgdGhpcy53aWR0aCA9IGZyYW1lLndpZHRoO1xcbiAgICAgIHRoaXMuaGVpZ2h0ID0gZnJhbWUuaGVpZ2h0O1xcbiAgICAgIHRoaXMubWFyZ2luID0gZnJhbWUubWFyZ2luIHx8IDA7XFxuXFxuICAgICAgLy8gZiA9IGZyYW1lLCBhID0gYWNjdW11bGF0b3JcXG4gICAgICB0aGlzLl9mID0gMDtcXG4gICAgICB0aGlzLl9hID0gMDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ2xvbmUgYW4gYW5pbWF0aW9uIHRvIGJlIHVzZWQgbW9yZSB0aGFuIG9uY2UuXFxuICAgICAqIEBtZW1iZXJvZiBrb250cmEuYW5pbWF0aW9uXFxuICAgICAqXFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XFxuICAgICAqL1xcbiAgICBjbG9uZSgpIHtcXG4gICAgICByZXR1cm4ga29udHJhLmFuaW1hdGlvbih0aGlzKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogUmVzZXQgYW4gYW5pbWF0aW9uIHRvIHRoZSBmaXJzdCBmcmFtZS5cXG4gICAgICogQG1lbWJlcm9mIGtvbnRyYS5hbmltYXRpb25cXG4gICAgICovXFxuICAgIHJlc2V0KCkge1xcbiAgICAgIHRoaXMuX2YgPSAwO1xcbiAgICAgIHRoaXMuX2EgPSAwO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBVcGRhdGUgdGhlIGFuaW1hdGlvbi4gVXNlZCB3aGVuIHRoZSBhbmltYXRpb24gaXMgbm90IHBhdXNlZCBvciBzdG9wcGVkLlxcbiAgICAgKiBAbWVtYmVyb2Yga29udHJhLmFuaW1hdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2R0PTEvNjBdIC0gVGltZSBzaW5jZSBsYXN0IHVwZGF0ZS5cXG4gICAgICovXFxuICAgIHVwZGF0ZShkdCkge1xcblxcbiAgICAgIC8vIGlmIHRoZSBhbmltYXRpb24gZG9lc24ndCBsb29wIHdlIHN0b3AgYXQgdGhlIGxhc3QgZnJhbWVcXG4gICAgICBpZiAoIXRoaXMubG9vcCAmJiB0aGlzLl9mID09IHRoaXMuZnJhbWVzLmxlbmd0aC0xKSByZXR1cm47XFxuXFxuICAgICAgZHQgPSBkdCB8fCAxIC8gNjA7XFxuXFxuICAgICAgdGhpcy5fYSArPSBkdDtcXG5cXG4gICAgICAvLyB1cGRhdGUgdG8gdGhlIG5leHQgZnJhbWUgaWYgaXQncyB0aW1lXFxuICAgICAgd2hpbGUgKHRoaXMuX2EgKiB0aGlzLmZyYW1lUmF0ZSA+PSAxKSB7XFxuICAgICAgICB0aGlzLl9mID0gKyt0aGlzLl9mICUgdGhpcy5mcmFtZXMubGVuZ3RoO1xcbiAgICAgICAgdGhpcy5fYSAtPSAxIC8gdGhpcy5mcmFtZVJhdGU7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBEcmF3IHRoZSBjdXJyZW50IGZyYW1lLiBVc2VkIHdoZW4gdGhlIGFuaW1hdGlvbiBpcyBub3Qgc3RvcHBlZC5cXG4gICAgICogQG1lbWJlcm9mIGtvbnRyYS5hbmltYXRpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXMgLSBIb3cgdG8gZHJhdyB0aGUgYW5pbWF0aW9uLlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcHJvcGVydGllcy54IC0gWCBwb3NpdGlvbiB0byBkcmF3LlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcHJvcGVydGllcy55IC0gWSBwb3NpdGlvbiB0byBkcmF3LlxcbiAgICAgKiBAcGFyYW0ge0NvbnRleHR9IFtwcm9wZXJ0aWVzLmNvbnRleHQ9a29udHJhLmNvbnRleHRdIC0gUHJvdmlkZSBhIGNvbnRleHQgZm9yIHRoZSBzcHJpdGUgdG8gZHJhdyBvbi5cXG4gICAgICovXFxuICAgIHJlbmRlcihwcm9wZXJ0aWVzKSB7XFxuICAgICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwge307XFxuXFxuICAgICAgLy8gZ2V0IHRoZSByb3cgYW5kIGNvbCBvZiB0aGUgZnJhbWVcXG4gICAgICBsZXQgcm93ID0gdGhpcy5mcmFtZXNbdGhpcy5fZl0gLyB0aGlzLnNwcml0ZVNoZWV0Ll9mIHwgMDtcXG4gICAgICBsZXQgY29sID0gdGhpcy5mcmFtZXNbdGhpcy5fZl0gJSB0aGlzLnNwcml0ZVNoZWV0Ll9mIHwgMDtcXG5cXG4gICAgICAocHJvcGVydGllcy5jb250ZXh0IHx8IGtvbnRyYS5jb250ZXh0KS5kcmF3SW1hZ2UoXFxuICAgICAgICB0aGlzLnNwcml0ZVNoZWV0LmltYWdlLFxcbiAgICAgICAgY29sICogdGhpcy53aWR0aCArIChjb2wgKiAyICsgMSkgKiB0aGlzLm1hcmdpbixcXG4gICAgICAgIHJvdyAqIHRoaXMuaGVpZ2h0ICsgKHJvdyAqIDIgKyAxKSAqIHRoaXMubWFyZ2luLFxcbiAgICAgICAgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsXFxuICAgICAgICBwcm9wZXJ0aWVzLngsIHByb3BlcnRpZXMueSxcXG4gICAgICAgIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XFxuICAgICAgKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBTaW5nbGUgYW5pbWF0aW9uIGZyb20gYSBzcHJpdGUgc2hlZXQuXFxuICAgKiBAbWVtYmVyb2Yga29udHJhXFxuICAgKlxcbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXMgLSBQcm9wZXJ0aWVzIG9mIHRoZSBhbmltYXRpb24uXFxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcGVydGllcy5zcHJpdGVTaGVldCAtIFNwcml0ZSBzaGVldCBmb3IgdGhlIGFuaW1hdGlvbi5cXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IHByb3BlcnRpZXMuZnJhbWVzIC0gTGlzdCBvZiBmcmFtZXMgb2YgdGhlIGFuaW1hdGlvbi5cXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgcHJvcGVydGllcy5mcmFtZVJhdGUgLSBOdW1iZXIgb2YgZnJhbWVzIHRvIGRpc3BsYXkgaW4gb25lIHNlY29uZC5cXG4gICAqL1xcbiAga29udHJhLmFuaW1hdGlvbiA9IGZ1bmN0aW9uKHByb3BlcnRpZXMpIHtcXG4gICAgcmV0dXJuIG5ldyBBbmltYXRpb24ocHJvcGVydGllcyk7XFxuICB9O1xcbiAga29udHJhLmFuaW1hdGlvbi5wcm90b3R5cGUgPSBBbmltYXRpb24ucHJvdG90eXBlO1xcblxcblxcblxcblxcblxcbiAgY2xhc3MgU3ByaXRlU2hlZXQge1xcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZSBwcm9wZXJ0aWVzIG9uIHRoZSBzcHJpdGVTaGVldC5cXG4gICAgICogQG1lbWJlcm9mIGtvbnRyYVxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcGVydGllcyAtIFByb3BlcnRpZXMgb2YgdGhlIHNwcml0ZSBzaGVldC5cXG4gICAgICogQHBhcmFtIHtJbWFnZXxDYW52YXN9IHByb3BlcnRpZXMuaW1hZ2UgLSBJbWFnZSBmb3IgdGhlIHNwcml0ZSBzaGVldC5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHByb3BlcnRpZXMuZnJhbWVXaWR0aCAtIFdpZHRoIChpbiBweCkgb2YgZWFjaCBmcmFtZS5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHByb3BlcnRpZXMuZnJhbWVIZWlnaHQgLSBIZWlnaHQgKGluIHB4KSBvZiBlYWNoIGZyYW1lLlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcHJvcGVydGllcy5mcmFtZU1hcmdpbiAtIE1hcmdpbiAoaW4gcHgpIGJldHdlZW4gZWFjaCBmcmFtZS5cXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXMuYW5pbWF0aW9ucyAtIEFuaW1hdGlvbnMgdG8gY3JlYXRlIGZyb20gdGhlIHNwcml0ZSBzaGVldC5cXG4gICAgICovXFxuICAgIGNvbnN0cnVjdG9yKHByb3BlcnRpZXMpIHtcXG4gICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcyB8fCB7fTtcXG5cXG4gICAgICAvLyBAaWYgREVCVUdcXG4gICAgICBpZiAoIXByb3BlcnRpZXMuaW1hZ2UpIHtcXG4gICAgICAgIHRocm93IEVycm9yKCdZb3UgbXVzdCBwcm92aWRlIGFuIEltYWdlIGZvciB0aGUgU3ByaXRlU2hlZXQnKTtcXG4gICAgICB9XFxuICAgICAgLy8gQGVuZGlmXFxuXFxuICAgICAgdGhpcy5hbmltYXRpb25zID0ge307XFxuICAgICAgdGhpcy5pbWFnZSA9IHByb3BlcnRpZXMuaW1hZ2U7XFxuICAgICAgdGhpcy5mcmFtZSA9IHtcXG4gICAgICAgIHdpZHRoOiBwcm9wZXJ0aWVzLmZyYW1lV2lkdGgsXFxuICAgICAgICBoZWlnaHQ6IHByb3BlcnRpZXMuZnJhbWVIZWlnaHQsXFxuICAgICAgICBtYXJnaW46IHByb3BlcnRpZXMuZnJhbWVNYXJnaW5cXG4gICAgICB9O1xcblxcbiAgICAgIC8vIGYgPSBmcmFtZXNQZXJSb3dcXG4gICAgICB0aGlzLl9mID0gcHJvcGVydGllcy5pbWFnZS53aWR0aCAvIHByb3BlcnRpZXMuZnJhbWVXaWR0aCB8IDA7XFxuXFxuICAgICAgdGhpcy5jcmVhdGVBbmltYXRpb25zKHByb3BlcnRpZXMuYW5pbWF0aW9ucyk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZSBhbmltYXRpb25zIGZyb20gdGhlIHNwcml0ZSBzaGVldC5cXG4gICAgICogQG1lbWJlcm9mIGtvbnRyYS5zcHJpdGVTaGVldFxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYW5pbWF0aW9ucyAtIExpc3Qgb2YgbmFtZWQgYW5pbWF0aW9ucyB0byBjcmVhdGUgZnJvbSB0aGUgSW1hZ2UuXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xudW1iZXJbXXxzdHJpbmdbXX0gYW5pbWF0aW9ucy5hbmltYXRpb25OYW1lLmZyYW1lcyAtIEEgc2luZ2xlIGZyYW1lIG9yIGxpc3Qgb2YgZnJhbWVzIGZvciB0aGlzIGFuaW1hdGlvbi5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuaW1hdGlvbnMuYW5pbWF0aW9uTmFtZS5mcmFtZVJhdGUgLSBOdW1iZXIgb2YgZnJhbWVzIHRvIGRpc3BsYXkgaW4gb25lIHNlY29uZC5cXG4gICAgICpcXG4gICAgICogQGV4YW1wbGVcXG4gICAgICogbGV0IHNoZWV0ID0ga29udHJhLnNwcml0ZVNoZWV0KHtpbWFnZTogaW1nLCBmcmFtZVdpZHRoOiAxNiwgZnJhbWVIZWlnaHQ6IDE2fSk7XFxuICAgICAqIHNoZWV0LmNyZWF0ZUFuaW1hdGlvbnMoe1xcbiAgICAgKiAgIGlkbGU6IHtcXG4gICAgICogICAgIGZyYW1lczogMSAgLy8gc2luZ2xlIGZyYW1lIGFuaW1hdGlvblxcbiAgICAgKiAgIH0sXFxuICAgICAqICAgd2Fsazoge1xcbiAgICAgKiAgICAgZnJhbWVzOiAnMi4uNicsICAvLyBhc2NlbmRpbmcgY29uc2VjdXRpdmUgZnJhbWUgYW5pbWF0aW9uIChmcmFtZXMgMi02LCBpbmNsdXNpdmUpXFxuICAgICAqICAgICBmcmFtZVJhdGU6IDRcXG4gICAgICogICB9LFxcbiAgICAgKiAgIG1vb25XYWxrOiB7XFxuICAgICAqICAgICBmcmFtZXM6ICc2Li4yJywgIC8vIGRlc2NlbmRpbmcgY29uc2VjdXRpdmUgZnJhbWUgYW5pbWF0aW9uXFxuICAgICAqICAgICBmcmFtZVJhdGU6IDRcXG4gICAgICogICB9LFxcbiAgICAgKiAgIGp1bXA6IHtcXG4gICAgICogICAgIGZyYW1lczogWzcsIDEyLCAyXSwgIC8vIG5vbi1jb25zZWN1dGl2ZSBmcmFtZSBhbmltYXRpb25cXG4gICAgICogICAgIGZyYW1lUmF0ZTogMyxcXG4gICAgICogICAgIGxvb3A6IGZhbHNlXFxuICAgICAqICAgfSxcXG4gICAgICogICBhdHRhY2s6IHtcXG4gICAgICogICAgIGZyYW1lczogWyc4Li4xMCcsIDEzLCAnMTAuLjgnXSwgIC8vIHlvdSBjYW4gYWxzbyBtaXggYW5kIG1hdGNoLCBpbiB0aGlzIGNhc2UgZnJhbWVzIFs4LDksMTAsMTMsMTAsOSw4XVxcbiAgICAgKiAgICAgZnJhbWVSYXRlOiAyLFxcbiAgICAgKiAgICAgbG9vcDogZmFsc2VcXG4gICAgICogICB9XFxuICAgICAqIH0pO1xcbiAgICAgKi9cXG4gICAgY3JlYXRlQW5pbWF0aW9ucyhhbmltYXRpb25zKSB7XFxuICAgICAgbGV0IGFuaW1hdGlvbiwgZnJhbWVzLCBmcmFtZVJhdGUsIHNlcXVlbmNlLCBuYW1lO1xcblxcbiAgICAgIGZvciAobmFtZSBpbiBhbmltYXRpb25zKSB7XFxuICAgICAgICBhbmltYXRpb24gPSBhbmltYXRpb25zW25hbWVdO1xcbiAgICAgICAgZnJhbWVzID0gYW5pbWF0aW9uLmZyYW1lcztcXG5cXG4gICAgICAgIC8vIGFycmF5IHRoYXQgaG9sZHMgdGhlIG9yZGVyIG9mIHRoZSBhbmltYXRpb25cXG4gICAgICAgIHNlcXVlbmNlID0gW107XFxuXFxuICAgICAgICAvLyBAaWYgREVCVUdcXG4gICAgICAgIGlmIChmcmFtZXMgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICB0aHJvdyBFcnJvcignQW5pbWF0aW9uICcgKyBuYW1lICsgJyBtdXN0IHByb3ZpZGUgYSBmcmFtZXMgcHJvcGVydHknKTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIEBlbmRpZlxcblxcbiAgICAgICAgLy8gYWRkIG5ldyBmcmFtZXMgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXlcXG4gICAgICAgIFtdLmNvbmNhdChmcmFtZXMpLm1hcChmdW5jdGlvbihmcmFtZSkge1xcbiAgICAgICAgICBzZXF1ZW5jZSA9IHNlcXVlbmNlLmNvbmNhdCh0aGlzLl9wKGZyYW1lKSk7XFxuICAgICAgICB9LCB0aGlzKTtcXG5cXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uc1tuYW1lXSA9IGtvbnRyYS5hbmltYXRpb24oe1xcbiAgICAgICAgICBzcHJpdGVTaGVldDogdGhpcyxcXG4gICAgICAgICAgZnJhbWVzOiBzZXF1ZW5jZSxcXG4gICAgICAgICAgZnJhbWVSYXRlOiBhbmltYXRpb24uZnJhbWVSYXRlLFxcbiAgICAgICAgICBsb29wOiBhbmltYXRpb24ubG9vcFxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBQYXJzZSBhIHN0cmluZyBvZiBjb25zZWN1dGl2ZSBmcmFtZXMuXFxuICAgICAqIEBtZW1iZXJvZiBrb250cmEuc3ByaXRlU2hlZXRcXG4gICAgICogQHByaXZhdGVcXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBmcmFtZXMgLSBTdGFydCBhbmQgZW5kIGZyYW1lLlxcbiAgICAgKlxcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IExpc3Qgb2YgZnJhbWVzLlxcbiAgICAgKi9cXG4gICAgX3AoY29uc2VjdXRpdmVGcmFtZXMsIGkpIHtcXG4gICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qZWQvMTQwYnl0ZXMvd2lraS9CeXRlLXNhdmluZy10ZWNobmlxdWVzI2NvZXJjaW9uLXRvLXRlc3QtZm9yLXR5cGVzXFxuICAgICAgaWYgKCtjb25zZWN1dGl2ZUZyYW1lcyA9PT0gY29uc2VjdXRpdmVGcmFtZXMpIHtcXG4gICAgICAgIHJldHVybiBjb25zZWN1dGl2ZUZyYW1lcztcXG4gICAgICB9XFxuXFxuICAgICAgbGV0IHNlcXVlbmNlID0gW107XFxuICAgICAgbGV0IGZyYW1lcyA9IGNvbnNlY3V0aXZlRnJhbWVzLnNwbGl0KCcuLicpO1xcblxcbiAgICAgIC8vIGNvZXJjZSBzdHJpbmcgdG8gbnVtYmVyXFxuICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vamVkLzE0MGJ5dGVzL3dpa2kvQnl0ZS1zYXZpbmctdGVjaG5pcXVlcyNjb2VyY2lvbi10by10ZXN0LWZvci10eXBlc1xcbiAgICAgIGxldCBzdGFydCA9IGkgPSArZnJhbWVzWzBdO1xcbiAgICAgIGxldCBlbmQgPSArZnJhbWVzWzFdO1xcblxcbiAgICAgIC8vIGFzY2VuZGluZyBmcmFtZSBvcmRlclxcbiAgICAgIGlmIChzdGFydCA8IGVuZCkge1xcbiAgICAgICAgZm9yICg7IGkgPD0gZW5kOyBpKyspIHtcXG4gICAgICAgICAgc2VxdWVuY2UucHVzaChpKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgLy8gZGVzY2VuZGluZyBvcmRlclxcbiAgICAgIGVsc2Uge1xcbiAgICAgICAgZm9yICg7IGkgPj0gZW5kOyBpLS0pIHtcXG4gICAgICAgICAgc2VxdWVuY2UucHVzaChpKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHNlcXVlbmNlO1xcbiAgICB9XFxuICB9XFxuXFxuICAvKipcXG4gICAqIENyZWF0ZSBhIHNwcml0ZSBzaGVldCBmcm9tIGFuIGltYWdlLlxcbiAgICogQG1lbWJlcm9mIGtvbnRyYVxcbiAgICpcXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wZXJ0aWVzIC0gUHJvcGVydGllcyBvZiB0aGUgc3ByaXRlIHNoZWV0LlxcbiAgICogQHBhcmFtIHtJbWFnZXxDYW52YXN9IHByb3BlcnRpZXMuaW1hZ2UgLSBJbWFnZSBmb3IgdGhlIHNwcml0ZSBzaGVldC5cXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwcm9wZXJ0aWVzLmZyYW1lV2lkdGggLSBXaWR0aCAoaW4gcHgpIG9mIGVhY2ggZnJhbWUuXFxuICAgKiBAcGFyYW0ge251bWJlcn0gcHJvcGVydGllcy5mcmFtZUhlaWdodCAtIEhlaWdodCAoaW4gcHgpIG9mIGVhY2ggZnJhbWUuXFxuICAgKiBAcGFyYW0ge251bWJlcn0gcHJvcGVydGllcy5mcmFtZU1hcmdpbiAtIE1hcmdpbiAoaW4gcHgpIGJldHdlZW4gZWFjaCBmcmFtZS5cXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wZXJ0aWVzLmFuaW1hdGlvbnMgLSBBbmltYXRpb25zIHRvIGNyZWF0ZSBmcm9tIHRoZSBzcHJpdGUgc2hlZXQuXFxuICAgKi9cXG4gIGtvbnRyYS5zcHJpdGVTaGVldCA9IGZ1bmN0aW9uKHByb3BlcnRpZXMpIHtcXG4gICAgcmV0dXJuIG5ldyBTcHJpdGVTaGVldChwcm9wZXJ0aWVzKTtcXG4gIH07XFxuICBrb250cmEuc3ByaXRlU2hlZXQucHJvdG90eXBlID0gU3ByaXRlU2hlZXQucHJvdG90eXBlO1xcbn0pKCk7XFxuLyoqXFxuICogT2JqZWN0IGZvciB1c2luZyBsb2NhbFN0b3JhZ2UuXFxuICovXFxua29udHJhLnN0b3JlID0ge1xcblxcbiAgLyoqXFxuICAgKiBTYXZlIGFuIGl0ZW0gdG8gbG9jYWxTdG9yYWdlLlxcbiAgICogQG1lbWJlcm9mIGtvbnRyYS5zdG9yZVxcbiAgICpcXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBOYW1lIHRvIHN0b3JlIHRoZSBpdGVtIGFzLlxcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIEl0ZW0gdG8gc3RvcmUuXFxuICAgKi9cXG4gIHNldChrZXksIHZhbHVlKSB7XFxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcXG4gICAgfVxcbiAgICBlbHNlIHtcXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XFxuICAgIH1cXG4gIH0sXFxuXFxuICAvKipcXG4gICAqIFJldHJpZXZlIGFuIGl0ZW0gZnJvbSBsb2NhbFN0b3JhZ2UgYW5kIGNvbnZlcnQgaXQgYmFjayB0byBpdCdzIG9yaWdpbmFsIHR5cGUuXFxuICAgKiBAbWVtYmVyb2Yga29udHJhLnN0b3JlXFxuICAgKlxcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIE5hbWUgb2YgdGhlIGl0ZW0uXFxuICAgKlxcbiAgICogQHJldHVybnMgeyp9XFxuICAgKi9cXG4gIGdldChrZXkpIHtcXG4gICAgbGV0IHZhbHVlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcXG5cXG4gICAgdHJ5IHtcXG4gICAgICB2YWx1ZSA9IEpTT04ucGFyc2UodmFsdWUpO1xcbiAgICB9XFxuICAgIGNhdGNoKGUpIHt9XFxuXFxuICAgIHJldHVybiB2YWx1ZTtcXG4gIH1cXG59O1xcbihmdW5jdGlvbigpIHtcXG4gIC8vIHNhdmUgTWF0aC5taW4gYW5kIE1hdGgubWF4IHRvIHZhcmlhYmxlIGFuZCB1c2UgdGhhdCBpbnN0ZWFkXFxuXFxuICAvKipcXG4gICAqIEEgdGlsZSBlbmdpbmUgZm9yIHJlbmRlcmluZyB0aWxlc2V0cy4gV29ya3Mgd2VsbCB3aXRoIHRoZSB0aWxlIGVuZ2luZSBwcm9ncmFtIFRpbGVkLlxcbiAgICogQG1lbWJlcm9mIGtvbnRyYVxcbiAgICpcXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wZXJ0aWVzIC0gUHJvcGVydGllcyBvZiB0aGUgdGlsZSBlbmdpbmUuXFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3Byb3BlcnRpZXMudGlsZVdpZHRoPTMyXSAtIFdpZHRoIG9mIGEgdGlsZS5cXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJvcGVydGllcy50aWxlSGVpZ2h0PTMyXSAtIEhlaWdodCBvZiBhIHRpbGUuXFxuICAgKiBAcGFyYW0ge251bWJlcn0gcHJvcGVydGllcy53aWR0aCAtIFdpZHRoIG9mIHRoZSBtYXAgKGluIHRpbGVzKS5cXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwcm9wZXJ0aWVzLmhlaWdodCAtIEhlaWdodCBvZiB0aGUgbWFwIChpbiB0aWxlcykuXFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3Byb3BlcnRpZXMueD0wXSAtIFggcG9zaXRpb24gdG8gZHJhdy5cXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJvcGVydGllcy55PTBdIC0gWSBwb3NpdGlvbiB0byBkcmF3LlxcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwcm9wZXJ0aWVzLnN4PTBdIC0gWCBwb3NpdGlvbiB0byBjbGlwIHRoZSB0aWxlc2V0LlxcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwcm9wZXJ0aWVzLnN5PTBdIC0gWSBwb3NpdGlvbiB0byBjbGlwIHRoZSB0aWxlc2V0LlxcbiAgICogQHBhcmFtIHtDb250ZXh0fSBbcHJvcGVydGllcy5jb250ZXh0PWtvbnRyYS5jb250ZXh0XSAtIFByb3ZpZGUgYSBjb250ZXh0IGZvciB0aGUgdGlsZSBlbmdpbmUgdG8gZHJhdyBvbi5cXG4gICAqL1xcbiAga29udHJhLnRpbGVFbmdpbmUgPSBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XFxuICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IHt9O1xcblxcbiAgICAvLyBzaXplIG9mIHRoZSBtYXAgKGluIHRpbGVzKVxcbiAgICAvLyBAaWYgREVCVUdcXG4gICAgaWYgKCFwcm9wZXJ0aWVzLndpZHRoIHx8ICFwcm9wZXJ0aWVzLmhlaWdodCkge1xcbiAgICAgIHRocm93IEVycm9yKCdZb3UgbXVzdCBwcm92aWRlIHdpZHRoIGFuZCBoZWlnaHQgcHJvcGVydGllcycpO1xcbiAgICB9XFxuICAgIC8vIEBlbmRpZlxcblxcbiAgICAvKipcXG4gICAgICogR2V0IHRoZSBpbmRleCBvZiB0aGUgeCwgeSBvciByb3csIGNvbC5cXG4gICAgICogQG1lbWJlcm9mIGtvbnRyYS50aWxlRW5naW5lXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbi54IC0gWCBjb29yZGluYXRlIG9mIHRoZSB0aWxlLlxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24ueSAtIFkgY29vcmRpbmF0ZSBvZiB0aGUgdGlsZS5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uLnJvdyAtIFJvdyBvZiB0aGUgdGlsZS5cXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uLmNvbCAtIENvbCBvZiB0aGUgdGlsZS5cXG4gICAgICpcXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aWxlIGluZGV4IG9yIC0xIGlmIHRoZSB4LCB5IG9yIHJvdywgY29sIGlzIG91dHNpZGUgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHRpbGUgZW5naW5lLlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gZ2V0SW5kZXgocG9zaXRpb24pIHtcXG4gICAgICBsZXQgcm93LCBjb2w7XFxuXFxuICAgICAgaWYgKHR5cGVvZiBwb3NpdGlvbi54ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcG9zaXRpb24ueSAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIHJvdyA9IHRpbGVFbmdpbmUuZ2V0Um93KHBvc2l0aW9uLnkpO1xcbiAgICAgICAgY29sID0gdGlsZUVuZ2luZS5nZXRDb2wocG9zaXRpb24ueCk7XFxuICAgICAgfVxcbiAgICAgIGVsc2Uge1xcbiAgICAgICAgcm93ID0gcG9zaXRpb24ucm93O1xcbiAgICAgICAgY29sID0gcG9zaXRpb24uY29sO1xcbiAgICAgIH1cXG5cXG4gICAgICAvLyBkb24ndCBjYWxjdWxhdGUgb3V0IG9mIGJvdW5kIG51bWJlcnNcXG4gICAgICBpZiAocm93IDwgMCB8fCBjb2wgPCAwIHx8IHJvdyA+PSBoZWlnaHQgfHwgY29sID49IHdpZHRoKSB7XFxuICAgICAgICByZXR1cm4gLTE7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBjb2wgKyByb3cgKiB3aWR0aDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogTW9kaWZpZWQgYmluYXJ5IHNlYXJjaCB0aGF0IHdpbGwgcmV0dXJuIHRoZSB0aWxlc2V0IGFzc29jaWF0ZWQgd2l0aCB0aGUgdGlsZVxcbiAgICAgKiBAbWVtYmVyb2Yga29udHJhLnRpbGVFbmdpbmVcXG4gICAgICogQHByaXZhdGVcXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbGUgLSBUaWxlIGdyaWQuXFxuICAgICAqXFxuICAgICAqIEByZXR1cm4ge29iamVjdH1cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGdldFRpbGVzZXQodGlsZSkge1xcbiAgICAgIGxldCBtaW4gPSAwO1xcbiAgICAgIGxldCBtYXggPSB0aWxlRW5naW5lLnRpbGVzZXRzLmxlbmd0aCAtIDE7XFxuICAgICAgbGV0IGluZGV4LCBjdXJyVGlsZTtcXG5cXG4gICAgICB3aGlsZSAobWluIDw9IG1heCkge1xcbiAgICAgICAgaW5kZXggPSAobWluICsgbWF4KSAvIDIgfCAwO1xcbiAgICAgICAgY3VyclRpbGUgPSB0aWxlRW5naW5lLnRpbGVzZXRzW2luZGV4XTtcXG5cXG4gICAgICAgIGlmICh0aWxlID49IGN1cnJUaWxlLmZpcnN0R3JpZCAmJiB0aWxlIDw9IGN1cnJUaWxlLmxhc3RHcmlkKSB7XFxuICAgICAgICAgIHJldHVybiBjdXJyVGlsZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKGN1cnJUaWxlLmxhc3RHcmlkIDwgdGlsZSkge1xcbiAgICAgICAgICBtaW4gPSBpbmRleCArIDE7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgbWF4ID0gaW5kZXggLSAxO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogUHJlLXJlbmRlciB0aGUgdGlsZXMgdG8gbWFrZSBkcmF3aW5nIGZhc3QuXFxuICAgICAqIEBtZW1iZXJvZiBrb250cmEudGlsZUVuZ2luZVxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gcHJlUmVuZGVySW1hZ2UoKSB7XFxuICAgICAgbGV0IHRpbGUsIHRpbGVzZXQsIGltYWdlLCB4LCB5LCBzeCwgc3ksIHRpbGVPZmZzZXQsIHc7XFxuXFxuICAgICAgLy8gZHJhdyBlYWNoIGxheWVyIGluIG9yZGVyXFxuICAgICAgZm9yIChsZXQgaSA9IDAsIGxheWVyOyBsYXllciA9IHRpbGVFbmdpbmUubGF5ZXJzW2xheWVyT3JkZXJbaV1dOyBpKyspIHtcXG4gICAgICAgIGZvciAobGV0IGogPSAwLCBsZW4gPSBsYXllci5kYXRhLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XFxuICAgICAgICAgIHRpbGUgPSBsYXllci5kYXRhW2pdO1xcblxcbiAgICAgICAgICAvLyBza2lwIGVtcHR5IHRpbGVzICgwKVxcbiAgICAgICAgICBpZiAoIXRpbGUpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0aWxlc2V0ID0gZ2V0VGlsZXNldCh0aWxlKTtcXG4gICAgICAgICAgaW1hZ2UgPSB0aWxlc2V0LmltYWdlO1xcblxcbiAgICAgICAgICB4ID0gKGogJSB3aWR0aCkgKiB0aWxlV2lkdGg7XFxuICAgICAgICAgIHkgPSAoaiAvIHdpZHRoIHwgMCkgKiB0aWxlSGVpZ2h0O1xcblxcbiAgICAgICAgICB0aWxlT2Zmc2V0ID0gdGlsZSAtIHRpbGVzZXQuZmlyc3RHcmlkO1xcbiAgICAgICAgICB3ID0gaW1hZ2Uud2lkdGggLyB0aWxlV2lkdGg7XFxuXFxuICAgICAgICAgIHN4ID0gKHRpbGVPZmZzZXQgJSB3KSAqIHRpbGVXaWR0aDtcXG4gICAgICAgICAgc3kgPSAodGlsZU9mZnNldCAvIHcgfCAwKSAqIHRpbGVIZWlnaHQ7XFxuXFxuICAgICAgICAgIG9mZnNjcmVlbkNvbnRleHQuZHJhd0ltYWdlKFxcbiAgICAgICAgICAgIGltYWdlLFxcbiAgICAgICAgICAgIHN4LCBzeSwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0LFxcbiAgICAgICAgICAgIHgsIHksIHRpbGVXaWR0aCwgdGlsZUhlaWdodFxcbiAgICAgICAgICApO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBsZXQgd2lkdGggPSBwcm9wZXJ0aWVzLndpZHRoO1xcbiAgICBsZXQgaGVpZ2h0ID0gcHJvcGVydGllcy5oZWlnaHQ7XFxuXFxuICAgIC8vIHNpemUgb2YgdGhlIHRpbGVzLiBNb3N0IGNvbW1vbiB0aWxlIHNpemUgb24gb3BlbmdhbWVhcnQub3JnIHNlZW1zIHRvIGJlIDMyeDMyLFxcbiAgICAvLyBmb2xsb3dlZCBieSAxNngxNlxcbiAgICAvLyBUaWxlZCBuYW1lcyB0aGUgcHJvcGVydHkgdGlsZXdpZHRoIGFuZCB0aWxlaGVpZ2h0XFxuICAgIGxldCB0aWxlV2lkdGggPSBwcm9wZXJ0aWVzLnRpbGVXaWR0aCB8fCBwcm9wZXJ0aWVzLnRpbGV3aWR0aCB8fCAzMjtcXG4gICAgbGV0IHRpbGVIZWlnaHQgPSBwcm9wZXJ0aWVzLnRpbGVIZWlnaHQgfHwgcHJvcGVydGllcy50aWxlaGVpZ2h0IHx8IDMyO1xcblxcbiAgICBsZXQgbWFwV2lkdGggPSB3aWR0aCAqIHRpbGVXaWR0aDtcXG4gICAgbGV0IG1hcEhlaWdodCA9IGhlaWdodCAqIHRpbGVIZWlnaHQ7XFxuXFxuICAgIGxldCBjb250ZXh0ID0gcHJvcGVydGllcy5jb250ZXh0IHx8IGtvbnRyYS5jb250ZXh0O1xcbiAgICBsZXQgY2FudmFzV2lkdGggPSBjb250ZXh0LmNhbnZhcy53aWR0aDtcXG4gICAgbGV0IGNhbnZhc0hlaWdodCA9IGNvbnRleHQuY2FudmFzLmhlaWdodDtcXG5cXG4gICAgLy8gY3JlYXRlIGFuIG9mZi1zY3JlZW4gY2FudmFzIGZvciBwcmUtcmVuZGVyaW5nIHRoZSBtYXBcXG4gICAgLy8gQHNlZSBodHRwOi8vanNwZXJmLmNvbS9yZW5kZXItdnMtcHJlcmVuZGVyXFxuICAgIGxldCBvZmZzY3JlZW5DYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcXG4gICAgbGV0IG9mZnNjcmVlbkNvbnRleHQgPSBvZmZzY3JlZW5DYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcXG5cXG4gICAgLy8gd2hlbiBjbGlwcGluZyBhbiBpbWFnZSwgc3ggYW5kIHN5IG11c3Qgd2l0aGluIHRoZSBpbWFnZSByZWdpb24sIG90aGVyd2lzZVxcbiAgICAvLyBGaXJlZm94IGFuZCBTYWZhcmkgd29uJ3QgZHJhdyBpdC5cXG4gICAgLy8gQHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE5MzM4MDMyL2NhbnZhcy1pbmRleHNpemVlcnJvci1pbmRleC1vci1zaXplLWlzLW5lZ2F0aXZlLW9yLWdyZWF0ZXItdGhhbi10aGUtYWxsb3dlZC1hXFxuICAgIGxldCBzeE1heCA9IE1hdGgubWF4KDAsIG1hcFdpZHRoIC0gY2FudmFzV2lkdGgpO1xcbiAgICBsZXQgc3lNYXggPSBNYXRoLm1heCgwLCBtYXBIZWlnaHQgLSBjYW52YXNIZWlnaHQpO1xcblxcbiAgICBsZXQgX3N4LCBfc3k7XFxuXFxuICAgIC8vIGRyYXcgb3JkZXIgb2YgbGF5ZXJzIChieSBuYW1lKVxcbiAgICBsZXQgbGF5ZXJPcmRlciA9IFtdO1xcblxcbiAgICBsZXQgdGlsZUVuZ2luZSA9IHtcXG4gICAgICB3aWR0aDogd2lkdGgsXFxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXFxuXFxuICAgICAgdGlsZVdpZHRoOiB0aWxlV2lkdGgsXFxuICAgICAgdGlsZUhlaWdodDogdGlsZUhlaWdodCxcXG5cXG4gICAgICBtYXBXaWR0aDogbWFwV2lkdGgsXFxuICAgICAgbWFwSGVpZ2h0OiBtYXBIZWlnaHQsXFxuXFxuICAgICAgY29udGV4dDogY29udGV4dCxcXG5cXG4gICAgICB4OiBwcm9wZXJ0aWVzLnggfHwgMCxcXG4gICAgICB5OiBwcm9wZXJ0aWVzLnkgfHwgMCxcXG5cXG4gICAgICB0aWxlc2V0czogW10sXFxuICAgICAgbGF5ZXJzOiB7fSxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBBZGQgYW4gdGlsZXNldCBmb3IgdGhlIHRpbGUgZW5naW5lIHRvIHVzZS5cXG4gICAgICAgKiBAbWVtYmVyb2Yga29udHJhLnRpbGVFbmdpbmVcXG4gICAgICAgKlxcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSB0aWxlc2V0IC0gUHJvcGVydGllcyBvZiB0aGUgaW1hZ2UgdG8gYWRkLlxcbiAgICAgICAqIEBwYXJhbSB7SW1hZ2V8Q2FudmFzfSB0aWxlc2V0LmltYWdlIC0gUGF0aCB0byB0aGUgaW1hZ2Ugb3IgSW1hZ2Ugb2JqZWN0LlxcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aWxlc2V0LmZpcnN0R3JpZCAtIFRoZSBmaXJzdCB0aWxlIGdyaWQgdG8gc3RhcnQgdGhlIGltYWdlLlxcbiAgICAgICAqL1xcbiAgICAgIGFkZFRpbGVzZXRzOiBmdW5jdGlvbiBhZGRUaWxlc2V0cyh0aWxlc2V0cykge1xcbiAgICAgICAgW10uY29uY2F0KHRpbGVzZXRzKS5tYXAoZnVuY3Rpb24odGlsZXNldCkge1xcbiAgICAgICAgICBsZXQgdGlsZXNldEltYWdlID0gdGlsZXNldC5pbWFnZTtcXG4gICAgICAgICAgbGV0IGltYWdlLCBmaXJzdEdyaWQsIG51bVRpbGVzLCBsYXN0VGlsZXNldCwgdGlsZXM7XFxuXFxuICAgICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2plZC8xNDBieXRlcy93aWtpL0J5dGUtc2F2aW5nLXRlY2huaXF1ZXMjY29lcmNpb24tdG8tdGVzdC1mb3ItdHlwZXNcXG4gICAgICAgICAgaWYgKCcnK3RpbGVzZXRJbWFnZSA9PT0gdGlsZXNldEltYWdlKSB7XFxuICAgICAgICAgICAgbGV0IGkgPSBJbmZpbml0eTtcXG5cXG4gICAgICAgICAgICB3aGlsZSAoaSA+PSAwKSB7XFxuICAgICAgICAgICAgICBpID0gdGlsZXNldEltYWdlLmxhc3RJbmRleE9mKCcvJywgaSk7XFxuICAgICAgICAgICAgICBsZXQgcGF0aCA9IChpIDwgMCA/IHRpbGVzZXRJbWFnZSA6IHRpbGVzZXRJbWFnZS5zdWJzdHIoaSkpO1xcblxcbiAgICAgICAgICAgICAgaWYgKGtvbnRyYS5hc3NldHMuaW1hZ2VzW3BhdGhdKSB7XFxuICAgICAgICAgICAgICAgIGltYWdlID0ga29udHJhLmFzc2V0cy5pbWFnZXNbcGF0aF07XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgaS0tO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICBpbWFnZSA9IHRpbGVzZXRJbWFnZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmaXJzdEdyaWQgPSB0aWxlc2V0LmZpcnN0R3JpZDtcXG5cXG4gICAgICAgICAgLy8gaWYgdGhlIHdpZHRoIG9yIGhlaWdodCBvZiB0aGUgcHJvdmlkZWQgaW1hZ2UgaXMgc21hbGxlciB0aGFuIHRoZSB0aWxlIHNpemUsXFxuICAgICAgICAgIC8vIGRlZmF1bHQgY2FsY3VsYXRpb24gdG8gMVxcbiAgICAgICAgICBudW1UaWxlcyA9ICggKGltYWdlLndpZHRoIC8gdGlsZVdpZHRoIHwgMCkgfHwgMSApICpcXG4gICAgICAgICAgICAgICAgICAgICAoIChpbWFnZS5oZWlnaHQgLyB0aWxlSGVpZ2h0IHwgMCkgfHwgMSApO1xcblxcbiAgICAgICAgICBpZiAoIWZpcnN0R3JpZCkge1xcbiAgICAgICAgICAgIC8vIG9ubHkgY2FsY3VsYXRlIHRoZSBmaXJzdCBncmlkIGlmIHRoZSB0aWxlIG1hcCBoYXMgYSB0aWxlc2V0IGFscmVhZHlcXG4gICAgICAgICAgICBpZiAodGlsZUVuZ2luZS50aWxlc2V0cy5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgICBsYXN0VGlsZXNldCA9IHRpbGVFbmdpbmUudGlsZXNldHNbdGlsZUVuZ2luZS50aWxlc2V0cy5sZW5ndGggLSAxXTtcXG4gICAgICAgICAgICAgIHRpbGVzID0gKGxhc3RUaWxlc2V0LmltYWdlLndpZHRoIC8gdGlsZVdpZHRoIHwgMCkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAobGFzdFRpbGVzZXQuaW1hZ2UuaGVpZ2h0IC8gdGlsZUhlaWdodCB8IDApO1xcblxcbiAgICAgICAgICAgICAgZmlyc3RHcmlkID0gbGFzdFRpbGVzZXQuZmlyc3RHcmlkICsgdGlsZXM7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSB0aGlzIGlzIHRoZSBmaXJzdCB0aWxlIGFkZGVkIHRvIHRoZSB0aWxlIG1hcFxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgZmlyc3RHcmlkID0gMTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGlsZUVuZ2luZS50aWxlc2V0cy5wdXNoKHtcXG4gICAgICAgICAgICBmaXJzdEdyaWQ6IGZpcnN0R3JpZCxcXG4gICAgICAgICAgICBsYXN0R3JpZDogZmlyc3RHcmlkICsgbnVtVGlsZXMgLSAxLFxcbiAgICAgICAgICAgIGltYWdlOiBpbWFnZVxcbiAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgLy8gc29ydCB0aGUgdGlsZSBtYXAgc28gd2UgY2FuIHBlcmZvcm0gYSBiaW5hcnkgc2VhcmNoIHdoZW4gZHJhd2luZ1xcbiAgICAgICAgICB0aWxlRW5naW5lLnRpbGVzZXRzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xcbiAgICAgICAgICAgIHJldHVybiBhLmZpcnN0R3JpZCAtIGIuZmlyc3RHcmlkO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0sXFxuXFxuICAgICAgLyoqXFxuICAgICAgICogQWRkIGEgbGF5ZXIgdG8gdGhlIHRpbGUgZW5naW5lLlxcbiAgICAgICAqIEBtZW1iZXJvZiBrb250cmEudGlsZUVuZ2luZVxcbiAgICAgICAqXFxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXMgLSBQcm9wZXJ0aWVzIG9mIHRoZSBsYXllciB0byBhZGQuXFxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnRpZXMubmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyLlxcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHByb3BlcnRpZXMuZGF0YSAtIFRpbGUgbGF5ZXIgZGF0YS5cXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wZXJ0aWVzLnJlbmRlcj10cnVlXSAtIElmIHRoZSBsYXllciBzaG91bGQgYmUgZHJhd24uXFxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcm9wZXJ0aWVzLnpJbmRleF0gLSBEcmF3IG9yZGVyIGZvciB0aWxlIGxheWVyLiBIaWdoZXN0IG51bWJlciBpcyBkcmF3biBsYXN0IChpLmUuIG9uIHRvcCBvZiBhbGwgb3RoZXIgbGF5ZXJzKS5cXG4gICAgICAgKi9cXG4gICAgICBhZGRMYXllcnM6IGZ1bmN0aW9uIGFkZExheWVycyhsYXllcnMpIHtcXG4gICAgICAgIFtdLmNvbmNhdChsYXllcnMpLm1hcChmdW5jdGlvbihsYXllcikge1xcbiAgICAgICAgICBsYXllci5yZW5kZXIgPSAobGF5ZXIucmVuZGVyID09PSB1bmRlZmluZWQgPyB0cnVlIDogbGF5ZXIucmVuZGVyKTtcXG5cXG4gICAgICAgICAgbGV0IGRhdGEsIHIsIHJvdywgYywgcHJvcCwgdmFsdWU7XFxuXFxuICAgICAgICAgIC8vIGZsYXR0ZW4gYSAyRCBhcnJheSBpbnRvIGEgc2luZ2xlIGFycmF5XFxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxheWVyLmRhdGFbMF0pKSB7XFxuICAgICAgICAgICAgZGF0YSA9IFtdO1xcblxcbiAgICAgICAgICAgIGZvciAociA9IDA7IHJvdyA9IGxheWVyLmRhdGFbcl07IHIrKykge1xcbiAgICAgICAgICAgICAgZm9yIChjID0gMDsgYyA8IHdpZHRoOyBjKyspIHtcXG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKHJvd1tjXSB8fCAwKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgZGF0YSA9IGxheWVyLmRhdGE7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGlsZUVuZ2luZS5sYXllcnNbbGF5ZXIubmFtZV0gPSB7XFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcXG4gICAgICAgICAgICB6SW5kZXg6IGxheWVyLnpJbmRleCB8fCAwLFxcbiAgICAgICAgICAgIHJlbmRlcjogbGF5ZXIucmVuZGVyXFxuICAgICAgICAgIH07XFxuXFxuICAgICAgICAgIC8vIG1lcmdlIHByb3BlcnRpZXMgb2YgbGF5ZXIgb250byBsYXllciBvYmplY3RcXG4gICAgICAgICAgZm9yIChwcm9wIGluIGxheWVyLnByb3BlcnRpZXMpIHtcXG4gICAgICAgICAgICB2YWx1ZSA9IGxheWVyLnByb3BlcnRpZXNbcHJvcF07XFxuXFxuICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgIHZhbHVlID0gSlNPTi5wYXJzZSh2YWx1ZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGNhdGNoKGUpIHt9XFxuXFxuICAgICAgICAgICAgdGlsZUVuZ2luZS5sYXllcnNbbGF5ZXIubmFtZV1bcHJvcF0gPSB2YWx1ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICAvLyBvbmx5IGFkZCB0aGUgbGF5ZXIgdG8gdGhlIGxheWVyIG9yZGVyIGlmIGl0IHNob3VsZCBiZSBkcmF3blxcbiAgICAgICAgICBpZiAodGlsZUVuZ2luZS5sYXllcnNbbGF5ZXIubmFtZV0ucmVuZGVyKSB7XFxuICAgICAgICAgICAgbGF5ZXJPcmRlci5wdXNoKGxheWVyLm5hbWUpO1xcblxcbiAgICAgICAgICAgIGxheWVyT3JkZXIuc29ydChmdW5jdGlvbihhLCBiKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gdGlsZUVuZ2luZS5sYXllcnNbYV0uekluZGV4IC0gdGlsZUVuZ2luZS5sYXllcnNbYl0uekluZGV4O1xcbiAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIHByZVJlbmRlckltYWdlKCk7XFxuICAgICAgfSxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBTaW1wbGUgYm91bmRpbmcgYm94IGNvbGxpc2lvbiB0ZXN0IGZvciBsYXllciB0aWxlcy5cXG4gICAgICAgKiBAbWVtYmVyb2Yga29udHJhLnRpbGVFbmdpbmVcXG4gICAgICAgKlxcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIuXFxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCAtIE9iamVjdCB0byBjaGVjayBjb2xsaXNpb24gYWdhaW5zdC5cXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2JqZWN0LnggLSBYIGNvb3JkaW5hdGUgb2YgdGhlIG9iamVjdC5cXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2JqZWN0LnkgLSBZIGNvb3JkaW5hdGUgb2YgdGhlIG9iamVjdC5cXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2JqZWN0LndpZHRoIC0gV2lkdGggb2YgdGhlIG9iamVjdC5cXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2JqZWN0LmhlaWdodCAtIEhlaWdodCBvZiB0aGUgb2JqZWN0LlxcbiAgICAgICAqXFxuICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIG9iamVjdCBjb2xsaWRlcyB3aXRoIGEgdGlsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxcbiAgICAgICAqL1xcbiAgICAgIGxheWVyQ29sbGlkZXNXaXRoOiBmdW5jdGlvbiBsYXllckNvbGxpZGVzV2l0aChuYW1lLCBvYmplY3QpIHtcXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBhbGwgdGlsZXMgdGhhdCB0aGUgb2JqZWN0IGNhbiBjb2xsaWRlIHdpdGhcXG4gICAgICAgIGxldCByb3cgPSB0aWxlRW5naW5lLmdldFJvdyhvYmplY3QueSk7XFxuICAgICAgICBsZXQgY29sID0gdGlsZUVuZ2luZS5nZXRDb2wob2JqZWN0LngpO1xcblxcbiAgICAgICAgbGV0IGVuZFJvdyA9IHRpbGVFbmdpbmUuZ2V0Um93KG9iamVjdC55ICsgb2JqZWN0LmhlaWdodCk7XFxuICAgICAgICBsZXQgZW5kQ29sID0gdGlsZUVuZ2luZS5nZXRDb2wob2JqZWN0LnggKyBvYmplY3Qud2lkdGgpO1xcblxcbiAgICAgICAgLy8gY2hlY2sgYWxsIHRpbGVzXFxuICAgICAgICBsZXQgaW5kZXg7XFxuICAgICAgICBmb3IgKGxldCByID0gcm93OyByIDw9IGVuZFJvdzsgcisrKSB7XFxuICAgICAgICAgIGZvciAobGV0IGMgPSBjb2w7IGMgPD0gZW5kQ29sOyBjKyspIHtcXG4gICAgICAgICAgICBpbmRleCA9IGdldEluZGV4KHtyb3c6IHIsIGNvbDogY30pO1xcblxcbiAgICAgICAgICAgIGlmICh0aWxlRW5naW5lLmxheWVyc1tuYW1lXS5kYXRhW2luZGV4XSkge1xcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfSxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBHZXQgdGhlIHRpbGUgZnJvbSB0aGUgc3BlY2lmaWVkIGxheWVyIGF0IHgsIHkgb3Igcm93LCBjb2wuXFxuICAgICAgICogQG1lbWJlcm9mIGtvbnRyYS50aWxlRW5naW5lXFxuICAgICAgICpcXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyLlxcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwb3NpdGlvbiAtIFBvc2l0aW9uIG9mIHRoZSB0aWxlIGluIGVpdGhlciB4LCB5IG9yIHJvdywgY29sLlxcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbi54IC0gWCBjb29yZGluYXRlIG9mIHRoZSB0aWxlLlxcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbi55IC0gWSBjb29yZGluYXRlIG9mIHRoZSB0aWxlLlxcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbi5yb3cgLSBSb3cgb2YgdGhlIHRpbGUuXFxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uLmNvbCAtIENvbCBvZiB0aGUgdGlsZS5cXG4gICAgICAgKlxcbiAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XFxuICAgICAgICovXFxuICAgICAgdGlsZUF0TGF5ZXI6IGZ1bmN0aW9uIHRpbGVBdExheWVyKG5hbWUsIHBvc2l0aW9uKSB7XFxuICAgICAgICBsZXQgaW5kZXggPSBnZXRJbmRleChwb3NpdGlvbik7XFxuXFxuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xcbiAgICAgICAgICByZXR1cm4gdGlsZUVuZ2luZS5sYXllcnNbbmFtZV0uZGF0YVtpbmRleF07XFxuICAgICAgICB9XFxuICAgICAgfSxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBSZW5kZXIgdGhlIHByZS1yZW5kZXJlZCBjYW52YXMuXFxuICAgICAgICogQG1lbWJlcm9mIGtvbnRyYS50aWxlRW5naW5lXFxuICAgICAgICovXFxuICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xcbiAgICAgICAgdGlsZUVuZ2luZS5jb250ZXh0LmRyYXdJbWFnZShcXG4gICAgICAgICAgb2Zmc2NyZWVuQ2FudmFzLFxcbiAgICAgICAgICB0aWxlRW5naW5lLnN4LCB0aWxlRW5naW5lLnN5LCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0LFxcbiAgICAgICAgICB0aWxlRW5naW5lLngsIHRpbGVFbmdpbmUueSwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodFxcbiAgICAgICAgKTtcXG4gICAgICB9LFxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIFJlbmRlciBhIHNwZWNpZmljIGxheWVyLlxcbiAgICAgICAqIEBtZW1iZXJvZiBrb250cmEudGlsZUVuZ2luZVxcbiAgICAgICAqXFxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0byByZW5kZXIuXFxuICAgICAgICovXFxuICAgICAgcmVuZGVyTGF5ZXI6IGZ1bmN0aW9uIHJlbmRlckxheWVyKG5hbWUpIHtcXG4gICAgICAgIGxldCBsYXllciA9IHRpbGVFbmdpbmUubGF5ZXJzW25hbWVdO1xcblxcbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBzdGFydGluZyB0aWxlXFxuICAgICAgICBsZXQgcm93ID0gdGlsZUVuZ2luZS5nZXRSb3coKTtcXG4gICAgICAgIGxldCBjb2wgPSB0aWxlRW5naW5lLmdldENvbCgpO1xcbiAgICAgICAgbGV0IGluZGV4ID0gZ2V0SW5kZXgoe3Jvdzogcm93LCBjb2w6IGNvbH0pO1xcblxcbiAgICAgICAgLy8gY2FsY3VsYXRlIHdoZXJlIHRvIHN0YXJ0IGRyYXdpbmcgdGhlIHRpbGUgcmVsYXRpdmUgdG8gdGhlIGRyYXdpbmcgY2FudmFzXFxuICAgICAgICBsZXQgc3RhcnRYID0gY29sICogdGlsZVdpZHRoIC0gdGlsZUVuZ2luZS5zeDtcXG4gICAgICAgIGxldCBzdGFydFkgPSByb3cgKiB0aWxlSGVpZ2h0IC0gdGlsZUVuZ2luZS5zeTtcXG5cXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBob3cgbWFueSB0aWxlcyB0aGUgZHJhd2luZyBjYW52YXMgY2FuIGhvbGRcXG4gICAgICAgIGxldCB2aWV3V2lkdGggPSBNYXRoLm1pbihNYXRoLmNlaWwoY2FudmFzV2lkdGggLyB0aWxlV2lkdGgpICsgMSwgd2lkdGgpO1xcbiAgICAgICAgbGV0IHZpZXdIZWlnaHQgPSBNYXRoLm1pbihNYXRoLmNlaWwoY2FudmFzSGVpZ2h0IC8gdGlsZUhlaWdodCkgKyAxLCBoZWlnaHQpO1xcbiAgICAgICAgbGV0IG51bVRpbGVzID0gdmlld1dpZHRoICogdmlld0hlaWdodDtcXG5cXG4gICAgICAgIGxldCBjb3VudCA9IDA7XFxuICAgICAgICBsZXQgeCwgeSwgdGlsZSwgdGlsZXNldCwgaW1hZ2UsIHRpbGVPZmZzZXQsIHcsIHN4LCBzeTtcXG5cXG4gICAgICAgIC8vIGRyYXcganVzdCBlbm91Z2ggb2YgdGhlIGxheWVyIHRvIGZpdCBpbnNpZGUgdGhlIGRyYXdpbmcgY2FudmFzXFxuICAgICAgICB3aGlsZSAoY291bnQgPCBudW1UaWxlcykge1xcbiAgICAgICAgICB0aWxlID0gbGF5ZXIuZGF0YVtpbmRleF07XFxuXFxuICAgICAgICAgIGlmICh0aWxlKSB7XFxuICAgICAgICAgICAgdGlsZXNldCA9IGdldFRpbGVzZXQodGlsZSk7XFxuICAgICAgICAgICAgaW1hZ2UgPSB0aWxlc2V0LmltYWdlO1xcblxcbiAgICAgICAgICAgIHggPSBzdGFydFggKyAoY291bnQgJSB2aWV3V2lkdGgpICogdGlsZVdpZHRoO1xcbiAgICAgICAgICAgIHkgPSBzdGFydFkgKyAoY291bnQgLyB2aWV3V2lkdGggfCAwKSAqIHRpbGVIZWlnaHQ7XFxuXFxuICAgICAgICAgICAgdGlsZU9mZnNldCA9IHRpbGUgLSB0aWxlc2V0LmZpcnN0R3JpZDtcXG4gICAgICAgICAgICB3ID0gaW1hZ2Uud2lkdGggLyB0aWxlV2lkdGg7XFxuXFxuICAgICAgICAgICAgc3ggPSAodGlsZU9mZnNldCAlIHcpICogdGlsZVdpZHRoO1xcbiAgICAgICAgICAgIHN5ID0gKHRpbGVPZmZzZXQgLyB3IHwgMCkgKiB0aWxlSGVpZ2h0O1xcblxcbiAgICAgICAgICAgIHRpbGVFbmdpbmUuY29udGV4dC5kcmF3SW1hZ2UoXFxuICAgICAgICAgICAgICBpbWFnZSxcXG4gICAgICAgICAgICAgIHN4LCBzeSwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0LFxcbiAgICAgICAgICAgICAgeCwgeSwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0XFxuICAgICAgICAgICAgKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoKytjb3VudCAlIHZpZXdXaWR0aCA9PT0gMCkge1xcbiAgICAgICAgICAgIGluZGV4ID0gY29sICsgKCsrcm93ICogd2lkdGgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIGluZGV4Kys7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9LFxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIEdldCB0aGUgcm93IGZyb20gdGhlIHkgY29vcmRpbmF0ZS5cXG4gICAgICAgKiBAbWVtYmVyb2Yga29udHJhLnRpbGVFbmdpbmVcXG4gICAgICAgKlxcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gWSBjb29yZGluYXRlLlxcbiAgICAgICAqXFxuICAgICAgICogQHJldHVybiB7bnVtYmVyfVxcbiAgICAgICAqL1xcbiAgICAgIGdldFJvdzogZnVuY3Rpb24gZ2V0Um93KHkpIHtcXG4gICAgICAgIHkgPSB5IHx8IDA7XFxuXFxuICAgICAgICByZXR1cm4gKHRpbGVFbmdpbmUuc3kgKyB5KSAvIHRpbGVIZWlnaHQgfCAwO1xcbiAgICAgIH0sXFxuXFxuICAgICAgLyoqXFxuICAgICAgICogR2V0IHRoZSBjb2wgZnJvbSB0aGUgeCBjb29yZGluYXRlLlxcbiAgICAgICAqIEBtZW1iZXJvZiBrb250cmEudGlsZUVuZ2luZVxcbiAgICAgICAqXFxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBYIGNvb3JkaW5hdGUuXFxuICAgICAgICpcXG4gICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XFxuICAgICAgICovXFxuICAgICAgZ2V0Q29sOiBmdW5jdGlvbiBnZXRDb2woeCkge1xcbiAgICAgICAgeCA9IHggfHwgMDtcXG5cXG4gICAgICAgIHJldHVybiAodGlsZUVuZ2luZS5zeCArIHgpIC8gdGlsZVdpZHRoIHwgMDtcXG4gICAgICB9LFxcblxcbiAgICAgIGdldCBzeCgpIHtcXG4gICAgICAgIHJldHVybiBfc3g7XFxuICAgICAgfSxcXG5cXG4gICAgICBnZXQgc3koKSB7XFxuICAgICAgICByZXR1cm4gX3N5O1xcbiAgICAgIH0sXFxuXFxuICAgICAgLy8gZW5zdXJlIHN4IGFuZCBzeSBhcmUgd2l0aGluIHRoZSBpbWFnZSByZWdpb25cXG4gICAgICBzZXQgc3godmFsdWUpIHtcXG4gICAgICAgIF9zeCA9IE1hdGgubWluKCBNYXRoLm1heCgwLCB2YWx1ZSksIHN4TWF4ICk7XFxuICAgICAgfSxcXG5cXG4gICAgICBzZXQgc3kodmFsdWUpIHtcXG4gICAgICAgIF9zeSA9IE1hdGgubWluKCBNYXRoLm1heCgwLCB2YWx1ZSksIHN5TWF4ICk7XFxuICAgICAgfSxcXG5cXG4gICAgICAvLyBleHBvc2UgcHJvcGVydGllcyBmb3IgdGVzdGluZ1xcbiAgICAgIC8vIEBpZiBERUJVR1xcbiAgICAgIF9sYXllck9yZGVyOiBsYXllck9yZGVyXFxuICAgICAgLy8gQGVuZGlmXFxuICAgIH07XFxuXFxuICAgIC8vIHNldCBoZXJlIHNvIHdlIHVzZSBzZXR0ZXIgZnVuY3Rpb25cXG4gICAgdGlsZUVuZ2luZS5zeCA9IHByb3BlcnRpZXMuc3ggfHwgMDtcXG4gICAgdGlsZUVuZ2luZS5zeSA9IHByb3BlcnRpZXMuc3kgfHwgMDtcXG5cXG4gICAgLy8gbWFrZSB0aGUgb2ZmLXNjcmVlbiBjYW52YXMgdGhlIGZ1bGwgc2l6ZSBvZiB0aGUgbWFwXFxuICAgIG9mZnNjcmVlbkNhbnZhcy53aWR0aCA9IG1hcFdpZHRoO1xcbiAgICBvZmZzY3JlZW5DYW52YXMuaGVpZ2h0ID0gbWFwSGVpZ2h0O1xcblxcbiAgICAvLyBtZXJnZSBwcm9wZXJ0aWVzIG9mIHRoZSB0aWxlIGVuZ2luZSBvbnRvIHRoZSB0aWxlIGVuZ2luZSBpdHNlbGZcXG4gICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wZXJ0aWVzLnByb3BlcnRpZXMpIHtcXG4gICAgICBsZXQgdmFsdWUgPSBwcm9wZXJ0aWVzLnByb3BlcnRpZXNbcHJvcF07XFxuXFxuICAgICAgdHJ5IHtcXG4gICAgICAgIHZhbHVlID0gSlNPTi5wYXJzZSh2YWx1ZSk7XFxuICAgICAgfVxcbiAgICAgIGNhdGNoKGUpIHt9XFxuXFxuICAgICAgLy8gcGFzc2VkIGluIHByb3BlcnRpZXMgb3ZlcnJpZGUgcHJvcGVydGllcy5wcm9wZXJ0aWVzXFxuICAgICAgdGlsZUVuZ2luZVtwcm9wXSA9IHRpbGVFbmdpbmVbcHJvcF0gfHwgdmFsdWU7XFxuICAgIH1cXG5cXG4gICAgaWYgKHByb3BlcnRpZXMudGlsZXNldHMpIHtcXG4gICAgICB0aWxlRW5naW5lLmFkZFRpbGVzZXRzKHByb3BlcnRpZXMudGlsZXNldHMpO1xcbiAgICB9XFxuXFxuICAgIGlmIChwcm9wZXJ0aWVzLmxheWVycykge1xcbiAgICAgIHRpbGVFbmdpbmUuYWRkTGF5ZXJzKHByb3BlcnRpZXMubGF5ZXJzKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gdGlsZUVuZ2luZTtcXG4gIH07XFxufSkoKTtcIiIsIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3N0eWxlcy5jc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc3R5bGVzLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc3R5bGVzLmNzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiYm9keSB7XFxuICBiYWNrZ3JvdW5kOiBibGFjaztcXG59XFxuY2FudmFzIHtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIHdoaXRlO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG4iLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG4iLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCwgcGFyZW50KSB7XG4gIGlmIChwYXJlbnQpe1xuICAgIHJldHVybiBwYXJlbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuICB9XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG59O1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBwYXNzaW5nIGZ1bmN0aW9uIGluIG9wdGlvbnMsIHRoZW4gdXNlIGl0IGZvciByZXNvbHZlIFwiaGVhZFwiIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gVXNlZnVsIGZvciBTaGFkb3cgUm9vdCBzdHlsZSBpLmVcbiAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAgICAgLy8gICBpbnNlcnRJbnRvOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Zvb1wiKS5zaGFkb3dSb290IH1cbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdHZhciBzdHlsZVRhcmdldCA9IGdldFRhcmdldC5jYWxsKHRoaXMsIHRhcmdldCwgcGFyZW50KTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cdFx0XHRpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBtZW1vW3RhcmdldF1cblx0fTtcbn0pKCk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG4gICAgICAgIGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmluc2VydEF0LmJlZm9yZSkge1xuXHRcdHZhciBuZXh0U2libGluZyA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUsIHRhcmdldCk7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dFNpYmxpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIltTdHlsZSBMb2FkZXJdXFxuXFxuIEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnICgnb3B0aW9ucy5pbnNlcnRBdCcpIGZvdW5kLlxcbiBNdXN0IGJlICd0b3AnLCAnYm90dG9tJywgb3IgT2JqZWN0LlxcbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXFxuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cblx0aWYob3B0aW9ucy5hdHRycy5ub25jZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dmFyIG5vbmNlID0gZ2V0Tm9uY2UoKTtcblx0XHRpZiAobm9uY2UpIHtcblx0XHRcdG9wdGlvbnMuYXR0cnMubm9uY2UgPSBub25jZTtcblx0XHR9XG5cdH1cblxuXHRhZGRBdHRycyhzdHlsZSwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZSk7XG5cblx0cmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBnZXROb25jZSgpIHtcblx0aWYgKHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHJldHVybiBfX3dlYnBhY2tfbm9uY2VfXztcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cbiIsIlxuLyoqXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFwiZml4ZXNcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgfVxuXG5cdC8vIGJsYW5rIG9yIG51bGw/XG5cdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFwic3RyaW5nXCIpIHtcblx0ICByZXR1cm4gY3NzO1xuICB9XG5cbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxuXHQvKlxuXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxuXHRhIHN0cmluZy5cblxuXHQgL3VybFxccypcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXCJ1cmxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcblxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqL1xuXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcblxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvfFxccyokKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xuXHRcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxuXHRcdHZhciBuZXdVcmw7XG5cblx0XHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XG5cdFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnlcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcblx0XHR9XG5cblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXG5cdFx0cmV0dXJuIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFwiKVwiO1xuXHR9KTtcblxuXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xuXHRyZXR1cm4gZml4ZWRDc3M7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==