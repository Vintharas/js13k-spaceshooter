!function(e){var n={};function t(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,t),i.l=!0,i.exports}t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var i in e)t.d(r,i,function(n){return e[n]}.bind(null,i));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=0)}([function(e,n,t){"use strict";t.r(n);t(1),t(4);document.body.appendChild(function(){let e=document.createElement("div");return e.innerHTML="Hello webpack",e}()),kontra.init();let r=[];function i(e){return e*Math.PI/180}let o=kontra.sprite({type:"ship",x:300,y:300,width:6,rotation:0,dt:0,ttl:1/0,render(){this.context.save(),this.context.translate(this.x,this.y),this.context.rotate(i(this.rotation)),this.context.beginPath(),this.context.moveTo(-3,-5),this.context.lineTo(12,0),this.context.lineTo(-3,5),this.context.closePath(),this.context.stroke(),this.context.restore()},update(){kontra.keys.pressed("left")?this.rotation+=-4:kontra.keys.pressed("right")&&(this.rotation+=4);const e=Math.cos(i(this.rotation)),n=Math.sin(i(this.rotation));if(kontra.keys.pressed("up")?(this.ddx=.1*e,this.ddy=.1*n):this.ddx=this.ddy=0,this.advance(),Math.sqrt(this.dx*this.dx+this.dy*this.dy)>10&&(this.dx*=.95,this.dy*=.95),this.dt+=1/60,kontra.keys.pressed("space")&&this.dt>.25){this.dt=0;let t=kontra.sprite({type:"bullet",x:this.x+12*e,y:this.y+12*n,dx:this.dx+5*e,dy:this.dy+5*n,ttl:50,width:2,height:2,color:"white"});r.push(t)}}});function a(e,n,t){let i=kontra.sprite({type:"asteroid",x:e,y:n,radius:t,ttl:1/0,dx:4*Math.random()-2,dy:4*Math.random()-2,render(){this.context.strokeStyle="white",this.context.beginPath(),this.context.arc(this.x,this.y,this.radius,0,2*Math.PI),this.context.stroke()}});r.push(i)}r.push(o);for(var s=0;s<4;s++)a(100,100,30);kontra.gameLoop({update:function(){r.map(e=>{e.update(),e.x<0?e.x=kontra.canvas.width:e.x>kontra.canvas.width&&(e.x=0),e.y<0?e.y=kontra.canvas.height:e.y>kontra.canvas.height&&(e.y=0)});for(let n=0;n<r.length;n++)if("asteroid"===r[n].type)for(let t=n+1;t<r.length;t++)if("asteroid"!==r[t].type){let i=r[n],o=r[t],s=i.x-o.x,l=i.y-o.y;if(Math.sqrt(s*s+l*l)<i.radius+o.width){if(i.ttl=0,o.ttl=0,i.radius>10)for(var e=0;e<3;e++)a(i.x,i.y,i.radius/2.5);break}}r=r.filter(e=>e.isAlive())},render:function(){r.forEach(e=>e.render())}}).start()},function(e,n,t){t(2)(t(3))},function(e,n){e.exports=function(e){function n(e){"undefined"!=typeof console&&(console.error||console.log)("[Script Loader]",e)}try{"undefined"!=typeof execScript&&"undefined"!=typeof attachEvent&&"undefined"==typeof addEventListener?execScript(e):"undefined"!=typeof eval?eval.call(null,e):n("EvalError: No eval function available")}catch(e){n(e)}}},function(e,n){e.exports="this.kontra = {\n\n  /**\n   * Initialize the canvas.\n   * @memberof kontra\n   *\n   * @param {string|HTMLCanvasElement} canvas - Main canvas ID or Element for the game.\n   */\n  init(canvas) {\n\n    // check if canvas is a string first, an element next, or default to getting\n    // first canvas on page\n    var canvasEl = this.canvas = document.getElementById(canvas) ||\n                                 canvas ||\n                                 document.querySelector('canvas');\n\n    // @if DEBUG\n    if (!canvasEl) {\n      throw Error('You must provide a canvas element for the game');\n    }\n    // @endif\n\n    this.context = canvasEl.getContext('2d');\n  },\n\n  /**\n   * Noop function.\n   * @see https://stackoverflow.com/questions/21634886/what-is-the-javascript-convention-for-no-operation#comment61796464_33458430\n   * @memberof kontra\n   * @private\n   *\n   * The new operator is required when using sinon.stub to replace with the noop.\n   */\n  _noop: new Function,\n\n  /**\n   * Dispatch event to any part of the code that needs to know when\n   * a new frame has started. Will be filled out in pointer events.\n   * @memberOf kontra\n   * @private\n   */\n  _tick: new Function\n};\n(function() {\n  let imageRegex = /(jpeg|jpg|gif|png)$/;\n  let audioRegex = /(wav|mp3|ogg|aac)$/;\n  let noRegex = /^no$/;\n  let leadingSlash = /^\\//;\n  let trailingSlash = /\\/$/;\n  let assets;\n\n  // audio playability\n  // @see https://github.com/Modernizr/Modernizr/blob/master/feature-detects/audio.js\n  let audio = new Audio();\n  let canUse = {\n    wav: '',\n    mp3: audio.canPlayType('audio/mpeg;').replace(noRegex,''),\n    ogg: audio.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(noRegex,''),\n    aac: audio.canPlayType('audio/aac;').replace(noRegex,'')\n  };\n\n  /**\n   * Join a base path and asset path.\n   *\n   * @param {string} base - The asset base path.\n   * @param {string} url - The URL to the asset.\n   *\n   * @returns {string}\n   */\n  function joinPath(base, url) {\n    return [base.replace(trailingSlash, ''), base ? url.replace(leadingSlash, '') : url]\n      .filter(s => s)\n      .join('/')\n  }\n\n  /**\n   * Get the extension of an asset.\n   *\n   * @param {string} url - The URL to the asset.\n   *\n   * @returns {string}\n   */\n  function getExtension(url) {\n    return url.split('.').pop();\n  }\n\n  /**\n   * Get the name of an asset.\n   *\n   * @param {string} url - The URL to the asset.\n   *\n   * @returns {string}\n   */\n  function getName(url) {\n    let name = url.replace('.' + getExtension(url), '');\n\n    // remove leading slash if there is no folder in the path\n    // @see https://stackoverflow.com/a/50592629/2124254\n    return name.split('/').length == 2 ? name.replace(leadingSlash, '') : name;\n  }\n\n  /**\n   * Load an Image file. Uses imagePath to resolve URL.\n   * @memberOf kontra.assets\n   * @private\n   *\n   * @param {string} url - The URL to the Image file.\n   *\n   * @returns {Promise} A deferred promise. Promise resolves with the Image.\n   *\n   * @example\n   * kontra.loadImage('car.png');\n   * kontra.loadImage('autobots/truck.png');\n   */\n  function loadImage(originalUrl, url) {\n    return new Promise(function(resolve, reject) {\n      let image = new Image();\n      url = joinPath(assets.imagePath, originalUrl);\n\n      image.onload = function loadImageOnLoad() {\n        assets.images[ getName(originalUrl) ] = assets.images[url] = this;\n        resolve(this);\n      };\n\n      image.onerror = function loadImageOnError() {\n        reject(/* @if DEBUG */ 'Unable to load image ' + /* @endif */ url);\n      };\n\n      image.src = url;\n    });\n  }\n\n  /**\n   * Load an Audio file. Supports loading multiple audio formats which will be resolved by\n   * the browser in the order listed. Uses audioPath to resolve URL.\n   * @memberOf kontra.assets\n   * @private\n   *\n   * @param {string|string[]} url - The URL to the Audio file.\n   *\n   * @returns {Promise} A deferred promise. Promise resolves with the Audio.\n   *\n   * @example\n   * kontra.loadAudio('sound_effects/laser.mp3');\n   * kontra.loadAudio(['explosion.mp3', 'explosion.m4a', 'explosion.ogg']);\n   */\n  function loadAudio(originalUrl, url, undefined) {\n    return new Promise(function(resolve, reject) {\n\n      // determine which audio format the browser can play\n      originalUrl = [].concat(originalUrl).reduce(function(a, source) {\n        return canUse[ getExtension(source) ] ? source : a\n      }, undefined);\n\n      if (!originalUrl) {\n        reject(/* @if DEBUG */ 'cannot play any of the audio formats provided' + /* @endif */ originalUrl);\n      }\n      else {\n        let audio = new Audio();\n        url = joinPath(assets.audioPath, originalUrl);\n\n        audio.addEventListener('canplay', function loadAudioOnLoad() {\n          assets.audio[ getName(originalUrl) ] = assets.audio[url] = this;\n          resolve(this);\n        });\n\n        audio.onerror = function loadAudioOnError() {\n          reject(/* @if DEBUG */ 'Unable to load audio ' + /* @endif */ url);\n        };\n\n        audio.src = url;\n        audio.load();\n      }\n    });\n  }\n\n  /**\n   * Load a data file (be it text or JSON). Uses dataPath to resolve URL.\n   * @memberOf kontra.assets\n   * @private\n   *\n   * @param {string} url - The URL to the data file.\n   *\n   * @returns {Promise} A deferred promise. Resolves with the data or parsed JSON.\n   *\n   * @example\n   * kontra.loadData('bio.json');\n   * kontra.loadData('dialog.txt');\n   */\n  function loadData(originalUrl, url) {\n    url = joinPath(assets.dataPath, originalUrl);\n\n    return fetch(url).then(function(response) {\n      if (!response.ok) throw response;\n      return response.clone().json().catch(function() { return response.text() })\n    }).then(function(data) {\n      assets.data[ getName(originalUrl) ] = assets.data[url] = data;\n      return data;\n    });\n  }\n\n  /**\n   * Object for loading assets.\n   */\n  assets = kontra.assets = {\n    // all assets are stored by name as well as by URL\n    images: {},\n    audio: {},\n    data: {},\n\n    // base asset path for determining asset URLs\n    imagePath: '',\n    audioPath: '',\n    dataPath: '',\n\n    /**\n     * Load an Image, Audio, or data file.\n     * @memberOf kontra.assets\n     *\n     * @param {string|string[]} - Comma separated list of assets to load.\n     *\n     * @returns {Promise}\n     *\n     * @example\n     * kontra.loadAsset('car.png');\n     * kontra.loadAsset(['explosion.mp3', 'explosion.ogg']);\n     * kontra.loadAsset('bio.json');\n     * kontra.loadAsset('car.png', ['explosion.mp3', 'explosion.ogg'], 'bio.json');\n     */\n    load() {\n      let promises = [];\n      let url, extension, asset, i, promise;\n\n      for (i = 0; (asset = arguments[i]); i++) {\n        url = [].concat(asset)[0];\n\n        extension = getExtension(url);\n        if (extension.match(imageRegex)) {\n          promise = loadImage(asset);\n        }\n        else if (extension.match(audioRegex)) {\n          promise = loadAudio(asset);\n        }\n        else {\n          promise = loadData(asset);\n        }\n\n        promises.push(promise);\n      }\n\n      return Promise.all(promises);\n    },\n\n    // expose properties for testing\n    /* @if DEBUG */\n    _canUse: canUse\n    /* @endif */\n  };\n})();\n(function() {\n\n  /**\n   * Game loop that updates and renders the game every frame.\n   * @memberof kontra\n   *\n   * @param {object}   properties - Properties of the game loop.\n   * @param {number}   [properties.fps=60] - Desired frame rate.\n   * @param {boolean}  [properties.clearCanvas=true] - Clear the canvas every frame.\n   * @param {function} properties.update - Function called to update the game.\n   * @param {function} properties.render - Function called to render the game.\n   */\n  kontra.gameLoop = function(properties) {\n    properties = properties || {};\n\n    // check for required functions\n    // @if DEBUG\n    if ( !(properties.update && properties.render) ) {\n      throw Error('You must provide update() and render() functions');\n    }\n    // @endif\n\n    // animation variables\n    let fps = properties.fps || 60;\n    let accumulator = 0;\n    let delta = 1E3 / fps;  // delta between performance.now timings (in ms)\n    let step = 1 / fps;\n\n    let clear = (properties.clearCanvas === false ?\n                kontra._noop :\n                function clear() {\n                  kontra.context.clearRect(0,0,kontra.canvas.width,kontra.canvas.height);\n                });\n    let last, rAF, now, dt;\n\n    /**\n     * Called every frame of the game loop.\n     */\n    function frame() {\n      rAF = requestAnimationFrame(frame);\n\n      now = performance.now();\n      dt = now - last;\n      last = now;\n\n      // prevent updating the game with a very large dt if the game were to lose focus\n      // and then regain focus later\n      if (dt > 1E3) {\n        return;\n      }\n\n      kontra._tick();\n      accumulator += dt;\n\n      while (accumulator >= delta) {\n        gameLoop.update(step);\n\n        accumulator -= delta;\n      }\n\n      clear();\n      gameLoop.render();\n    }\n\n    // game loop object\n    let gameLoop = {\n      update: properties.update,\n      render: properties.render,\n      isStopped: true,\n\n      /**\n       * Start the game loop.\n       * @memberof kontra.gameLoop\n       */\n      start() {\n        last = performance.now();\n        this.isStopped = false;\n        requestAnimationFrame(frame);\n      },\n\n      /**\n       * Stop the game loop.\n       */\n      stop() {\n        this.isStopped = true;\n        cancelAnimationFrame(rAF);\n      },\n\n      // expose properties for testing\n      // @if DEBUG\n      _frame: frame,\n      set _last(value) {\n        last = value;\n      }\n      // @endif\n    };\n\n    return gameLoop;\n  };\n})();\n(function() {\n  let callbacks = {};\n  let pressedKeys = {};\n\n  let keyMap = {\n    // named keys\n    13: 'enter',\n    27: 'esc',\n    32: 'space',\n    37: 'left',\n    38: 'up',\n    39: 'right',\n    40: 'down'\n  };\n\n  // alpha keys\n  // @see https://stackoverflow.com/a/43095772/2124254\n  for (let i = 0; i < 26; i++) {\n    keyMap[65+i] = (10 + i).toString(36);\n  }\n  // numeric keys\n  for (i = 0; i < 10; i++) {\n    keyMap[48+i] = ''+i;\n  }\n\n  addEventListener('keydown', keydownEventHandler);\n  addEventListener('keyup', keyupEventHandler);\n  addEventListener('blur', blurEventHandler);\n\n  /**\n   * Execute a function that corresponds to a keyboard key.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function keydownEventHandler(e) {\n    let key = keyMap[e.which];\n    pressedKeys[key] = true;\n\n    if (callbacks[key]) {\n      callbacks[key](e);\n    }\n  }\n\n  /**\n   * Set the released key to not being pressed.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function keyupEventHandler(e) {\n    pressedKeys[ keyMap[e.which] ] = false;\n  }\n\n  /**\n   * Reset pressed keys.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function blurEventHandler(e) {\n    pressedKeys = {};\n  }\n\n  /**\n   * Object for using the keyboard.\n   */\n  kontra.keys = {\n    /**\n     * Register a function to be called on a key press.\n     * @memberof kontra.keys\n     *\n     * @param {string|string[]} keys - key or keys to bind.\n     */\n    bind(keys, callback) {\n      // smaller than doing `Array.isArray(keys) ? keys : [keys]`\n      [].concat(keys).map(function(key) {\n        callbacks[key] = callback;\n      })\n    },\n\n    /**\n     * Remove the callback function for a key.\n     * @memberof kontra.keys\n     *\n     * @param {string|string[]} keys - key or keys to unbind.\n     */\n    unbind(keys, undefined) {\n      [].concat(keys).map(function(key) {\n        callbacks[key] = undefined;\n      })\n    },\n\n    /**\n     * Returns whether a key is pressed.\n     * @memberof kontra.keys\n     *\n     * @param {string} key - Key to check for press.\n     *\n     * @returns {boolean}\n     */\n    pressed(key) {\n      return !!pressedKeys[key];\n    }\n  };\n})();\n(function() {\n  let pointer;\n\n  // save each object as they are rendered to determine which object\n  // is on top when multiple objects are the target of an event.\n  // we'll always use the last frame's object order so we know\n  // the finalized order of all objects, otherwise an object could ask\n  // if it's being hovered when it's rendered first even if other objects\n  // would block it later in the render order\n  let thisFrameRenderOrder = [];\n  let lastFrameRenderOrder = [];\n\n  let callbacks = {};\n  let trackedObjects = [];\n  let pressedButtons = {};\n\n  let buttonMap = {\n    0: 'left',\n    1: 'middle',\n    2: 'right'\n  };\n\n  addEventListener('mousedown', pointerDownHandler);\n  addEventListener('touchstart', pointerDownHandler);\n  addEventListener('mouseup', pointerUpHandler);\n  addEventListener('touchend', pointerUpHandler);\n  addEventListener('blur', blurEventHandler);\n  addEventListener('mousemove', mouseMoveHandler);\n\n  /**\n   * Detection collision between a rectangle and a circle.\n   * @see https://yal.cc/rectangle-circle-intersection-test/\n   * @private\n   *\n   * @param {object} object - Object to check collision against.\n   */\n  function circleRectCollision(object) {\n    let dx = pointer.x - Math.max(object.x, Math.min(pointer.x, object.x + object.width));\n    let dy = pointer.y - Math.max(object.y, Math.min(pointer.y, object.y + object.height));\n    return (dx * dx + dy * dy) < (pointer.radius * pointer.radius);\n  }\n\n  /**\n   * Get the first on top object that the pointer collides with.\n   * @private\n   *\n   * @returns {object} First object to collide with the pointer.\n   */\n  function getCurrentObject() {\n\n    // if pointer events are required on the very first frame or without a game loop,\n    // use the current frame order array\n    let frameOrder = (lastFrameRenderOrder.length ? lastFrameRenderOrder : thisFrameRenderOrder);\n    let length = frameOrder.length - 1;\n    let object, collides;\n\n    for (let i = length; i >= 0; i--) {\n      object = frameOrder[i];\n\n      if (object.collidesWithPointer) {\n        collides = object.collidesWithPointer(pointer);\n      }\n      else {\n        collides = circleRectCollision(object);\n      }\n\n      if (collides) {\n        return object;\n      }\n    }\n  }\n\n  /**\n   * Execute the onDown callback for an object.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function pointerDownHandler(e) {\n    pressedButtons[ buttonMap[e.button] ] = true;\n    pointerHandler(e, 'onDown');\n  }\n\n  /**\n   * Execute the onUp callback for an object.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function pointerUpHandler(e) {\n    pressedButtons[ buttonMap[e.button] ] = false;\n    pointerHandler(e, 'onUp');\n  }\n\n  /**\n   * Track the position of the mouse.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function mouseMoveHandler(e) {\n    pointerHandler(e, 'onOver');\n  }\n\n  /**\n   * Reset pressed buttons.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function blurEventHandler(e) {\n    pressedButtons = {};\n  }\n\n  /**\n   * Find the first object for the event and execute it's callback function\n   * @private\n   *\n   * @param {Event} e\n   * @param {string} event - Which event was called.\n   */\n  function pointerHandler(e, event) {\n    if (!kontra.canvas) return;\n\n    let clientX, clientY;\n\n    if (e.type.indexOf('mouse') !== -1) {\n      clientX = e.clientX;\n      clientY = e.clientY;\n    }\n    else {\n      // touchstart uses touches while touchend uses changedTouches\n      // @see https://stackoverflow.com/questions/17957593/how-to-capture-touchend-coordinates\n      clientX = (e.touches[0] || e.changedTouches[0]).clientX;\n      clientY = (e.touches[0] || e.changedTouches[0]).clientY;\n    }\n\n    pointer.x = clientX - kontra.canvas.offsetLeft;\n    pointer.y = clientY - kontra.canvas.offsetTop;\n\n    let object;\n    if (e.target === kontra.canvas) {\n      object = getCurrentObject();\n      if (object && object[event]) {\n        object[event]();\n      }\n    }\n\n    if (callbacks[event]) {\n      callbacks[event](e, object);\n    }\n  }\n\n  /**\n   * Object for using the pointer.\n   */\n  pointer = kontra.pointer = {\n    x: 0,\n    y: 0,\n    radius: 5,  // arbitrary size\n\n    /**\n     * Register object to be tracked by pointer events.\n     * @memberof kontra.pointer\n     *\n     * @param {object|object[]} objects - Object or objects to track.\n     */\n    track(objects) {\n      [].concat(objects).map(function(object) {\n\n        // override the objects render function to keep track of render order\n        if (!object._r) {\n          object._r = object.render;\n\n          object.render = function() {\n            thisFrameRenderOrder.push(this);\n            this._r();\n          };\n\n          trackedObjects.push(object);\n        }\n      });\n    },\n\n    /**\n     * Remove object from being tracked by pointer events.\n     * @memberof kontra.pointer\n     *\n     * @param {object|object[]} objects - Object or objects to stop tracking.\n     */\n    untrack(objects, undefined) {\n      [].concat(objects).map(function(object) {\n\n        // restore original render function to no longer track render order\n        object.render = object._r;\n        object._r = undefined;\n\n        let index = trackedObjects.indexOf(object);\n        if (index !== -1) {\n          trackedObjects.splice(index, 1);\n        }\n      })\n    },\n\n    /**\n     * Returns whether a tracked object is under the pointer.\n     * @memberof kontra.pointer\n     *\n     * @param {object} object - Object to check\n     *\n     * @returns {boolean}\n     */\n    over(object) {\n      if (trackedObjects.indexOf(object) === -1) return false;\n\n      return getCurrentObject() === object;\n    },\n\n    /**\n     * Register a function to be called on pointer down.\n     * @memberof kontra.pointer\n     *\n     * @param {function} callback - Function to execute\n     */\n    onDown(callback) {\n      callbacks.onDown = callback;\n    },\n\n    /**\n     * Register a function to be called on pointer up.\n     * @memberof kontra.pointer\n     *\n     * @param {function} callback - Function to execute\n     */\n    onUp(callback) {\n      callbacks.onUp = callback;\n    },\n\n    /**\n     * Returns whether the button is pressed.\n     * @memberof kontra.pointer\n     *\n     * @param {string} button - Button to check for press.\n     *\n     * @returns {boolean}\n     */\n    pressed(button) {\n      return !!pressedButtons[button]\n    }\n  };\n\n  // reset object render order on every new frame\n  kontra._tick = function() {\n    lastFrameRenderOrder.length = 0;\n\n    thisFrameRenderOrder.map(function(object) {\n      lastFrameRenderOrder.push(object);\n    });\n\n    thisFrameRenderOrder.length = 0;\n  };\n})();\n(function() {\n\n  /**\n   * Object pool. The pool will grow in size to accommodate as many objects as are needed.\n   * Unused items are at the front of the pool and in use items are at the of the pool.\n   * @memberof kontra\n   *\n   * @param {object} properties - Properties of the pool.\n   * @param {function} properties.create - Function that returns the object to use in the pool.\n   * @param {number} properties.maxSize - The maximum size that the pool will grow to.\n   */\n  kontra.pool = function(properties) {\n    properties = properties || {};\n\n    let inUse = 0;\n\n    // check for the correct structure of the objects added to pools so we know that the\n    // rest of the pool code will work without errors\n    // @if DEBUG\n    let obj;\n    if (!properties.create ||\n        ( !( obj = properties.create() ) ||\n          !( obj.update && obj.init &&\n             obj.isAlive )\n       )) {\n      throw Error('Must provide create() function which returns an object with init(), update(), and isAlive() functions');\n    }\n    // @endif\n\n    return {\n      _c: properties.create,\n\n      // start the pool with an object\n      objects: [properties.create()],\n      size: 1,\n      maxSize: properties.maxSize || Infinity,\n\n      /**\n       * Get an object from the pool.\n       * @memberof kontra.pool\n       *\n       * @param {object} properties - Properties to pass to object.init().\n       */\n      get(properties) {\n        properties = properties || {};\n\n        // the pool is out of objects if the first object is in use and it can't grow\n        if (this.objects[0].isAlive()) {\n          if (this.size === this.maxSize) {\n            return;\n          }\n          // double the size of the array by filling it with twice as many objects\n          else {\n            for (let x = 0; x < this.size && this.objects.length < this.maxSize; x++) {\n              this.objects.unshift(this._c());\n            }\n\n            this.size = this.objects.length;\n          }\n        }\n\n        // save off first object in pool to reassign to last object after unshift\n        let obj = this.objects.shift();\n        obj.init(properties);\n        this.objects.push(obj);\n        inUse++;\n      },\n\n      /**\n       * Return all objects that are alive from the pool.\n       * @memberof kontra.pool\n       *\n       * @returns {object[]}\n       */\n      getAliveObjects() {\n        return this.objects.slice(this.objects.length - inUse);\n      },\n\n      /**\n       * Clear the object pool.\n       * @memberof kontra.pool\n       */\n      clear() {\n        inUse = this.objects.length = 0;\n        this.size = 1;\n        this.objects.push(this._c());\n      },\n\n      /**\n       * Update all alive pool objects.\n       * @memberof kontra.pool\n       *\n       * @param {number} dt - Time since last update.\n       */\n      update(dt) {\n        let i = this.size - 1;\n        let obj;\n\n        // If the user kills an object outside of the update cycle, the pool won't know of\n        // the change until the next update and inUse won't be decremented. If the user then\n        // gets an object when inUse is the same size as objects.length, inUse will increment\n        // and this statement will evaluate to -1.\n        //\n        // I don't like having to go through the pool to kill an object as it forces you to\n        // know which object came from which pool. Instead, we'll just prevent the index from\n        // going below 0 and accept the fact that inUse may be out of sync for a frame.\n        let index = Math.max(this.objects.length - inUse, 0);\n\n        // only iterate over the objects that are alive\n        while (i >= index) {\n          obj = this.objects[i];\n\n          obj.update(dt);\n\n          // if the object is dead, move it to the front of the pool\n          if (!obj.isAlive()) {\n            this.objects = this.objects.splice(i, 1).concat(this.objects);\n            inUse--;\n            index++;\n          }\n          else {\n            i--;\n          }\n        }\n      },\n\n      /**\n       * render all alive pool objects.\n       * @memberof kontra.pool\n       */\n      render() {\n        let index = Math.max(this.objects.length - inUse, 0);\n\n        for (let i = this.size - 1; i >= index; i--) {\n          this.objects[i].render();\n        }\n      }\n    };\n  };\n})();\n(function() {\n\n  /**\n   * A quadtree for 2D collision checking. The quadtree acts like an object pool in that it\n   * will create subnodes as objects are needed but it won't clean up the subnodes when it\n   * collapses to avoid garbage collection.\n   * @memberof kontra\n   *\n   * @param {object} properties - Properties of the quadtree.\n   * @param {number} [properties.maxDepth=3] - Maximum node depths the quadtree can have.\n   * @param {number} [properties.maxObjects=25] - Maximum number of objects a node can support before splitting.\n   * @param {object} [properties.bounds] - The 2D space this node occupies.\n   * @param {object} [properties.parent] - Private. The node that contains this node.\n   * @param {number} [properties.depth=0] - Private. Current node depth.\n   *\n   * The quadrant indices are numbered as follows (following a z-order curve):\n   *     |\n   *  0  |  1\n   * ----+----\n   *  2  |  3\n   *     |\n   */\n  kontra.quadtree = function(properties) {\n    properties = properties || {};\n\n    return {\n      maxDepth: properties.maxDepth || 3,\n      maxObjects: properties.maxObjects || 25,\n\n      // since we won't clean up any subnodes, we need to keep track of which nodes are\n      // currently the leaf node so we know which nodes to add objects to\n      // b = branch, d = depth, p = parent\n      _b: false,\n      _d: properties.depth || 0,\n      /* @if VISUAL_DEBUG */\n      _p: properties.parent,\n      /* @endif */\n\n      bounds: properties.bounds || {\n        x: 0,\n        y: 0,\n        width: kontra.canvas.width,\n        height: kontra.canvas.height\n      },\n\n      objects: [],\n      subnodes: [],\n\n      /**\n       * Clear the quadtree\n       * @memberof kontra.quadtree\n       */\n      clear() {\n        this.subnodes.map(function(subnode) {\n          subnode.clear();\n        });\n\n        this._b = false;\n        this.objects.length = 0;\n      },\n\n      /**\n       * Find the leaf node the object belongs to and get all objects that are part of\n       * that node.\n       * @memberof kontra.quadtree\n       *\n       * @param {object} object - Object to use for finding the leaf node.\n       *\n       * @returns {object[]} A list of objects in the same leaf node as the object.\n       */\n      get(object) {\n        let objects = [];\n        let indices, i;\n\n        // traverse the tree until we get to a leaf node\n        while (this.subnodes.length && this._b) {\n          indices = this._g(object);\n\n          for (i = 0; i < indices.length; i++) {\n            objects.push.apply(objects, this.subnodes[ indices[i] ].get(object));\n          }\n\n          return objects;\n        }\n\n        return this.objects;\n      },\n\n      /**\n       * Add an object to the quadtree. Once the number of objects in the node exceeds\n       * the maximum number of objects allowed, it will split and move all objects to their\n       * corresponding subnodes.\n       * @memberof kontra.quadtree\n       *\n       * @param {...object|object[]} Objects to add to the quadtree\n       *\n       * @example\n       * kontra.quadtree().add({id:1}, {id:2}, {id:3});\n       * kontra.quadtree().add([{id:1}, {id:2}], {id:3});\n       */\n      add() {\n        let i, j, object, obj, indices, index;\n\n        for (j = 0; j < arguments.length; j++) {\n          object = arguments[j];\n\n          // add a group of objects separately\n          if (Array.isArray(object)) {\n            this.add.apply(this, object);\n\n            continue;\n          }\n\n          // current node has subnodes, so we need to add this object into a subnode\n          if (this._b) {\n            this._a(object);\n\n            continue;\n          }\n\n          // this node is a leaf node so add the object to it\n          this.objects.push(object);\n\n          // split the node if there are too many objects\n          if (this.objects.length > this.maxObjects && this._d < this.maxDepth) {\n            this._s();\n\n            // move all objects to their corresponding subnodes\n            for (i = 0; (obj = this.objects[i]); i++) {\n              this._a(obj);\n            }\n\n            this.objects.length = 0;\n          }\n        }\n      },\n\n      /**\n       * Add an object to a subnode.\n       * @memberof kontra.quadtree\n       * @private\n       *\n       * @param {object} object - Object to add into a subnode\n       */\n      // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#use-placeholder-arguments-instead-of-var\n      _a(object, indices, i) {\n        indices = this._g(object);\n\n        // add the object to all subnodes it intersects\n        for (i = 0; i < indices.length; i++) {\n          this.subnodes[ indices[i] ].add(object);\n        }\n      },\n\n      /**\n       * Determine which subnodes the object intersects with.\n       * @memberof kontra.quadtree\n       * @private\n       *\n       * @param {object} object - Object to check.\n       *\n       * @returns {number[]} List of all subnodes object intersects.\n       */\n      _g(object) {\n        let indices = [];\n\n        let verticalMidpoint = this.bounds.x + this.bounds.width / 2;\n        let horizontalMidpoint = this.bounds.y + this.bounds.height / 2;\n\n        // save off quadrant checks for reuse\n        let intersectsTopQuadrants = object.y < horizontalMidpoint && object.y + object.height >= this.bounds.y;\n        let intersectsBottomQuadrants = object.y + object.height >= horizontalMidpoint && object.y < this.bounds.y + this.bounds.height;\n\n        // object intersects with the left quadrants\n        if (object.x < verticalMidpoint && object.x + object.width >= this.bounds.x) {\n          if (intersectsTopQuadrants) {  // top left\n            indices.push(0);\n          }\n\n          if (intersectsBottomQuadrants) {  // bottom left\n            indices.push(2);\n          }\n        }\n\n        // object intersects with the right quadrants\n        if (object.x + object.width >= verticalMidpoint && object.x < this.bounds.x + this.bounds.width) {  // top right\n          if (intersectsTopQuadrants) {\n            indices.push(1);\n          }\n\n          if (intersectsBottomQuadrants) {  // bottom right\n            indices.push(3);\n          }\n        }\n\n        return indices;\n      },\n\n      /**\n       * Split the node into four subnodes.\n       * @memberof kontra.quadtree\n       * @private\n       */\n      // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#use-placeholder-arguments-instead-of-var\n      _s(subWidth, subHeight, i) {\n        this._b = true;\n\n        // only split if we haven't split before\n        if (this.subnodes.length) {\n          return;\n        }\n\n        subWidth = this.bounds.width / 2 | 0;\n        subHeight = this.bounds.height / 2 | 0;\n\n        for (i = 0; i < 4; i++) {\n          this.subnodes[i] = kontra.quadtree({\n            bounds: {\n              x: this.bounds.x + (i % 2 === 1 ? subWidth : 0),  // nodes 1 and 3\n              y: this.bounds.y + (i >= 2 ? subHeight : 0),      // nodes 2 and 3\n              width: subWidth,\n              height: subHeight\n            },\n            depth: this._d+1,\n            maxDepth: this.maxDepth,\n            maxObjects: this.maxObjects,\n            /* @if VISUAL_DEBUG */\n            parent: this\n            /* @endif */\n          });\n        }\n      },\n\n      /**\n       * Draw the quadtree. Useful for visual debugging.\n       * @memberof kontra.quadtree\n       */\n       /* @if VISUAL_DEBUG **\n       render() {\n         // don't draw empty leaf nodes, always draw branch nodes and the first node\n         if (this.objects.length || this._d === 0 ||\n             (this._p && this._p._b)) {\n\n           kontra.context.strokeStyle = 'red';\n           kontra.context.strokeRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);\n\n           if (this.subnodes.length) {\n             for (let i = 0; i < 4; i++) {\n               this.subnodes[i].render();\n             }\n           }\n         }\n       }\n       /* @endif */\n    };\n  };\n})();\n(function() {\n\n  class Vector {\n    /**\n     * Initialize the vectors x and y position.\n     * @memberof kontra.vector\n     * @private\n     *\n     * @param {number} [x=0] - X coordinate.\n     * @param {number} [y=0] - Y coordinate.\n     *\n     * @returns {vector}\n     */\n    constructor(x, y) {\n      this._x = x || 0;\n      this._y = y || 0;\n    }\n\n    /**\n     * Add a vector to this vector.\n     * @memberof kontra.vector\n     *\n     * @param {vector} vector - Vector to add.\n     * @param {number} dt=1 - Time since last update.\n     */\n    add(vector, dt) {\n      this.x += (vector.x || 0) * (dt || 1);\n      this.y += (vector.y || 0) * (dt || 1);\n    }\n\n    /**\n     * Clamp the vector between two points that form a rectangle.\n     * @memberof kontra.vector\n     *\n     * @param {number} xMin - Min x value.\n     * @param {number} yMin - Min y value.\n     * @param {number} xMax - Max x value.\n     * @param {number} yMax - Max y value.\n     */\n    clamp(xMin, yMin, xMax, yMax) {\n      this._c = true;\n      this._a = xMin;\n      this._b = yMin;\n      this._d = xMax;\n      this._e = yMax;\n    }\n\n    /**\n     * Vector x\n     * @memberof kontra.vector\n     *\n     * @property {number} x\n     */\n    get x() {\n      return this._x;\n    }\n\n    /**\n     * Vector y\n     * @memberof kontra.vector\n     *\n     * @property {number} y\n     */\n    get y() {\n      return this._y;\n    }\n\n    set x(value) {\n      this._x = (this._c ? Math.min( Math.max(this._a, value), this._d ) : value);\n    }\n\n    set y(value) {\n      this._y = (this._c ? Math.min( Math.max(this._b, value), this._e ) : value);\n    }\n  }\n\n  /**\n   * A vector for 2D space.\n   * @memberof kontra\n   *\n   * @param {number} [x=0] - X coordinate.\n   * @param {number} [y=0] - Y coordinate.\n   */\n  kontra.vector = (x, y) => {\n    return new Vector(x, y);\n  };\n  kontra.vector.prototype = Vector.prototype;\n\n\n\n\n\n  class Sprite {\n    /**\n     * Initialize properties on the sprite.\n     * @memberof kontra.sprite\n     *\n     * @param {object} properties - Properties of the sprite.\n     * @param {number} properties.x - X coordinate of the sprite.\n     * @param {number} properties.y - Y coordinate of the sprite.\n     * @param {number} [properties.dx] - Change in X position.\n     * @param {number} [properties.dy] - Change in Y position.\n     * @param {number} [properties.ddx] - Change in X velocity.\n     * @param {number} [properties.ddy] - Change in Y velocity.\n     *\n     * @param {number} [properties.ttl=0] - How may frames the sprite should be alive.\n     * @param {Context} [properties.context=kontra.context] - Provide a context for the sprite to draw on.\n     *\n     * @param {Image|Canvas} [properties.image] - Image for the sprite.\n     *\n     * @param {object} [properties.animations] - Animations for the sprite instead of an image.\n     *\n     * @param {string} [properties.color] - If no image or animation is provided, use color to draw a rectangle for the sprite.\n     * @param {number} [properties.width] - Width of the sprite for drawing a rectangle.\n     * @param {number} [properties.height] - Height of the sprite for drawing a rectangle.\n     *\n     * @param {function} [properties.update] - Function to use to update the sprite.\n     * @param {function} [properties.render] - Function to use to render the sprite.\n     *\n     * If you need the sprite to live forever, or just need it to stay on screen until you\n     * decide when to kill it, you can set <code>ttl</code> to <code>Infinity</code>.\n     * Just be sure to set <code>ttl</code> to 0 when you want the sprite to die.\n     */\n    // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#use-placeholder-arguments-instead-of-var\n    init(properties, prop, temp, firstAnimation) {\n      properties = properties || {};\n\n      this.position = kontra.vector(properties.x, properties.y);\n      this.velocity = kontra.vector(properties.dx, properties.dy);\n      this.acceleration = kontra.vector(properties.ddx, properties.ddy);\n\n      // defaults\n      this.width = this.height = 0;\n      this.context = kontra.context;\n\n      // loop through properties before overrides\n      for (prop in properties) {\n        this[prop] = properties[prop];\n      }\n\n      // image sprite\n      if (temp = properties.image) {\n        this.image = temp;\n        this.width = temp.width;\n        this.height = temp.height;\n      }\n      // animation sprite\n      else if (temp = properties.animations) {\n\n        // clone each animation so no sprite shares an animation\n        for (prop in temp) {\n          this.animations[prop] = temp[prop].clone();\n\n          // default the current animation to the first one in the list\n          firstAnimation = firstAnimation || temp[prop];\n        }\n\n        this._ca = firstAnimation;\n        this.width = firstAnimation.width;\n        this.height = firstAnimation.height;\n      }\n\n      return this;\n    }\n\n    // define getter and setter shortcut functions to make it easier to work with the\n    // position, velocity, and acceleration vectors.\n\n    /**\n     * Sprite position.x\n     * @memberof kontra.sprite\n     *\n     * @property {number} x\n     */\n    get x() {\n      return this.position.x;\n    }\n\n    /**\n     * Sprite position.y\n     * @memberof kontra.sprite\n     *\n     * @property {number} y\n     */\n    get y() {\n      return this.position.y;\n    }\n\n    /**\n     * Sprite velocity.x\n     * @memberof kontra.sprite\n     *\n     * @property {number} dx\n     */\n    get dx() {\n      return this.velocity.x;\n    }\n\n    /**\n     * Sprite velocity.y\n     * @memberof kontra.sprite\n     *\n     * @property {number} dy\n     */\n    get dy() {\n      return this.velocity.y;\n    }\n\n    /**\n     * Sprite acceleration.x\n     * @memberof kontra.sprite\n     *\n     * @property {number} ddx\n     */\n    get ddx() {\n      return this.acceleration.x;\n    }\n\n    /**\n     * Sprite acceleration.y\n     * @memberof kontra.sprite\n     *\n     * @property {number} ddy\n     */\n    get ddy() {\n      return this.acceleration.y;\n    }\n\n    set x(value) {\n      this.position.x = value;\n    }\n    set y(value) {\n      this.position.y = value;\n    }\n    set dx(value) {\n      this.velocity.x = value;\n    }\n    set dy(value) {\n      this.velocity.y = value;\n    }\n    set ddx(value) {\n      this.acceleration.x = value;\n    }\n    set ddy(value) {\n      this.acceleration.y = value;\n    }\n\n    /**\n     * Determine if the sprite is alive.\n     * @memberof kontra.sprite\n     *\n     * @returns {boolean}\n     */\n    isAlive() {\n      return this.ttl > 0;\n    }\n\n    /**\n     * Simple bounding box collision test.\n     * @memberof kontra.sprite\n     *\n     * @param {object} object - Object to check collision against.\n     *\n     * @returns {boolean} True if the objects collide, false otherwise.\n     */\n    collidesWith(object) {\n      return this.x < object.x + object.width &&\n             this.x + this.width > object.x &&\n             this.y < object.y + object.height &&\n             this.y + this.height > object.y;\n    }\n\n    /**\n     * Update the sprites velocity and position.\n     * @memberof kontra.sprite\n     * @abstract\n     *\n     * @param {number} dt - Time since last update.\n     *\n     * This function can be overridden on a per sprite basis if more functionality\n     * is needed in the update step. Just call <code>this.advance()</code> when you need\n     * the sprite to update its position.\n     *\n     * @example\n     * sprite = kontra.sprite({\n     *   update: function update(dt) {\n     *     // do some logic\n     *\n     *     this.advance(dt);\n     *   }\n     * });\n     */\n    update(dt) {\n      this.advance(dt);\n    }\n\n    /**\n     * Render the sprite.\n     * @memberof kontra.sprite.\n     * @abstract\n     *\n     * This function can be overridden on a per sprite basis if more functionality\n     * is needed in the render step. Just call <code>this.draw()</code> when you need the\n     * sprite to draw its image.\n     *\n     * @example\n     * sprite = kontra.sprite({\n     *   render: function render() {\n     *     // do some logic\n     *\n     *     this.draw();\n     *   }\n     * });\n     */\n    render() {\n      this.draw();\n    }\n\n    /**\n     * Play an animation.\n     * @memberof kontra.sprite\n     *\n     * @param {string} name - Name of the animation to play.\n     */\n    playAnimation(name) {\n      this._ca = this.animations[name];\n\n      if (!this._ca.loop) {\n        this._ca.reset();\n      }\n    }\n\n    /**\n     * Advance the sprites position, velocity, and current animation (if it\n     * has one).\n     * @memberof kontra.sprite\n     *\n     * @param {number} dt - Time since last update.\n     */\n    advance(dt) {\n      this.velocity.add(this.acceleration, dt);\n      this.position.add(this.velocity, dt);\n\n      this.ttl--;\n\n      if (this._ca) {\n        this._ca.update(dt);\n      }\n    }\n\n    /**\n     * Draw the sprite to the canvas.\n     * @memberof kontra.sprite\n     */\n    draw() {\n      if (this.image) {\n        this.context.drawImage(this.image, this.x, this.y);\n      }\n      else if (this._ca) {\n        this._ca.render(this);\n      }\n      else {\n        this.context.fillStyle = this.color;\n        this.context.fillRect(this.x, this.y, this.width, this.height);\n      }\n    }\n  };\n\n  /**\n   * A sprite with a position, velocity, and acceleration.\n   * @memberof kontra\n   * @requires kontra.vector\n   *\n   * @param {object} properties - Properties of the sprite.\n   * @param {number} properties.x - X coordinate of the sprite.\n   * @param {number} properties.y - Y coordinate of the sprite.\n   * @param {number} [properties.dx] - Change in X position.\n   * @param {number} [properties.dy] - Change in Y position.\n   * @param {number} [properties.ddx] - Change in X velocity.\n   * @param {number} [properties.ddy] - Change in Y velocity.\n   *\n   * @param {number} [properties.ttl=0] - How may frames the sprite should be alive.\n   * @param {Context} [properties.context=kontra.context] - Provide a context for the sprite to draw on.\n   *\n   * @param {Image|Canvas} [properties.image] - Image for the sprite.\n   *\n   * @param {object} [properties.animations] - Animations for the sprite instead of an image.\n   *\n   * @param {string} [properties.color] - If no image or animation is provided, use color to draw a rectangle for the sprite.\n   * @param {number} [properties.width] - Width of the sprite for drawing a rectangle.\n   * @param {number} [properties.height] - Height of the sprite for drawing a rectangle.\n   *\n   * @param {function} [properties.update] - Function to use to update the sprite.\n   * @param {function} [properties.render] - Function to use to render the sprite.\n   */\n  kontra.sprite = (properties) => {\n    return (new Sprite()).init(properties);\n  };\n  kontra.sprite.prototype = Sprite.prototype;\n})();\n(function() {\n\n  class Animation {\n    /**\n     * Initialize properties on the animation.\n     * @memberof kontra.animation\n     * @private\n     *\n     * @param {object} properties - Properties of the animation.\n     * @param {object} properties.spriteSheet - Sprite sheet for the animation.\n     * @param {number[]} properties.frames - List of frames of the animation.\n     * @param {number}  properties.frameRate - Number of frames to display in one second.\n     * @param {boolean} [properties.loop=true] - If the animation should loop.\n     */\n    // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#use-placeholder-arguments-instead-of-var\n    constructor(properties, frame) {\n      properties = properties || {};\n\n      this.spriteSheet = properties.spriteSheet;\n      this.frames = properties.frames;\n      this.frameRate = properties.frameRate;\n      this.loop = (properties.loop === undefined ? true : properties.loop);\n\n      frame = properties.spriteSheet.frame;\n      this.width = frame.width;\n      this.height = frame.height;\n      this.margin = frame.margin || 0;\n\n      // f = frame, a = accumulator\n      this._f = 0;\n      this._a = 0;\n    }\n\n    /**\n     * Clone an animation to be used more than once.\n     * @memberof kontra.animation\n     *\n     * @returns {object}\n     */\n    clone() {\n      return kontra.animation(this);\n    }\n\n    /**\n     * Reset an animation to the first frame.\n     * @memberof kontra.animation\n     */\n    reset() {\n      this._f = 0;\n      this._a = 0;\n    }\n\n    /**\n     * Update the animation. Used when the animation is not paused or stopped.\n     * @memberof kontra.animation\n     * @private\n     *\n     * @param {number} [dt=1/60] - Time since last update.\n     */\n    update(dt) {\n\n      // if the animation doesn't loop we stop at the last frame\n      if (!this.loop && this._f == this.frames.length-1) return;\n\n      dt = dt || 1 / 60;\n\n      this._a += dt;\n\n      // update to the next frame if it's time\n      while (this._a * this.frameRate >= 1) {\n        this._f = ++this._f % this.frames.length;\n        this._a -= 1 / this.frameRate;\n      }\n    }\n\n    /**\n     * Draw the current frame. Used when the animation is not stopped.\n     * @memberof kontra.animation\n     * @private\n     *\n     * @param {object} properties - How to draw the animation.\n     * @param {number} properties.x - X position to draw.\n     * @param {number} properties.y - Y position to draw.\n     * @param {Context} [properties.context=kontra.context] - Provide a context for the sprite to draw on.\n     */\n    render(properties) {\n      properties = properties || {};\n\n      // get the row and col of the frame\n      let row = this.frames[this._f] / this.spriteSheet._f | 0;\n      let col = this.frames[this._f] % this.spriteSheet._f | 0;\n\n      (properties.context || kontra.context).drawImage(\n        this.spriteSheet.image,\n        col * this.width + (col * 2 + 1) * this.margin,\n        row * this.height + (row * 2 + 1) * this.margin,\n        this.width, this.height,\n        properties.x, properties.y,\n        this.width, this.height\n      );\n    }\n  }\n\n  /**\n   * Single animation from a sprite sheet.\n   * @memberof kontra\n   *\n   * @param {object} properties - Properties of the animation.\n   * @param {object} properties.spriteSheet - Sprite sheet for the animation.\n   * @param {number[]} properties.frames - List of frames of the animation.\n   * @param {number}  properties.frameRate - Number of frames to display in one second.\n   */\n  kontra.animation = function(properties) {\n    return new Animation(properties);\n  };\n  kontra.animation.prototype = Animation.prototype;\n\n\n\n\n\n  class SpriteSheet {\n    /**\n     * Initialize properties on the spriteSheet.\n     * @memberof kontra\n     * @private\n     *\n     * @param {object} properties - Properties of the sprite sheet.\n     * @param {Image|Canvas} properties.image - Image for the sprite sheet.\n     * @param {number} properties.frameWidth - Width (in px) of each frame.\n     * @param {number} properties.frameHeight - Height (in px) of each frame.\n     * @param {number} properties.frameMargin - Margin (in px) between each frame.\n     * @param {object} properties.animations - Animations to create from the sprite sheet.\n     */\n    constructor(properties) {\n      properties = properties || {};\n\n      // @if DEBUG\n      if (!properties.image) {\n        throw Error('You must provide an Image for the SpriteSheet');\n      }\n      // @endif\n\n      this.animations = {};\n      this.image = properties.image;\n      this.frame = {\n        width: properties.frameWidth,\n        height: properties.frameHeight,\n        margin: properties.frameMargin\n      };\n\n      // f = framesPerRow\n      this._f = properties.image.width / properties.frameWidth | 0;\n\n      this.createAnimations(properties.animations);\n    }\n\n    /**\n     * Create animations from the sprite sheet.\n     * @memberof kontra.spriteSheet\n     *\n     * @param {object} animations - List of named animations to create from the Image.\n     * @param {number|string|number[]|string[]} animations.animationName.frames - A single frame or list of frames for this animation.\n     * @param {number} animations.animationName.frameRate - Number of frames to display in one second.\n     *\n     * @example\n     * let sheet = kontra.spriteSheet({image: img, frameWidth: 16, frameHeight: 16});\n     * sheet.createAnimations({\n     *   idle: {\n     *     frames: 1  // single frame animation\n     *   },\n     *   walk: {\n     *     frames: '2..6',  // ascending consecutive frame animation (frames 2-6, inclusive)\n     *     frameRate: 4\n     *   },\n     *   moonWalk: {\n     *     frames: '6..2',  // descending consecutive frame animation\n     *     frameRate: 4\n     *   },\n     *   jump: {\n     *     frames: [7, 12, 2],  // non-consecutive frame animation\n     *     frameRate: 3,\n     *     loop: false\n     *   },\n     *   attack: {\n     *     frames: ['8..10', 13, '10..8'],  // you can also mix and match, in this case frames [8,9,10,13,10,9,8]\n     *     frameRate: 2,\n     *     loop: false\n     *   }\n     * });\n     */\n    createAnimations(animations) {\n      let animation, frames, frameRate, sequence, name;\n\n      for (name in animations) {\n        animation = animations[name];\n        frames = animation.frames;\n\n        // array that holds the order of the animation\n        sequence = [];\n\n        // @if DEBUG\n        if (frames === undefined) {\n          throw Error('Animation ' + name + ' must provide a frames property');\n        }\n        // @endif\n\n        // add new frames to the end of the array\n        [].concat(frames).map(function(frame) {\n          sequence = sequence.concat(this._p(frame));\n        }, this);\n\n        this.animations[name] = kontra.animation({\n          spriteSheet: this,\n          frames: sequence,\n          frameRate: animation.frameRate,\n          loop: animation.loop\n        });\n      }\n    }\n\n    /**\n     * Parse a string of consecutive frames.\n     * @memberof kontra.spriteSheet\n     * @private\n     *\n     * @param {number|string} frames - Start and end frame.\n     *\n     * @returns {number[]} List of frames.\n     */\n    _p(consecutiveFrames, i) {\n      // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#coercion-to-test-for-types\n      if (+consecutiveFrames === consecutiveFrames) {\n        return consecutiveFrames;\n      }\n\n      let sequence = [];\n      let frames = consecutiveFrames.split('..');\n\n      // coerce string to number\n      // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#coercion-to-test-for-types\n      let start = i = +frames[0];\n      let end = +frames[1];\n\n      // ascending frame order\n      if (start < end) {\n        for (; i <= end; i++) {\n          sequence.push(i);\n        }\n      }\n      // descending order\n      else {\n        for (; i >= end; i--) {\n          sequence.push(i);\n        }\n      }\n\n      return sequence;\n    }\n  }\n\n  /**\n   * Create a sprite sheet from an image.\n   * @memberof kontra\n   *\n   * @param {object} properties - Properties of the sprite sheet.\n   * @param {Image|Canvas} properties.image - Image for the sprite sheet.\n   * @param {number} properties.frameWidth - Width (in px) of each frame.\n   * @param {number} properties.frameHeight - Height (in px) of each frame.\n   * @param {number} properties.frameMargin - Margin (in px) between each frame.\n   * @param {object} properties.animations - Animations to create from the sprite sheet.\n   */\n  kontra.spriteSheet = function(properties) {\n    return new SpriteSheet(properties);\n  };\n  kontra.spriteSheet.prototype = SpriteSheet.prototype;\n})();\n/**\n * Object for using localStorage.\n */\nkontra.store = {\n\n  /**\n   * Save an item to localStorage.\n   * @memberof kontra.store\n   *\n   * @param {string} key - Name to store the item as.\n   * @param {*} value - Item to store.\n   */\n  set(key, value) {\n    if (value === undefined) {\n      localStorage.removeItem(key);\n    }\n    else {\n      localStorage.setItem(key, JSON.stringify(value));\n    }\n  },\n\n  /**\n   * Retrieve an item from localStorage and convert it back to it's original type.\n   * @memberof kontra.store\n   *\n   * @param {string} key - Name of the item.\n   *\n   * @returns {*}\n   */\n  get(key) {\n    let value = localStorage.getItem(key);\n\n    try {\n      value = JSON.parse(value);\n    }\n    catch(e) {}\n\n    return value;\n  }\n};\n(function() {\n  // save Math.min and Math.max to variable and use that instead\n\n  /**\n   * A tile engine for rendering tilesets. Works well with the tile engine program Tiled.\n   * @memberof kontra\n   *\n   * @param {object} properties - Properties of the tile engine.\n   * @param {number} [properties.tileWidth=32] - Width of a tile.\n   * @param {number} [properties.tileHeight=32] - Height of a tile.\n   * @param {number} properties.width - Width of the map (in tiles).\n   * @param {number} properties.height - Height of the map (in tiles).\n   * @param {number} [properties.x=0] - X position to draw.\n   * @param {number} [properties.y=0] - Y position to draw.\n   * @param {number} [properties.sx=0] - X position to clip the tileset.\n   * @param {number} [properties.sy=0] - Y position to clip the tileset.\n   * @param {Context} [properties.context=kontra.context] - Provide a context for the tile engine to draw on.\n   */\n  kontra.tileEngine = function(properties) {\n    properties = properties || {};\n\n    // size of the map (in tiles)\n    // @if DEBUG\n    if (!properties.width || !properties.height) {\n      throw Error('You must provide width and height properties');\n    }\n    // @endif\n\n    /**\n     * Get the index of the x, y or row, col.\n     * @memberof kontra.tileEngine\n     * @private\n     *\n     * @param {number} position.x - X coordinate of the tile.\n     * @param {number} position.y - Y coordinate of the tile.\n     * @param {number} position.row - Row of the tile.\n     * @param {number} position.col - Col of the tile.\n     *\n     * @return {number} Returns the tile index or -1 if the x, y or row, col is outside the dimensions of the tile engine.\n     */\n    function getIndex(position) {\n      let row, col;\n\n      if (typeof position.x !== 'undefined' && typeof position.y !== 'undefined') {\n        row = tileEngine.getRow(position.y);\n        col = tileEngine.getCol(position.x);\n      }\n      else {\n        row = position.row;\n        col = position.col;\n      }\n\n      // don't calculate out of bound numbers\n      if (row < 0 || col < 0 || row >= height || col >= width) {\n        return -1;\n      }\n\n      return col + row * width;\n    }\n\n    /**\n     * Modified binary search that will return the tileset associated with the tile\n     * @memberof kontra.tileEngine\n     * @private\n     *\n     * @param {number} tile - Tile grid.\n     *\n     * @return {object}\n     */\n    function getTileset(tile) {\n      let min = 0;\n      let max = tileEngine.tilesets.length - 1;\n      let index, currTile;\n\n      while (min <= max) {\n        index = (min + max) / 2 | 0;\n        currTile = tileEngine.tilesets[index];\n\n        if (tile >= currTile.firstGrid && tile <= currTile.lastGrid) {\n          return currTile;\n        }\n        else if (currTile.lastGrid < tile) {\n          min = index + 1;\n        }\n        else {\n          max = index - 1;\n        }\n      }\n    }\n\n    /**\n     * Pre-render the tiles to make drawing fast.\n     * @memberof kontra.tileEngine\n     * @private\n     */\n    function preRenderImage() {\n      let tile, tileset, image, x, y, sx, sy, tileOffset, w;\n\n      // draw each layer in order\n      for (let i = 0, layer; layer = tileEngine.layers[layerOrder[i]]; i++) {\n        for (let j = 0, len = layer.data.length; j < len; j++) {\n          tile = layer.data[j];\n\n          // skip empty tiles (0)\n          if (!tile) {\n            continue;\n          }\n\n          tileset = getTileset(tile);\n          image = tileset.image;\n\n          x = (j % width) * tileWidth;\n          y = (j / width | 0) * tileHeight;\n\n          tileOffset = tile - tileset.firstGrid;\n          w = image.width / tileWidth;\n\n          sx = (tileOffset % w) * tileWidth;\n          sy = (tileOffset / w | 0) * tileHeight;\n\n          offscreenContext.drawImage(\n            image,\n            sx, sy, tileWidth, tileHeight,\n            x, y, tileWidth, tileHeight\n          );\n        }\n      }\n    }\n\n    let width = properties.width;\n    let height = properties.height;\n\n    // size of the tiles. Most common tile size on opengameart.org seems to be 32x32,\n    // followed by 16x16\n    // Tiled names the property tilewidth and tileheight\n    let tileWidth = properties.tileWidth || properties.tilewidth || 32;\n    let tileHeight = properties.tileHeight || properties.tileheight || 32;\n\n    let mapWidth = width * tileWidth;\n    let mapHeight = height * tileHeight;\n\n    let context = properties.context || kontra.context;\n    let canvasWidth = context.canvas.width;\n    let canvasHeight = context.canvas.height;\n\n    // create an off-screen canvas for pre-rendering the map\n    // @see http://jsperf.com/render-vs-prerender\n    let offscreenCanvas = document.createElement('canvas');\n    let offscreenContext = offscreenCanvas.getContext('2d');\n\n    // when clipping an image, sx and sy must within the image region, otherwise\n    // Firefox and Safari won't draw it.\n    // @see http://stackoverflow.com/questions/19338032/canvas-indexsizeerror-index-or-size-is-negative-or-greater-than-the-allowed-a\n    let sxMax = Math.max(0, mapWidth - canvasWidth);\n    let syMax = Math.max(0, mapHeight - canvasHeight);\n\n    let _sx, _sy;\n\n    // draw order of layers (by name)\n    let layerOrder = [];\n\n    let tileEngine = {\n      width: width,\n      height: height,\n\n      tileWidth: tileWidth,\n      tileHeight: tileHeight,\n\n      mapWidth: mapWidth,\n      mapHeight: mapHeight,\n\n      context: context,\n\n      x: properties.x || 0,\n      y: properties.y || 0,\n\n      tilesets: [],\n      layers: {},\n\n      /**\n       * Add an tileset for the tile engine to use.\n       * @memberof kontra.tileEngine\n       *\n       * @param {object|object[]} tileset - Properties of the image to add.\n       * @param {Image|Canvas} tileset.image - Path to the image or Image object.\n       * @param {number} tileset.firstGrid - The first tile grid to start the image.\n       */\n      addTilesets: function addTilesets(tilesets) {\n        [].concat(tilesets).map(function(tileset) {\n          let tilesetImage = tileset.image;\n          let image, firstGrid, numTiles, lastTileset, tiles;\n\n          // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#coercion-to-test-for-types\n          if (''+tilesetImage === tilesetImage) {\n            let i = Infinity;\n\n            while (i >= 0) {\n              i = tilesetImage.lastIndexOf('/', i);\n              let path = (i < 0 ? tilesetImage : tilesetImage.substr(i));\n\n              if (kontra.assets.images[path]) {\n                image = kontra.assets.images[path];\n                break;\n              }\n\n              i--;\n            }\n          }\n          else {\n            image = tilesetImage;\n          }\n\n          firstGrid = tileset.firstGrid;\n\n          // if the width or height of the provided image is smaller than the tile size,\n          // default calculation to 1\n          numTiles = ( (image.width / tileWidth | 0) || 1 ) *\n                     ( (image.height / tileHeight | 0) || 1 );\n\n          if (!firstGrid) {\n            // only calculate the first grid if the tile map has a tileset already\n            if (tileEngine.tilesets.length > 0) {\n              lastTileset = tileEngine.tilesets[tileEngine.tilesets.length - 1];\n              tiles = (lastTileset.image.width / tileWidth | 0) *\n                      (lastTileset.image.height / tileHeight | 0);\n\n              firstGrid = lastTileset.firstGrid + tiles;\n            }\n            // otherwise this is the first tile added to the tile map\n            else {\n              firstGrid = 1;\n            }\n          }\n\n          tileEngine.tilesets.push({\n            firstGrid: firstGrid,\n            lastGrid: firstGrid + numTiles - 1,\n            image: image\n          });\n\n          // sort the tile map so we can perform a binary search when drawing\n          tileEngine.tilesets.sort(function(a, b) {\n            return a.firstGrid - b.firstGrid;\n          });\n        });\n      },\n\n      /**\n       * Add a layer to the tile engine.\n       * @memberof kontra.tileEngine\n       *\n       * @param {object} properties - Properties of the layer to add.\n       * @param {string} properties.name - Name of the layer.\n       * @param {number[]} properties.data - Tile layer data.\n       * @param {boolean} [properties.render=true] - If the layer should be drawn.\n       * @param {number} [properties.zIndex] - Draw order for tile layer. Highest number is drawn last (i.e. on top of all other layers).\n       */\n      addLayers: function addLayers(layers) {\n        [].concat(layers).map(function(layer) {\n          layer.render = (layer.render === undefined ? true : layer.render);\n\n          let data, r, row, c, prop, value;\n\n          // flatten a 2D array into a single array\n          if (Array.isArray(layer.data[0])) {\n            data = [];\n\n            for (r = 0; row = layer.data[r]; r++) {\n              for (c = 0; c < width; c++) {\n                data.push(row[c] || 0);\n              }\n            }\n          }\n          else {\n            data = layer.data;\n          }\n\n          tileEngine.layers[layer.name] = {\n            data: data,\n            zIndex: layer.zIndex || 0,\n            render: layer.render\n          };\n\n          // merge properties of layer onto layer object\n          for (prop in layer.properties) {\n            value = layer.properties[prop];\n\n            try {\n              value = JSON.parse(value);\n            }\n            catch(e) {}\n\n            tileEngine.layers[layer.name][prop] = value;\n          }\n\n          // only add the layer to the layer order if it should be drawn\n          if (tileEngine.layers[layer.name].render) {\n            layerOrder.push(layer.name);\n\n            layerOrder.sort(function(a, b) {\n              return tileEngine.layers[a].zIndex - tileEngine.layers[b].zIndex;\n            });\n\n          }\n        });\n\n        preRenderImage();\n      },\n\n      /**\n       * Simple bounding box collision test for layer tiles.\n       * @memberof kontra.tileEngine\n       *\n       * @param {string} name - Name of the layer.\n       * @param {object} object - Object to check collision against.\n       * @param {number} object.x - X coordinate of the object.\n       * @param {number} object.y - Y coordinate of the object.\n       * @param {number} object.width - Width of the object.\n       * @param {number} object.height - Height of the object.\n       *\n       * @returns {boolean} True if the object collides with a tile, false otherwise.\n       */\n      layerCollidesWith: function layerCollidesWith(name, object) {\n        // calculate all tiles that the object can collide with\n        let row = tileEngine.getRow(object.y);\n        let col = tileEngine.getCol(object.x);\n\n        let endRow = tileEngine.getRow(object.y + object.height);\n        let endCol = tileEngine.getCol(object.x + object.width);\n\n        // check all tiles\n        let index;\n        for (let r = row; r <= endRow; r++) {\n          for (let c = col; c <= endCol; c++) {\n            index = getIndex({row: r, col: c});\n\n            if (tileEngine.layers[name].data[index]) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n      },\n\n      /**\n       * Get the tile from the specified layer at x, y or row, col.\n       * @memberof kontra.tileEngine\n       *\n       * @param {string} name - Name of the layer.\n       * @param {object} position - Position of the tile in either x, y or row, col.\n       * @param {number} position.x - X coordinate of the tile.\n       * @param {number} position.y - Y coordinate of the tile.\n       * @param {number} position.row - Row of the tile.\n       * @param {number} position.col - Col of the tile.\n       *\n       * @returns {number}\n       */\n      tileAtLayer: function tileAtLayer(name, position) {\n        let index = getIndex(position);\n\n        if (index >= 0) {\n          return tileEngine.layers[name].data[index];\n        }\n      },\n\n      /**\n       * Render the pre-rendered canvas.\n       * @memberof kontra.tileEngine\n       */\n      render: function render() {\n        /* istanbul ignore next */\n        tileEngine.context.drawImage(\n          offscreenCanvas,\n          tileEngine.sx, tileEngine.sy, canvasWidth, canvasHeight,\n          tileEngine.x, tileEngine.y, canvasWidth, canvasHeight\n        );\n      },\n\n      /**\n       * Render a specific layer.\n       * @memberof kontra.tileEngine\n       *\n       * @param {string} name - Name of the layer to render.\n       */\n      renderLayer: function renderLayer(name) {\n        let layer = tileEngine.layers[name];\n\n        // calculate the starting tile\n        let row = tileEngine.getRow();\n        let col = tileEngine.getCol();\n        let index = getIndex({row: row, col: col});\n\n        // calculate where to start drawing the tile relative to the drawing canvas\n        let startX = col * tileWidth - tileEngine.sx;\n        let startY = row * tileHeight - tileEngine.sy;\n\n        // calculate how many tiles the drawing canvas can hold\n        let viewWidth = Math.min(Math.ceil(canvasWidth / tileWidth) + 1, width);\n        let viewHeight = Math.min(Math.ceil(canvasHeight / tileHeight) + 1, height);\n        let numTiles = viewWidth * viewHeight;\n\n        let count = 0;\n        let x, y, tile, tileset, image, tileOffset, w, sx, sy;\n\n        // draw just enough of the layer to fit inside the drawing canvas\n        while (count < numTiles) {\n          tile = layer.data[index];\n\n          if (tile) {\n            tileset = getTileset(tile);\n            image = tileset.image;\n\n            x = startX + (count % viewWidth) * tileWidth;\n            y = startY + (count / viewWidth | 0) * tileHeight;\n\n            tileOffset = tile - tileset.firstGrid;\n            w = image.width / tileWidth;\n\n            sx = (tileOffset % w) * tileWidth;\n            sy = (tileOffset / w | 0) * tileHeight;\n\n            tileEngine.context.drawImage(\n              image,\n              sx, sy, tileWidth, tileHeight,\n              x, y, tileWidth, tileHeight\n            );\n          }\n\n          if (++count % viewWidth === 0) {\n            index = col + (++row * width);\n          }\n          else {\n            index++;\n          }\n        }\n      },\n\n      /**\n       * Get the row from the y coordinate.\n       * @memberof kontra.tileEngine\n       *\n       * @param {number} y - Y coordinate.\n       *\n       * @return {number}\n       */\n      getRow: function getRow(y) {\n        y = y || 0;\n\n        return (tileEngine.sy + y) / tileHeight | 0;\n      },\n\n      /**\n       * Get the col from the x coordinate.\n       * @memberof kontra.tileEngine\n       *\n       * @param {number} x - X coordinate.\n       *\n       * @return {number}\n       */\n      getCol: function getCol(x) {\n        x = x || 0;\n\n        return (tileEngine.sx + x) / tileWidth | 0;\n      },\n\n      get sx() {\n        return _sx;\n      },\n\n      get sy() {\n        return _sy;\n      },\n\n      // ensure sx and sy are within the image region\n      set sx(value) {\n        _sx = Math.min( Math.max(0, value), sxMax );\n      },\n\n      set sy(value) {\n        _sy = Math.min( Math.max(0, value), syMax );\n      },\n\n      // expose properties for testing\n      // @if DEBUG\n      _layerOrder: layerOrder\n      // @endif\n    };\n\n    // set here so we use setter function\n    tileEngine.sx = properties.sx || 0;\n    tileEngine.sy = properties.sy || 0;\n\n    // make the off-screen canvas the full size of the map\n    offscreenCanvas.width = mapWidth;\n    offscreenCanvas.height = mapHeight;\n\n    // merge properties of the tile engine onto the tile engine itself\n    for (let prop in properties.properties) {\n      let value = properties.properties[prop];\n\n      try {\n        value = JSON.parse(value);\n      }\n      catch(e) {}\n\n      // passed in properties override properties.properties\n      tileEngine[prop] = tileEngine[prop] || value;\n    }\n\n    if (properties.tilesets) {\n      tileEngine.addTilesets(properties.tilesets);\n    }\n\n    if (properties.layers) {\n      tileEngine.addLayers(properties.layers);\n    }\n\n    return tileEngine;\n  };\n})();"},function(e,n,t){var r=t(5);"string"==typeof r&&(r=[[e.i,r,""]]);var i={hmr:!0,transform:void 0,insertInto:void 0};t(7)(r,i);r.locals&&(e.exports=r.locals)},function(e,n,t){(e.exports=t(6)(!1)).push([e.i,"body {\n  background: black;\n}\ncanvas {\n  border: 1px solid white;\n}\n",""])},function(e,n){e.exports=function(e){var n=[];return n.toString=function(){return this.map(function(n){var t=function(e,n){var t=e[1]||"",r=e[3];if(!r)return t;if(n&&"function"==typeof btoa){var i=function(e){return"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(e))))+" */"}(r),o=r.sources.map(function(e){return"/*# sourceURL="+r.sourceRoot+e+" */"});return[t].concat(o).concat([i]).join("\n")}return[t].join("\n")}(n,e);return n[2]?"@media "+n[2]+"{"+t+"}":t}).join("")},n.i=function(e,t){"string"==typeof e&&(e=[[null,e,""]]);for(var r={},i=0;i<this.length;i++){var o=this[i][0];"number"==typeof o&&(r[o]=!0)}for(i=0;i<e.length;i++){var a=e[i];"number"==typeof a[0]&&r[a[0]]||(t&&!a[2]?a[2]=t:t&&(a[2]="("+a[2]+") and ("+t+")"),n.push(a))}},n}},function(e,n,t){var r={},i=function(e){var n;return function(){return void 0===n&&(n=e.apply(this,arguments)),n}}(function(){return window&&document&&document.all&&!window.atob}),o=function(e){var n={};return function(e,t){if("function"==typeof e)return e();if(void 0===n[e]){var r=function(e,n){return n?n.querySelector(e):document.querySelector(e)}.call(this,e,t);if(window.HTMLIFrameElement&&r instanceof window.HTMLIFrameElement)try{r=r.contentDocument.head}catch(e){r=null}n[e]=r}return n[e]}}(),a=null,s=0,l=[],p=t(8);function c(e,n){for(var t=0;t<e.length;t++){var i=e[t],o=r[i.id];if(o){o.refs++;for(var a=0;a<o.parts.length;a++)o.parts[a](i.parts[a]);for(;a<i.parts.length;a++)o.parts.push(b(i.parts[a],n))}else{var s=[];for(a=0;a<i.parts.length;a++)s.push(b(i.parts[a],n));r[i.id]={id:i.id,refs:1,parts:s}}}}function d(e,n){for(var t=[],r={},i=0;i<e.length;i++){var o=e[i],a=n.base?o[0]+n.base:o[0],s={css:o[1],media:o[2],sourceMap:o[3]};r[a]?r[a].parts.push(s):t.push(r[a]={id:a,parts:[s]})}return t}function h(e,n){var t=o(e.insertInto);if(!t)throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");var r=l[l.length-1];if("top"===e.insertAt)r?r.nextSibling?t.insertBefore(n,r.nextSibling):t.appendChild(n):t.insertBefore(n,t.firstChild),l.push(n);else if("bottom"===e.insertAt)t.appendChild(n);else{if("object"!=typeof e.insertAt||!e.insertAt.before)throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");var i=o(e.insertAt.before,t);t.insertBefore(n,i)}}function m(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e);var n=l.indexOf(e);n>=0&&l.splice(n,1)}function u(e){var n=document.createElement("style");if(void 0===e.attrs.type&&(e.attrs.type="text/css"),void 0===e.attrs.nonce){var r=function(){0;return t.nc}();r&&(e.attrs.nonce=r)}return f(n,e.attrs),h(e,n),n}function f(e,n){Object.keys(n).forEach(function(t){e.setAttribute(t,n[t])})}function b(e,n){var t,r,i,o;if(n.transform&&e.css){if(!(o=n.transform(e.css)))return function(){};e.css=o}if(n.singleton){var l=s++;t=a||(a=u(n)),r=y.bind(null,t,l,!1),i=y.bind(null,t,l,!0)}else e.sourceMap&&"function"==typeof URL&&"function"==typeof URL.createObjectURL&&"function"==typeof URL.revokeObjectURL&&"function"==typeof Blob&&"function"==typeof btoa?(t=function(e){var n=document.createElement("link");return void 0===e.attrs.type&&(e.attrs.type="text/css"),e.attrs.rel="stylesheet",f(n,e.attrs),h(e,n),n}(n),r=function(e,n,t){var r=t.css,i=t.sourceMap,o=void 0===n.convertToAbsoluteUrls&&i;(n.convertToAbsoluteUrls||o)&&(r=p(r));i&&(r+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(i))))+" */");var a=new Blob([r],{type:"text/css"}),s=e.href;e.href=URL.createObjectURL(a),s&&URL.revokeObjectURL(s)}.bind(null,t,n),i=function(){m(t),t.href&&URL.revokeObjectURL(t.href)}):(t=u(n),r=function(e,n){var t=n.css,r=n.media;r&&e.setAttribute("media",r);if(e.styleSheet)e.styleSheet.cssText=t;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(t))}}.bind(null,t),i=function(){m(t)});return r(e),function(n){if(n){if(n.css===e.css&&n.media===e.media&&n.sourceMap===e.sourceMap)return;r(e=n)}else i()}}e.exports=function(e,n){if("undefined"!=typeof DEBUG&&DEBUG&&"object"!=typeof document)throw new Error("The style-loader cannot be used in a non-browser environment");(n=n||{}).attrs="object"==typeof n.attrs?n.attrs:{},n.singleton||"boolean"==typeof n.singleton||(n.singleton=i()),n.insertInto||(n.insertInto="head"),n.insertAt||(n.insertAt="bottom");var t=d(e,n);return c(t,n),function(e){for(var i=[],o=0;o<t.length;o++){var a=t[o];(s=r[a.id]).refs--,i.push(s)}e&&c(d(e,n),n);for(o=0;o<i.length;o++){var s;if(0===(s=i[o]).refs){for(var l=0;l<s.parts.length;l++)s.parts[l]();delete r[s.id]}}}};var g=function(){var e=[];return function(n,t){return e[n]=t,e.filter(Boolean).join("\n")}}();function y(e,n,t,r){var i=t?"":r.css;if(e.styleSheet)e.styleSheet.cssText=g(n,i);else{var o=document.createTextNode(i),a=e.childNodes;a[n]&&e.removeChild(a[n]),a.length?e.insertBefore(o,a[n]):e.appendChild(o)}}},function(e,n){e.exports=function(e){var n="undefined"!=typeof window&&window.location;if(!n)throw new Error("fixUrls requires window.location");if(!e||"string"!=typeof e)return e;var t=n.protocol+"//"+n.host,r=t+n.pathname.replace(/\/[^\/]*$/,"/");return e.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi,function(e,n){var i,o=n.trim().replace(/^"(.*)"$/,function(e,n){return n}).replace(/^'(.*)'$/,function(e,n){return n});return/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(o)?e:(i=0===o.indexOf("//")?o:0===o.indexOf("/")?t+o:r+o.replace(/^\.\//,""),"url("+JSON.stringify(i)+")")})}}]);